// Copyright 2025 xinchentechnote
// Code generated by fin-protoc. DO NOT EDIT.
#pragma once
#include <cstdint>
#include <functional>
#include <iomanip>
#include <memory>
#include <string>
#include <unordered_map>
#include <vector>
#include <iostream>
#include "include/codec.hpp"
#include "include/bytebuf.hpp"
#include "include/checksum.hpp"
#include "message_factory.hpp"

struct Logon : public codec::BinaryCodec {
    std::string senderCompId;
    std::string targetCompId;
    int32_t heartBtint;
    std::string password;
    std::string defaultApplVerId;

    void encode(ByteBuf& buf) const override {
        codec::write_fixed_string(buf, senderCompId, 20);
        codec::write_fixed_string(buf, targetCompId, 20);
        buf.write_i32(heartBtint);
        codec::write_fixed_string(buf, password, 16);
        codec::write_fixed_string(buf, defaultApplVerId, 32);
    }
    

    void decode(ByteBuf& buf) override {
        senderCompId = codec::read_fixed_string(buf, 20);
        targetCompId = codec::read_fixed_string(buf, 20);
        heartBtint = buf.read_i32();
        password = codec::read_fixed_string(buf, 16);
        defaultApplVerId = codec::read_fixed_string(buf, 32);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const Logon*>(&other);
        if(!checkType) return false;
        return senderCompId == checkType->senderCompId
               && targetCompId == checkType->targetCompId
               && heartBtint == checkType->heartBtint
               && password == checkType->password
               && defaultApplVerId == checkType->defaultApplVerId;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "Logon { "
        << "SenderCompID: " << senderCompId
        << ", "
        << "TargetCompID: " << targetCompId
        << ", "
        << "HeartBtint: " << std::to_string(heartBtint)
        << ", "
        << "Password: " << password
        << ", "
        << "DefaultApplVerID: " << defaultApplVerId
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const Logon& pkt) {
    return os << pkt.toString();
}


struct Logout : public codec::BinaryCodec {
    int32_t sessionStatus;
    std::string text;

    void encode(ByteBuf& buf) const override {
        buf.write_i32(sessionStatus);
        codec::write_fixed_string(buf, text, 200);
    }
    

    void decode(ByteBuf& buf) override {
        sessionStatus = buf.read_i32();
        text = codec::read_fixed_string(buf, 200);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const Logout*>(&other);
        if(!checkType) return false;
        return sessionStatus == checkType->sessionStatus
               && text == checkType->text;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "Logout { "
        << "SessionStatus: " << std::to_string(sessionStatus)
        << ", "
        << "Text: " << text
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const Logout& pkt) {
    return os << pkt.toString();
}


struct Heartbeat : public codec::BinaryCodec {

    void encode(ByteBuf& buf) const override {
    }
    

    void decode(ByteBuf& buf) override {
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const Heartbeat*>(&other);
        if(!checkType) return false;
        return true;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "Heartbeat { "
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const Heartbeat& pkt) {
    return os << pkt.toString();
}


struct Extend100101 : public codec::BinaryCodec {
    int64_t stopPx;
    int64_t minQty;
    uint16_t maxPriceLevels;
    std::string timeInForce;
    std::string cashMargin;

    void encode(ByteBuf& buf) const override {
        buf.write_i64(stopPx);
        buf.write_i64(minQty);
        buf.write_u16(maxPriceLevels);
        codec::write_fixed_string(buf, timeInForce, 1);
        codec::write_fixed_string(buf, cashMargin, 1);
    }
    

    void decode(ByteBuf& buf) override {
        stopPx = buf.read_i64();
        minQty = buf.read_i64();
        maxPriceLevels = buf.read_u16();
        timeInForce = codec::read_fixed_string(buf, 1);
        cashMargin = codec::read_fixed_string(buf, 1);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const Extend100101*>(&other);
        if(!checkType) return false;
        return stopPx == checkType->stopPx
               && minQty == checkType->minQty
               && maxPriceLevels == checkType->maxPriceLevels
               && timeInForce == checkType->timeInForce
               && cashMargin == checkType->cashMargin;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "Extend100101 { "
        << "StopPx: " << std::to_string(stopPx)
        << ", "
        << "MinQty: " << std::to_string(minQty)
        << ", "
        << "MaxPriceLevels: " << std::to_string(maxPriceLevels)
        << ", "
        << "TimeInForce: " << timeInForce
        << ", "
        << "CashMargin: " << cashMargin
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const Extend100101& pkt) {
    return os << pkt.toString();
}


struct Extend100201 : public codec::BinaryCodec {
    int64_t stopPx;
    int64_t minQty;
    uint16_t maxPriceLevels;
    std::string timeInForce;

    void encode(ByteBuf& buf) const override {
        buf.write_i64(stopPx);
        buf.write_i64(minQty);
        buf.write_u16(maxPriceLevels);
        codec::write_fixed_string(buf, timeInForce, 1);
    }
    

    void decode(ByteBuf& buf) override {
        stopPx = buf.read_i64();
        minQty = buf.read_i64();
        maxPriceLevels = buf.read_u16();
        timeInForce = codec::read_fixed_string(buf, 1);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const Extend100201*>(&other);
        if(!checkType) return false;
        return stopPx == checkType->stopPx
               && minQty == checkType->minQty
               && maxPriceLevels == checkType->maxPriceLevels
               && timeInForce == checkType->timeInForce;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "Extend100201 { "
        << "StopPx: " << std::to_string(stopPx)
        << ", "
        << "MinQty: " << std::to_string(minQty)
        << ", "
        << "MaxPriceLevels: " << std::to_string(maxPriceLevels)
        << ", "
        << "TimeInForce: " << timeInForce
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const Extend100201& pkt) {
    return os << pkt.toString();
}


struct Extend100301 : public codec::BinaryCodec {
    int64_t stopPx;
    int64_t minQty;
    uint16_t maxPriceLevels;
    std::string timeInForce;

    void encode(ByteBuf& buf) const override {
        buf.write_i64(stopPx);
        buf.write_i64(minQty);
        buf.write_u16(maxPriceLevels);
        codec::write_fixed_string(buf, timeInForce, 1);
    }
    

    void decode(ByteBuf& buf) override {
        stopPx = buf.read_i64();
        minQty = buf.read_i64();
        maxPriceLevels = buf.read_u16();
        timeInForce = codec::read_fixed_string(buf, 1);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const Extend100301*>(&other);
        if(!checkType) return false;
        return stopPx == checkType->stopPx
               && minQty == checkType->minQty
               && maxPriceLevels == checkType->maxPriceLevels
               && timeInForce == checkType->timeInForce;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "Extend100301 { "
        << "StopPx: " << std::to_string(stopPx)
        << ", "
        << "MinQty: " << std::to_string(minQty)
        << ", "
        << "MaxPriceLevels: " << std::to_string(maxPriceLevels)
        << ", "
        << "TimeInForce: " << timeInForce
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const Extend100301& pkt) {
    return os << pkt.toString();
}


struct Extend100501 : public codec::BinaryCodec {
    std::string confirmId;
    std::string cashMargin;

    void encode(ByteBuf& buf) const override {
        codec::write_fixed_string(buf, confirmId, 8);
        codec::write_fixed_string(buf, cashMargin, 1);
    }
    

    void decode(ByteBuf& buf) override {
        confirmId = codec::read_fixed_string(buf, 8);
        cashMargin = codec::read_fixed_string(buf, 1);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const Extend100501*>(&other);
        if(!checkType) return false;
        return confirmId == checkType->confirmId
               && cashMargin == checkType->cashMargin;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "Extend100501 { "
        << "ConfirmID: " << confirmId
        << ", "
        << "CashMargin: " << cashMargin
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const Extend100501& pkt) {
    return os << pkt.toString();
}


struct Extend100601 : public codec::BinaryCodec {
    std::string cashMargin;

    void encode(ByteBuf& buf) const override {
        codec::write_fixed_string(buf, cashMargin, 1);
    }
    

    void decode(ByteBuf& buf) override {
        cashMargin = codec::read_fixed_string(buf, 1);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const Extend100601*>(&other);
        if(!checkType) return false;
        return cashMargin == checkType->cashMargin;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "Extend100601 { "
        << "CashMargin: " << cashMargin
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const Extend100601& pkt) {
    return os << pkt.toString();
}


struct Extend100701 : public codec::BinaryCodec {
    uint16_t expirationDays;
    uint8_t expirationType;
    std::string shareProperty;

    void encode(ByteBuf& buf) const override {
        buf.write_u16(expirationDays);
        buf.write_u8(expirationType);
        codec::write_fixed_string(buf, shareProperty, 2);
    }
    

    void decode(ByteBuf& buf) override {
        expirationDays = buf.read_u16();
        expirationType = buf.read_u8();
        shareProperty = codec::read_fixed_string(buf, 2);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const Extend100701*>(&other);
        if(!checkType) return false;
        return expirationDays == checkType->expirationDays
               && expirationType == checkType->expirationType
               && shareProperty == checkType->shareProperty;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "Extend100701 { "
        << "ExpirationDays: " << std::to_string(expirationDays)
        << ", "
        << "ExpirationType: " << static_cast<unsigned>(expirationType)
        << ", "
        << "ShareProperty: " << shareProperty
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const Extend100701& pkt) {
    return os << pkt.toString();
}


struct Extend101501 : public codec::BinaryCodec {
    std::string shareProperty;

    void encode(ByteBuf& buf) const override {
        codec::write_fixed_string(buf, shareProperty, 2);
    }
    

    void decode(ByteBuf& buf) override {
        shareProperty = codec::read_fixed_string(buf, 2);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const Extend101501*>(&other);
        if(!checkType) return false;
        return shareProperty == checkType->shareProperty;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "Extend101501 { "
        << "ShareProperty: " << shareProperty
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const Extend101501& pkt) {
    return os << pkt.toString();
}


struct Extend101601 : public codec::BinaryCodec {
    std::string contractAccountCode;

    void encode(ByteBuf& buf) const override {
        codec::write_fixed_string(buf, contractAccountCode, 6);
    }
    

    void decode(ByteBuf& buf) override {
        contractAccountCode = codec::read_fixed_string(buf, 6);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const Extend101601*>(&other);
        if(!checkType) return false;
        return contractAccountCode == checkType->contractAccountCode;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "Extend101601 { "
        << "ContractAccountCode: " << contractAccountCode
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const Extend101601& pkt) {
    return os << pkt.toString();
}


struct Extend101701 : public codec::BinaryCodec {
    int64_t cashOrderQty;

    void encode(ByteBuf& buf) const override {
        buf.write_i64(cashOrderQty);
    }
    

    void decode(ByteBuf& buf) override {
        cashOrderQty = buf.read_i64();
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const Extend101701*>(&other);
        if(!checkType) return false;
        return cashOrderQty == checkType->cashOrderQty;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "Extend101701 { "
        << "CashOrderQty: " << std::to_string(cashOrderQty)
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const Extend101701& pkt) {
    return os << pkt.toString();
}


struct Extend101801 : public codec::BinaryCodec {
    std::string tenderer;

    void encode(ByteBuf& buf) const override {
        codec::write_fixed_string(buf, tenderer, 6);
    }
    

    void decode(ByteBuf& buf) override {
        tenderer = codec::read_fixed_string(buf, 6);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const Extend101801*>(&other);
        if(!checkType) return false;
        return tenderer == checkType->tenderer;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "Extend101801 { "
        << "Tenderer: " << tenderer
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const Extend101801& pkt) {
    return os << pkt.toString();
}


struct Extend102701 : public codec::BinaryCodec {
    std::string disposalPbu;
    std::string disposalAccountId;

    void encode(ByteBuf& buf) const override {
        codec::write_fixed_string(buf, disposalPbu, 6);
        codec::write_fixed_string(buf, disposalAccountId, 12);
    }
    

    void decode(ByteBuf& buf) override {
        disposalPbu = codec::read_fixed_string(buf, 6);
        disposalAccountId = codec::read_fixed_string(buf, 12);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const Extend102701*>(&other);
        if(!checkType) return false;
        return disposalPbu == checkType->disposalPbu
               && disposalAccountId == checkType->disposalAccountId;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "Extend102701 { "
        << "DisposalPBU: " << disposalPbu
        << ", "
        << "DisposalAccountID: " << disposalAccountId
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const Extend102701& pkt) {
    return os << pkt.toString();
}


struct Extend102801 : public codec::BinaryCodec {
    std::string lenderPbu;
    std::string lenderAccountId;

    void encode(ByteBuf& buf) const override {
        codec::write_fixed_string(buf, lenderPbu, 6);
        codec::write_fixed_string(buf, lenderAccountId, 12);
    }
    

    void decode(ByteBuf& buf) override {
        lenderPbu = codec::read_fixed_string(buf, 6);
        lenderAccountId = codec::read_fixed_string(buf, 12);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const Extend102801*>(&other);
        if(!checkType) return false;
        return lenderPbu == checkType->lenderPbu
               && lenderAccountId == checkType->lenderAccountId;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "Extend102801 { "
        << "LenderPBU: " << lenderPbu
        << ", "
        << "LenderAccountID: " << lenderAccountId
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const Extend102801& pkt) {
    return os << pkt.toString();
}


struct Extend102901 : public codec::BinaryCodec {
    std::string deductionPbu;
    std::string deductionAccountId;

    void encode(ByteBuf& buf) const override {
        codec::write_fixed_string(buf, deductionPbu, 6);
        codec::write_fixed_string(buf, deductionAccountId, 12);
    }
    

    void decode(ByteBuf& buf) override {
        deductionPbu = codec::read_fixed_string(buf, 6);
        deductionAccountId = codec::read_fixed_string(buf, 12);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const Extend102901*>(&other);
        if(!checkType) return false;
        return deductionPbu == checkType->deductionPbu
               && deductionAccountId == checkType->deductionAccountId;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "Extend102901 { "
        << "DeductionPBU: " << deductionPbu
        << ", "
        << "DeductionAccountID: " << deductionAccountId
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const Extend102901& pkt) {
    return os << pkt.toString();
}


struct Extend106301 : public codec::BinaryCodec {
    int64_t stopPx;
    int64_t minQty;
    uint16_t maxPriceLevels;
    std::string timeInForce;
    std::string lotType;

    void encode(ByteBuf& buf) const override {
        buf.write_i64(stopPx);
        buf.write_i64(minQty);
        buf.write_u16(maxPriceLevels);
        codec::write_fixed_string(buf, timeInForce, 1);
        codec::write_fixed_string(buf, lotType, 1);
    }
    

    void decode(ByteBuf& buf) override {
        stopPx = buf.read_i64();
        minQty = buf.read_i64();
        maxPriceLevels = buf.read_u16();
        timeInForce = codec::read_fixed_string(buf, 1);
        lotType = codec::read_fixed_string(buf, 1);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const Extend106301*>(&other);
        if(!checkType) return false;
        return stopPx == checkType->stopPx
               && minQty == checkType->minQty
               && maxPriceLevels == checkType->maxPriceLevels
               && timeInForce == checkType->timeInForce
               && lotType == checkType->lotType;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "Extend106301 { "
        << "StopPx: " << std::to_string(stopPx)
        << ", "
        << "MinQty: " << std::to_string(minQty)
        << ", "
        << "MaxPriceLevels: " << std::to_string(maxPriceLevels)
        << ", "
        << "TimeInForce: " << timeInForce
        << ", "
        << "LotType: " << lotType
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const Extend106301& pkt) {
    return os << pkt.toString();
}


struct Extend103501 : public codec::BinaryCodec {
    std::string contractAccountCode;

    void encode(ByteBuf& buf) const override {
        codec::write_fixed_string(buf, contractAccountCode, 6);
    }
    

    void decode(ByteBuf& buf) override {
        contractAccountCode = codec::read_fixed_string(buf, 6);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const Extend103501*>(&other);
        if(!checkType) return false;
        return contractAccountCode == checkType->contractAccountCode;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "Extend103501 { "
        << "ContractAccountCode: " << contractAccountCode
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const Extend103501& pkt) {
    return os << pkt.toString();
}


struct Extend103701 : public codec::BinaryCodec {
    std::string cashMargin;

    void encode(ByteBuf& buf) const override {
        codec::write_fixed_string(buf, cashMargin, 1);
    }
    

    void decode(ByteBuf& buf) override {
        cashMargin = codec::read_fixed_string(buf, 1);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const Extend103701*>(&other);
        if(!checkType) return false;
        return cashMargin == checkType->cashMargin;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "Extend103701 { "
        << "CashMargin: " << cashMargin
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const Extend103701& pkt) {
    return os << pkt.toString();
}


struct Extend104101 : public codec::BinaryCodec {
    int64_t stopPx;
    int64_t minQty;
    uint16_t maxPriceLevels;
    std::string timeInForce;
    std::string cashMargin;

    void encode(ByteBuf& buf) const override {
        buf.write_i64(stopPx);
        buf.write_i64(minQty);
        buf.write_u16(maxPriceLevels);
        codec::write_fixed_string(buf, timeInForce, 1);
        codec::write_fixed_string(buf, cashMargin, 1);
    }
    

    void decode(ByteBuf& buf) override {
        stopPx = buf.read_i64();
        minQty = buf.read_i64();
        maxPriceLevels = buf.read_u16();
        timeInForce = codec::read_fixed_string(buf, 1);
        cashMargin = codec::read_fixed_string(buf, 1);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const Extend104101*>(&other);
        if(!checkType) return false;
        return stopPx == checkType->stopPx
               && minQty == checkType->minQty
               && maxPriceLevels == checkType->maxPriceLevels
               && timeInForce == checkType->timeInForce
               && cashMargin == checkType->cashMargin;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "Extend104101 { "
        << "StopPx: " << std::to_string(stopPx)
        << ", "
        << "MinQty: " << std::to_string(minQty)
        << ", "
        << "MaxPriceLevels: " << std::to_string(maxPriceLevels)
        << ", "
        << "TimeInForce: " << timeInForce
        << ", "
        << "CashMargin: " << cashMargin
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const Extend104101& pkt) {
    return os << pkt.toString();
}


struct Extend104128 : public codec::BinaryCodec {
    std::string memberId;
    std::string investorType;
    std::string investorId;
    std::string investorName;
    std::string traderCode;
    std::string secondaryOrderId;
    uint16_t bidTransType;
    uint16_t bidExecInstType;
    int64_t lowLimitPrice;
    int64_t highLimitPrice;
    int64_t minQty;
    uint32_t tradeDate;
    uint16_t settlType;
    uint8_t settlPeriod;
    uint8_t preTradeAnonymity;
    std::string cashMargin;
    std::string memo;

    void encode(ByteBuf& buf) const override {
        codec::write_fixed_string(buf, memberId, 6);
        codec::write_fixed_string(buf, investorType, 2);
        codec::write_fixed_string(buf, investorId, 10);
        codec::write_fixed_string(buf, investorName, 120);
        codec::write_fixed_string(buf, traderCode, 8);
        codec::write_fixed_string(buf, secondaryOrderId, 16);
        buf.write_u16(bidTransType);
        buf.write_u16(bidExecInstType);
        buf.write_i64(lowLimitPrice);
        buf.write_i64(highLimitPrice);
        buf.write_i64(minQty);
        buf.write_u32(tradeDate);
        buf.write_u16(settlType);
        buf.write_u8(settlPeriod);
        buf.write_u8(preTradeAnonymity);
        codec::write_fixed_string(buf, cashMargin, 1);
        codec::write_fixed_string(buf, memo, 160);
    }
    

    void decode(ByteBuf& buf) override {
        memberId = codec::read_fixed_string(buf, 6);
        investorType = codec::read_fixed_string(buf, 2);
        investorId = codec::read_fixed_string(buf, 10);
        investorName = codec::read_fixed_string(buf, 120);
        traderCode = codec::read_fixed_string(buf, 8);
        secondaryOrderId = codec::read_fixed_string(buf, 16);
        bidTransType = buf.read_u16();
        bidExecInstType = buf.read_u16();
        lowLimitPrice = buf.read_i64();
        highLimitPrice = buf.read_i64();
        minQty = buf.read_i64();
        tradeDate = buf.read_u32();
        settlType = buf.read_u16();
        settlPeriod = buf.read_u8();
        preTradeAnonymity = buf.read_u8();
        cashMargin = codec::read_fixed_string(buf, 1);
        memo = codec::read_fixed_string(buf, 160);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const Extend104128*>(&other);
        if(!checkType) return false;
        return memberId == checkType->memberId
               && investorType == checkType->investorType
               && investorId == checkType->investorId
               && investorName == checkType->investorName
               && traderCode == checkType->traderCode
               && secondaryOrderId == checkType->secondaryOrderId
               && bidTransType == checkType->bidTransType
               && bidExecInstType == checkType->bidExecInstType
               && lowLimitPrice == checkType->lowLimitPrice
               && highLimitPrice == checkType->highLimitPrice
               && minQty == checkType->minQty
               && tradeDate == checkType->tradeDate
               && settlType == checkType->settlType
               && settlPeriod == checkType->settlPeriod
               && preTradeAnonymity == checkType->preTradeAnonymity
               && cashMargin == checkType->cashMargin
               && memo == checkType->memo;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "Extend104128 { "
        << "MemberID: " << memberId
        << ", "
        << "InvestorType: " << investorType
        << ", "
        << "InvestorID: " << investorId
        << ", "
        << "InvestorName: " << investorName
        << ", "
        << "TraderCode: " << traderCode
        << ", "
        << "SecondaryOrderID: " << secondaryOrderId
        << ", "
        << "BidTransType: " << std::to_string(bidTransType)
        << ", "
        << "BidExecInstType: " << std::to_string(bidExecInstType)
        << ", "
        << "LowLimitPrice: " << std::to_string(lowLimitPrice)
        << ", "
        << "HighLimitPrice: " << std::to_string(highLimitPrice)
        << ", "
        << "MinQty: " << std::to_string(minQty)
        << ", "
        << "TradeDate: " << std::to_string(tradeDate)
        << ", "
        << "SettlType: " << std::to_string(settlType)
        << ", "
        << "SettlPeriod: " << static_cast<unsigned>(settlPeriod)
        << ", "
        << "PreTradeAnonymity: " << static_cast<unsigned>(preTradeAnonymity)
        << ", "
        << "CashMargin: " << cashMargin
        << ", "
        << "Memo: " << memo
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const Extend104128& pkt) {
    return os << pkt.toString();
}


struct Extend104701 : public codec::BinaryCodec {
    std::string secondaryOrderId;

    void encode(ByteBuf& buf) const override {
        codec::write_fixed_string(buf, secondaryOrderId, 16);
    }
    

    void decode(ByteBuf& buf) override {
        secondaryOrderId = codec::read_fixed_string(buf, 16);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const Extend104701*>(&other);
        if(!checkType) return false;
        return secondaryOrderId == checkType->secondaryOrderId;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "Extend104701 { "
        << "SecondaryOrderID: " << secondaryOrderId
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const Extend104701& pkt) {
    return os << pkt.toString();
}


struct NewOrderTag{};
using NewOrderMessageFactory = MessageFactory<std::string, codec::BinaryCodec, NewOrderTag>;
REGISTER_MESSAGE(NewOrderMessageFactory, "010", Extend100101);
REGISTER_MESSAGE(NewOrderMessageFactory, "020", Extend100201);
REGISTER_MESSAGE(NewOrderMessageFactory, "030", Extend100301);
REGISTER_MESSAGE(NewOrderMessageFactory, "051", Extend100501);
REGISTER_MESSAGE(NewOrderMessageFactory, "052", Extend100501);
REGISTER_MESSAGE(NewOrderMessageFactory, "060", Extend100601);
REGISTER_MESSAGE(NewOrderMessageFactory, "061", Extend100601);
REGISTER_MESSAGE(NewOrderMessageFactory, "070", Extend100701);
REGISTER_MESSAGE(NewOrderMessageFactory, "150", Extend101501);
REGISTER_MESSAGE(NewOrderMessageFactory, "151", Extend101501);
REGISTER_MESSAGE(NewOrderMessageFactory, "152", Extend101501);
REGISTER_MESSAGE(NewOrderMessageFactory, "160", Extend101601);
REGISTER_MESSAGE(NewOrderMessageFactory, "170", Extend101701);
REGISTER_MESSAGE(NewOrderMessageFactory, "180", Extend101801);
REGISTER_MESSAGE(NewOrderMessageFactory, "181", Extend101801);
REGISTER_MESSAGE(NewOrderMessageFactory, "270", Extend102701);
REGISTER_MESSAGE(NewOrderMessageFactory, "271", Extend102701);
REGISTER_MESSAGE(NewOrderMessageFactory, "280", Extend102801);
REGISTER_MESSAGE(NewOrderMessageFactory, "281", Extend102801);
REGISTER_MESSAGE(NewOrderMessageFactory, "290", Extend102901);
REGISTER_MESSAGE(NewOrderMessageFactory, "291", Extend102901);
REGISTER_MESSAGE(NewOrderMessageFactory, "630", Extend106301);
REGISTER_MESSAGE(NewOrderMessageFactory, "350", Extend103501);
REGISTER_MESSAGE(NewOrderMessageFactory, "351", Extend103501);
REGISTER_MESSAGE(NewOrderMessageFactory, "370", Extend103701);
REGISTER_MESSAGE(NewOrderMessageFactory, "410", Extend104101);
REGISTER_MESSAGE(NewOrderMessageFactory, "417", Extend104128);
REGISTER_MESSAGE(NewOrderMessageFactory, "470", Extend104701);


struct NewOrder : public codec::BinaryCodec {
    std::string applId;
    std::string submittingPbuid;
    std::string securityId;
    std::string securityIdsource;
    uint16_t ownerType;
    std::string clearingFirm;
    int64_t transactTime;
    std::string userInfo;
    std::string clOrdId;
    std::string accountId;
    std::string branchId;
    std::string orderRestrictions;
    std::string side;
    std::string ordType;
    int64_t orderQty;
    int64_t price;
    std::unique_ptr<codec::BinaryCodec> applExtend;

    void encode(ByteBuf& buf) const override {
        codec::write_fixed_string(buf, applId, 3);
        codec::write_fixed_string(buf, submittingPbuid, 6);
        codec::write_fixed_string(buf, securityId, 8);
        codec::write_fixed_string(buf, securityIdsource, 4);
        buf.write_u16(ownerType);
        codec::write_fixed_string(buf, clearingFirm, 2);
        buf.write_i64(transactTime);
        codec::write_fixed_string(buf, userInfo, 8);
        codec::write_fixed_string(buf, clOrdId, 10);
        codec::write_fixed_string(buf, accountId, 12);
        codec::write_fixed_string(buf, branchId, 4);
        codec::write_fixed_string(buf, orderRestrictions, 4);
        codec::write_fixed_string(buf, side, 1);
        codec::write_fixed_string(buf, ordType, 1);
        buf.write_i64(orderQty);
        buf.write_i64(price);
        applExtend->encode(buf);
    }
    

    void decode(ByteBuf& buf) override {
        applId = codec::read_fixed_string(buf, 3);
        submittingPbuid = codec::read_fixed_string(buf, 6);
        securityId = codec::read_fixed_string(buf, 8);
        securityIdsource = codec::read_fixed_string(buf, 4);
        ownerType = buf.read_u16();
        clearingFirm = codec::read_fixed_string(buf, 2);
        transactTime = buf.read_i64();
        userInfo = codec::read_fixed_string(buf, 8);
        clOrdId = codec::read_fixed_string(buf, 10);
        accountId = codec::read_fixed_string(buf, 12);
        branchId = codec::read_fixed_string(buf, 4);
        orderRestrictions = codec::read_fixed_string(buf, 4);
        side = codec::read_fixed_string(buf, 1);
        ordType = codec::read_fixed_string(buf, 1);
        orderQty = buf.read_i64();
        price = buf.read_i64();
        applExtend = NewOrderMessageFactory::getInstance().create(applId);
        applExtend->decode(buf);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const NewOrder*>(&other);
        if(!checkType) return false;
        return applId == checkType->applId
               && submittingPbuid == checkType->submittingPbuid
               && securityId == checkType->securityId
               && securityIdsource == checkType->securityIdsource
               && ownerType == checkType->ownerType
               && clearingFirm == checkType->clearingFirm
               && transactTime == checkType->transactTime
               && userInfo == checkType->userInfo
               && clOrdId == checkType->clOrdId
               && accountId == checkType->accountId
               && branchId == checkType->branchId
               && orderRestrictions == checkType->orderRestrictions
               && side == checkType->side
               && ordType == checkType->ordType
               && orderQty == checkType->orderQty
               && price == checkType->price
               && applExtend->equals(*checkType->applExtend);
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "NewOrder { "
        << "ApplID: " << applId
        << ", "
        << "SubmittingPBUID: " << submittingPbuid
        << ", "
        << "SecurityID: " << securityId
        << ", "
        << "SecurityIDSource: " << securityIdsource
        << ", "
        << "OwnerType: " << std::to_string(ownerType)
        << ", "
        << "ClearingFirm: " << clearingFirm
        << ", "
        << "TransactTime: " << std::to_string(transactTime)
        << ", "
        << "UserInfo: " << userInfo
        << ", "
        << "ClOrdID: " << clOrdId
        << ", "
        << "AccountID: " << accountId
        << ", "
        << "BranchID: " << branchId
        << ", "
        << "OrderRestrictions: " << orderRestrictions
        << ", "
        << "Side: " << side
        << ", "
        << "OrdType: " << ordType
        << ", "
        << "OrderQty: " << std::to_string(orderQty)
        << ", "
        << "Price: " << std::to_string(price)
        << ", "
        << "ApplExtend: " << applExtend->toString()
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const NewOrder& pkt) {
    return os << pkt.toString();
}





struct Extend101401 : public codec::BinaryCodec {
    int64_t stopPx;
    int64_t minQty;
    uint16_t maxPriceLevels;
    std::string timeInForce;
    std::string positionEffect;
    uint8_t coveredOrUncovered;
    std::string contractAccountCode;
    std::string secondaryOrderId;

    void encode(ByteBuf& buf) const override {
        buf.write_i64(stopPx);
        buf.write_i64(minQty);
        buf.write_u16(maxPriceLevels);
        codec::write_fixed_string(buf, timeInForce, 1);
        codec::write_fixed_string(buf, positionEffect, 1);
        buf.write_u8(coveredOrUncovered);
        codec::write_fixed_string(buf, contractAccountCode, 6);
        codec::write_fixed_string(buf, secondaryOrderId, 16);
    }
    

    void decode(ByteBuf& buf) override {
        stopPx = buf.read_i64();
        minQty = buf.read_i64();
        maxPriceLevels = buf.read_u16();
        timeInForce = codec::read_fixed_string(buf, 1);
        positionEffect = codec::read_fixed_string(buf, 1);
        coveredOrUncovered = buf.read_u8();
        contractAccountCode = codec::read_fixed_string(buf, 6);
        secondaryOrderId = codec::read_fixed_string(buf, 16);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const Extend101401*>(&other);
        if(!checkType) return false;
        return stopPx == checkType->stopPx
               && minQty == checkType->minQty
               && maxPriceLevels == checkType->maxPriceLevels
               && timeInForce == checkType->timeInForce
               && positionEffect == checkType->positionEffect
               && coveredOrUncovered == checkType->coveredOrUncovered
               && contractAccountCode == checkType->contractAccountCode
               && secondaryOrderId == checkType->secondaryOrderId;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "Extend101401 { "
        << "StopPx: " << std::to_string(stopPx)
        << ", "
        << "MinQty: " << std::to_string(minQty)
        << ", "
        << "MaxPriceLevels: " << std::to_string(maxPriceLevels)
        << ", "
        << "TimeInForce: " << timeInForce
        << ", "
        << "PositionEffect: " << positionEffect
        << ", "
        << "CoveredOrUncovered: " << static_cast<unsigned>(coveredOrUncovered)
        << ", "
        << "ContractAccountCode: " << contractAccountCode
        << ", "
        << "SecondaryOrderID: " << secondaryOrderId
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const Extend101401& pkt) {
    return os << pkt.toString();
}


















struct Extend200102 : public codec::BinaryCodec {
    int64_t stopPx;
    int64_t minQty;
    uint16_t maxPriceLevels;
    std::string timeInForce;
    std::string cashMargin;

    void encode(ByteBuf& buf) const override {
        buf.write_i64(stopPx);
        buf.write_i64(minQty);
        buf.write_u16(maxPriceLevels);
        codec::write_fixed_string(buf, timeInForce, 1);
        codec::write_fixed_string(buf, cashMargin, 1);
    }
    

    void decode(ByteBuf& buf) override {
        stopPx = buf.read_i64();
        minQty = buf.read_i64();
        maxPriceLevels = buf.read_u16();
        timeInForce = codec::read_fixed_string(buf, 1);
        cashMargin = codec::read_fixed_string(buf, 1);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const Extend200102*>(&other);
        if(!checkType) return false;
        return stopPx == checkType->stopPx
               && minQty == checkType->minQty
               && maxPriceLevels == checkType->maxPriceLevels
               && timeInForce == checkType->timeInForce
               && cashMargin == checkType->cashMargin;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "Extend200102 { "
        << "StopPx: " << std::to_string(stopPx)
        << ", "
        << "MinQty: " << std::to_string(minQty)
        << ", "
        << "MaxPriceLevels: " << std::to_string(maxPriceLevels)
        << ", "
        << "TimeInForce: " << timeInForce
        << ", "
        << "CashMargin: " << cashMargin
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const Extend200102& pkt) {
    return os << pkt.toString();
}


struct Extend200202 : public codec::BinaryCodec {
    int64_t stopPx;
    int64_t minQty;
    uint16_t maxPriceLevels;
    std::string timeInForce;

    void encode(ByteBuf& buf) const override {
        buf.write_i64(stopPx);
        buf.write_i64(minQty);
        buf.write_u16(maxPriceLevels);
        codec::write_fixed_string(buf, timeInForce, 1);
    }
    

    void decode(ByteBuf& buf) override {
        stopPx = buf.read_i64();
        minQty = buf.read_i64();
        maxPriceLevels = buf.read_u16();
        timeInForce = codec::read_fixed_string(buf, 1);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const Extend200202*>(&other);
        if(!checkType) return false;
        return stopPx == checkType->stopPx
               && minQty == checkType->minQty
               && maxPriceLevels == checkType->maxPriceLevels
               && timeInForce == checkType->timeInForce;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "Extend200202 { "
        << "StopPx: " << std::to_string(stopPx)
        << ", "
        << "MinQty: " << std::to_string(minQty)
        << ", "
        << "MaxPriceLevels: " << std::to_string(maxPriceLevels)
        << ", "
        << "TimeInForce: " << timeInForce
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const Extend200202& pkt) {
    return os << pkt.toString();
}


struct Extend200302 : public codec::BinaryCodec {
    int64_t stopPx;
    int64_t minQty;
    uint16_t maxPriceLevels;
    std::string timeInForce;

    void encode(ByteBuf& buf) const override {
        buf.write_i64(stopPx);
        buf.write_i64(minQty);
        buf.write_u16(maxPriceLevels);
        codec::write_fixed_string(buf, timeInForce, 1);
    }
    

    void decode(ByteBuf& buf) override {
        stopPx = buf.read_i64();
        minQty = buf.read_i64();
        maxPriceLevels = buf.read_u16();
        timeInForce = codec::read_fixed_string(buf, 1);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const Extend200302*>(&other);
        if(!checkType) return false;
        return stopPx == checkType->stopPx
               && minQty == checkType->minQty
               && maxPriceLevels == checkType->maxPriceLevels
               && timeInForce == checkType->timeInForce;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "Extend200302 { "
        << "StopPx: " << std::to_string(stopPx)
        << ", "
        << "MinQty: " << std::to_string(minQty)
        << ", "
        << "MaxPriceLevels: " << std::to_string(maxPriceLevels)
        << ", "
        << "TimeInForce: " << timeInForce
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const Extend200302& pkt) {
    return os << pkt.toString();
}


struct Extend200502 : public codec::BinaryCodec {
    std::string confirmId;
    std::string cashMargin;

    void encode(ByteBuf& buf) const override {
        codec::write_fixed_string(buf, confirmId, 8);
        codec::write_fixed_string(buf, cashMargin, 1);
    }
    

    void decode(ByteBuf& buf) override {
        confirmId = codec::read_fixed_string(buf, 8);
        cashMargin = codec::read_fixed_string(buf, 1);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const Extend200502*>(&other);
        if(!checkType) return false;
        return confirmId == checkType->confirmId
               && cashMargin == checkType->cashMargin;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "Extend200502 { "
        << "ConfirmID: " << confirmId
        << ", "
        << "CashMargin: " << cashMargin
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const Extend200502& pkt) {
    return os << pkt.toString();
}


struct Extend200602 : public codec::BinaryCodec {
    std::string cashMargin;

    void encode(ByteBuf& buf) const override {
        codec::write_fixed_string(buf, cashMargin, 1);
    }
    

    void decode(ByteBuf& buf) override {
        cashMargin = codec::read_fixed_string(buf, 1);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const Extend200602*>(&other);
        if(!checkType) return false;
        return cashMargin == checkType->cashMargin;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "Extend200602 { "
        << "CashMargin: " << cashMargin
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const Extend200602& pkt) {
    return os << pkt.toString();
}


struct Extend200702 : public codec::BinaryCodec {
    uint16_t expirationDays;
    uint8_t expirationType;
    std::string shareProperty;

    void encode(ByteBuf& buf) const override {
        buf.write_u16(expirationDays);
        buf.write_u8(expirationType);
        codec::write_fixed_string(buf, shareProperty, 2);
    }
    

    void decode(ByteBuf& buf) override {
        expirationDays = buf.read_u16();
        expirationType = buf.read_u8();
        shareProperty = codec::read_fixed_string(buf, 2);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const Extend200702*>(&other);
        if(!checkType) return false;
        return expirationDays == checkType->expirationDays
               && expirationType == checkType->expirationType
               && shareProperty == checkType->shareProperty;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "Extend200702 { "
        << "ExpirationDays: " << std::to_string(expirationDays)
        << ", "
        << "ExpirationType: " << static_cast<unsigned>(expirationType)
        << ", "
        << "ShareProperty: " << shareProperty
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const Extend200702& pkt) {
    return os << pkt.toString();
}


struct Extend201502 : public codec::BinaryCodec {
    std::string shareProperty;

    void encode(ByteBuf& buf) const override {
        codec::write_fixed_string(buf, shareProperty, 2);
    }
    

    void decode(ByteBuf& buf) override {
        shareProperty = codec::read_fixed_string(buf, 2);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const Extend201502*>(&other);
        if(!checkType) return false;
        return shareProperty == checkType->shareProperty;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "Extend201502 { "
        << "ShareProperty: " << shareProperty
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const Extend201502& pkt) {
    return os << pkt.toString();
}


struct Extend201602 : public codec::BinaryCodec {
    std::string contractAccountCode;

    void encode(ByteBuf& buf) const override {
        codec::write_fixed_string(buf, contractAccountCode, 6);
    }
    

    void decode(ByteBuf& buf) override {
        contractAccountCode = codec::read_fixed_string(buf, 6);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const Extend201602*>(&other);
        if(!checkType) return false;
        return contractAccountCode == checkType->contractAccountCode;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "Extend201602 { "
        << "ContractAccountCode: " << contractAccountCode
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const Extend201602& pkt) {
    return os << pkt.toString();
}


struct Extend201702 : public codec::BinaryCodec {
    int64_t cashOrderQty;

    void encode(ByteBuf& buf) const override {
        buf.write_i64(cashOrderQty);
    }
    

    void decode(ByteBuf& buf) override {
        cashOrderQty = buf.read_i64();
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const Extend201702*>(&other);
        if(!checkType) return false;
        return cashOrderQty == checkType->cashOrderQty;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "Extend201702 { "
        << "CashOrderQty: " << std::to_string(cashOrderQty)
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const Extend201702& pkt) {
    return os << pkt.toString();
}


struct Extend201802 : public codec::BinaryCodec {
    std::string tenderer;

    void encode(ByteBuf& buf) const override {
        codec::write_fixed_string(buf, tenderer, 6);
    }
    

    void decode(ByteBuf& buf) override {
        tenderer = codec::read_fixed_string(buf, 6);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const Extend201802*>(&other);
        if(!checkType) return false;
        return tenderer == checkType->tenderer;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "Extend201802 { "
        << "Tenderer: " << tenderer
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const Extend201802& pkt) {
    return os << pkt.toString();
}


struct Extend202702 : public codec::BinaryCodec {
    std::string disposalPbu;
    std::string disposalAccountId;

    void encode(ByteBuf& buf) const override {
        codec::write_fixed_string(buf, disposalPbu, 6);
        codec::write_fixed_string(buf, disposalAccountId, 12);
    }
    

    void decode(ByteBuf& buf) override {
        disposalPbu = codec::read_fixed_string(buf, 6);
        disposalAccountId = codec::read_fixed_string(buf, 12);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const Extend202702*>(&other);
        if(!checkType) return false;
        return disposalPbu == checkType->disposalPbu
               && disposalAccountId == checkType->disposalAccountId;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "Extend202702 { "
        << "DisposalPBU: " << disposalPbu
        << ", "
        << "DisposalAccountID: " << disposalAccountId
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const Extend202702& pkt) {
    return os << pkt.toString();
}


struct Extend202802 : public codec::BinaryCodec {
    std::string lenderPbu;
    std::string lenderAccountId;

    void encode(ByteBuf& buf) const override {
        codec::write_fixed_string(buf, lenderPbu, 6);
        codec::write_fixed_string(buf, lenderAccountId, 12);
    }
    

    void decode(ByteBuf& buf) override {
        lenderPbu = codec::read_fixed_string(buf, 6);
        lenderAccountId = codec::read_fixed_string(buf, 12);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const Extend202802*>(&other);
        if(!checkType) return false;
        return lenderPbu == checkType->lenderPbu
               && lenderAccountId == checkType->lenderAccountId;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "Extend202802 { "
        << "LenderPBU: " << lenderPbu
        << ", "
        << "LenderAccountID: " << lenderAccountId
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const Extend202802& pkt) {
    return os << pkt.toString();
}


struct Extend202902 : public codec::BinaryCodec {
    std::string deductionPbu;
    std::string deductionAccountId;

    void encode(ByteBuf& buf) const override {
        codec::write_fixed_string(buf, deductionPbu, 6);
        codec::write_fixed_string(buf, deductionAccountId, 12);
    }
    

    void decode(ByteBuf& buf) override {
        deductionPbu = codec::read_fixed_string(buf, 6);
        deductionAccountId = codec::read_fixed_string(buf, 12);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const Extend202902*>(&other);
        if(!checkType) return false;
        return deductionPbu == checkType->deductionPbu
               && deductionAccountId == checkType->deductionAccountId;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "Extend202902 { "
        << "DeductionPBU: " << deductionPbu
        << ", "
        << "DeductionAccountID: " << deductionAccountId
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const Extend202902& pkt) {
    return os << pkt.toString();
}


struct Extend206302 : public codec::BinaryCodec {
    std::string rejectText;
    int64_t stopPx;
    int64_t minQty;
    uint16_t maxPriceLevels;
    std::string timeInForce;
    std::string lotType;
    uint32_t imcrejectTextLen;
    std::string imcrejectText;

    void encode(ByteBuf& buf) const override {
        codec::write_fixed_string(buf, rejectText, 16);
        buf.write_i64(stopPx);
        buf.write_i64(minQty);
        buf.write_u16(maxPriceLevels);
        codec::write_fixed_string(buf, timeInForce, 1);
        codec::write_fixed_string(buf, lotType, 1);
        buf.write_u32(imcrejectTextLen);
        codec::write_string<uint32_t>(buf, imcrejectText);
    }
    

    void decode(ByteBuf& buf) override {
        rejectText = codec::read_fixed_string(buf, 16);
        stopPx = buf.read_i64();
        minQty = buf.read_i64();
        maxPriceLevels = buf.read_u16();
        timeInForce = codec::read_fixed_string(buf, 1);
        lotType = codec::read_fixed_string(buf, 1);
        imcrejectTextLen = buf.read_u32();
        imcrejectText = codec::read_string<uint32_t>(buf);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const Extend206302*>(&other);
        if(!checkType) return false;
        return rejectText == checkType->rejectText
               && stopPx == checkType->stopPx
               && minQty == checkType->minQty
               && maxPriceLevels == checkType->maxPriceLevels
               && timeInForce == checkType->timeInForce
               && lotType == checkType->lotType
               && imcrejectTextLen == checkType->imcrejectTextLen
               && imcrejectText == checkType->imcrejectText;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "Extend206302 { "
        << "RejectText: " << rejectText
        << ", "
        << "StopPx: " << std::to_string(stopPx)
        << ", "
        << "MinQty: " << std::to_string(minQty)
        << ", "
        << "MaxPriceLevels: " << std::to_string(maxPriceLevels)
        << ", "
        << "TimeInForce: " << timeInForce
        << ", "
        << "LotType: " << lotType
        << ", "
        << "IMCRejectTextLen: " << std::to_string(imcrejectTextLen)
        << ", "
        << "IMCRejectText: " << imcrejectText
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const Extend206302& pkt) {
    return os << pkt.toString();
}


struct Extend203502 : public codec::BinaryCodec {
    std::string contractAccountCode;

    void encode(ByteBuf& buf) const override {
        codec::write_fixed_string(buf, contractAccountCode, 6);
    }
    

    void decode(ByteBuf& buf) override {
        contractAccountCode = codec::read_fixed_string(buf, 6);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const Extend203502*>(&other);
        if(!checkType) return false;
        return contractAccountCode == checkType->contractAccountCode;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "Extend203502 { "
        << "ContractAccountCode: " << contractAccountCode
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const Extend203502& pkt) {
    return os << pkt.toString();
}


struct Extend203702 : public codec::BinaryCodec {
    std::string cashMargin;

    void encode(ByteBuf& buf) const override {
        codec::write_fixed_string(buf, cashMargin, 1);
    }
    

    void decode(ByteBuf& buf) override {
        cashMargin = codec::read_fixed_string(buf, 1);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const Extend203702*>(&other);
        if(!checkType) return false;
        return cashMargin == checkType->cashMargin;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "Extend203702 { "
        << "CashMargin: " << cashMargin
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const Extend203702& pkt) {
    return os << pkt.toString();
}


struct Extend204102 : public codec::BinaryCodec {
    int64_t stopPx;
    int64_t minQty;
    uint16_t maxPriceLevels;
    std::string timeInForce;
    std::string cashMargin;

    void encode(ByteBuf& buf) const override {
        buf.write_i64(stopPx);
        buf.write_i64(minQty);
        buf.write_u16(maxPriceLevels);
        codec::write_fixed_string(buf, timeInForce, 1);
        codec::write_fixed_string(buf, cashMargin, 1);
    }
    

    void decode(ByteBuf& buf) override {
        stopPx = buf.read_i64();
        minQty = buf.read_i64();
        maxPriceLevels = buf.read_u16();
        timeInForce = codec::read_fixed_string(buf, 1);
        cashMargin = codec::read_fixed_string(buf, 1);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const Extend204102*>(&other);
        if(!checkType) return false;
        return stopPx == checkType->stopPx
               && minQty == checkType->minQty
               && maxPriceLevels == checkType->maxPriceLevels
               && timeInForce == checkType->timeInForce
               && cashMargin == checkType->cashMargin;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "Extend204102 { "
        << "StopPx: " << std::to_string(stopPx)
        << ", "
        << "MinQty: " << std::to_string(minQty)
        << ", "
        << "MaxPriceLevels: " << std::to_string(maxPriceLevels)
        << ", "
        << "TimeInForce: " << timeInForce
        << ", "
        << "CashMargin: " << cashMargin
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const Extend204102& pkt) {
    return os << pkt.toString();
}


struct Extend204129 : public codec::BinaryCodec {
    std::string memberId;
    std::string investorType;
    std::string investorId;
    std::string investorName;
    std::string traderCode;
    std::string secondaryOrderId;
    uint16_t bidTransType;
    uint16_t bidExecInstType;
    int64_t lowLimitPrice;
    int64_t highLimitPrice;
    int64_t minQty;
    uint32_t tradeDate;
    uint16_t settlType;
    uint8_t settlPeriod;
    uint8_t preTradeAnonymity;
    std::string cashMargin;
    std::string memo;

    void encode(ByteBuf& buf) const override {
        codec::write_fixed_string(buf, memberId, 6);
        codec::write_fixed_string(buf, investorType, 2);
        codec::write_fixed_string(buf, investorId, 10);
        codec::write_fixed_string(buf, investorName, 120);
        codec::write_fixed_string(buf, traderCode, 8);
        codec::write_fixed_string(buf, secondaryOrderId, 16);
        buf.write_u16(bidTransType);
        buf.write_u16(bidExecInstType);
        buf.write_i64(lowLimitPrice);
        buf.write_i64(highLimitPrice);
        buf.write_i64(minQty);
        buf.write_u32(tradeDate);
        buf.write_u16(settlType);
        buf.write_u8(settlPeriod);
        buf.write_u8(preTradeAnonymity);
        codec::write_fixed_string(buf, cashMargin, 1);
        codec::write_fixed_string(buf, memo, 160);
    }
    

    void decode(ByteBuf& buf) override {
        memberId = codec::read_fixed_string(buf, 6);
        investorType = codec::read_fixed_string(buf, 2);
        investorId = codec::read_fixed_string(buf, 10);
        investorName = codec::read_fixed_string(buf, 120);
        traderCode = codec::read_fixed_string(buf, 8);
        secondaryOrderId = codec::read_fixed_string(buf, 16);
        bidTransType = buf.read_u16();
        bidExecInstType = buf.read_u16();
        lowLimitPrice = buf.read_i64();
        highLimitPrice = buf.read_i64();
        minQty = buf.read_i64();
        tradeDate = buf.read_u32();
        settlType = buf.read_u16();
        settlPeriod = buf.read_u8();
        preTradeAnonymity = buf.read_u8();
        cashMargin = codec::read_fixed_string(buf, 1);
        memo = codec::read_fixed_string(buf, 160);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const Extend204129*>(&other);
        if(!checkType) return false;
        return memberId == checkType->memberId
               && investorType == checkType->investorType
               && investorId == checkType->investorId
               && investorName == checkType->investorName
               && traderCode == checkType->traderCode
               && secondaryOrderId == checkType->secondaryOrderId
               && bidTransType == checkType->bidTransType
               && bidExecInstType == checkType->bidExecInstType
               && lowLimitPrice == checkType->lowLimitPrice
               && highLimitPrice == checkType->highLimitPrice
               && minQty == checkType->minQty
               && tradeDate == checkType->tradeDate
               && settlType == checkType->settlType
               && settlPeriod == checkType->settlPeriod
               && preTradeAnonymity == checkType->preTradeAnonymity
               && cashMargin == checkType->cashMargin
               && memo == checkType->memo;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "Extend204129 { "
        << "MemberID: " << memberId
        << ", "
        << "InvestorType: " << investorType
        << ", "
        << "InvestorID: " << investorId
        << ", "
        << "InvestorName: " << investorName
        << ", "
        << "TraderCode: " << traderCode
        << ", "
        << "SecondaryOrderID: " << secondaryOrderId
        << ", "
        << "BidTransType: " << std::to_string(bidTransType)
        << ", "
        << "BidExecInstType: " << std::to_string(bidExecInstType)
        << ", "
        << "LowLimitPrice: " << std::to_string(lowLimitPrice)
        << ", "
        << "HighLimitPrice: " << std::to_string(highLimitPrice)
        << ", "
        << "MinQty: " << std::to_string(minQty)
        << ", "
        << "TradeDate: " << std::to_string(tradeDate)
        << ", "
        << "SettlType: " << std::to_string(settlType)
        << ", "
        << "SettlPeriod: " << static_cast<unsigned>(settlPeriod)
        << ", "
        << "PreTradeAnonymity: " << static_cast<unsigned>(preTradeAnonymity)
        << ", "
        << "CashMargin: " << cashMargin
        << ", "
        << "Memo: " << memo
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const Extend204129& pkt) {
    return os << pkt.toString();
}


struct Extend204702 : public codec::BinaryCodec {
    std::string secondaryOrderId;

    void encode(ByteBuf& buf) const override {
        codec::write_fixed_string(buf, secondaryOrderId, 16);
    }
    

    void decode(ByteBuf& buf) override {
        secondaryOrderId = codec::read_fixed_string(buf, 16);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const Extend204702*>(&other);
        if(!checkType) return false;
        return secondaryOrderId == checkType->secondaryOrderId;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "Extend204702 { "
        << "SecondaryOrderID: " << secondaryOrderId
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const Extend204702& pkt) {
    return os << pkt.toString();
}


struct ExecutionConfirmTag{};
using ExecutionConfirmMessageFactory = MessageFactory<std::string, codec::BinaryCodec, ExecutionConfirmTag>;
REGISTER_MESSAGE(ExecutionConfirmMessageFactory, "010", Extend200102);
REGISTER_MESSAGE(ExecutionConfirmMessageFactory, "020", Extend200202);
REGISTER_MESSAGE(ExecutionConfirmMessageFactory, "030", Extend200302);
REGISTER_MESSAGE(ExecutionConfirmMessageFactory, "051", Extend200502);
REGISTER_MESSAGE(ExecutionConfirmMessageFactory, "052", Extend200502);
REGISTER_MESSAGE(ExecutionConfirmMessageFactory, "060", Extend200602);
REGISTER_MESSAGE(ExecutionConfirmMessageFactory, "061", Extend200602);
REGISTER_MESSAGE(ExecutionConfirmMessageFactory, "070", Extend200702);
REGISTER_MESSAGE(ExecutionConfirmMessageFactory, "150", Extend201502);
REGISTER_MESSAGE(ExecutionConfirmMessageFactory, "151", Extend201502);
REGISTER_MESSAGE(ExecutionConfirmMessageFactory, "152", Extend201502);
REGISTER_MESSAGE(ExecutionConfirmMessageFactory, "160", Extend201602);
REGISTER_MESSAGE(ExecutionConfirmMessageFactory, "170", Extend201702);
REGISTER_MESSAGE(ExecutionConfirmMessageFactory, "180", Extend201802);
REGISTER_MESSAGE(ExecutionConfirmMessageFactory, "181", Extend201802);
REGISTER_MESSAGE(ExecutionConfirmMessageFactory, "270", Extend202702);
REGISTER_MESSAGE(ExecutionConfirmMessageFactory, "271", Extend202702);
REGISTER_MESSAGE(ExecutionConfirmMessageFactory, "280", Extend202802);
REGISTER_MESSAGE(ExecutionConfirmMessageFactory, "281", Extend202802);
REGISTER_MESSAGE(ExecutionConfirmMessageFactory, "290", Extend202902);
REGISTER_MESSAGE(ExecutionConfirmMessageFactory, "291", Extend202902);
REGISTER_MESSAGE(ExecutionConfirmMessageFactory, "630", Extend206302);
REGISTER_MESSAGE(ExecutionConfirmMessageFactory, "350", Extend203502);
REGISTER_MESSAGE(ExecutionConfirmMessageFactory, "351", Extend203502);
REGISTER_MESSAGE(ExecutionConfirmMessageFactory, "370", Extend203702);
REGISTER_MESSAGE(ExecutionConfirmMessageFactory, "410", Extend204102);
REGISTER_MESSAGE(ExecutionConfirmMessageFactory, "417", Extend204129);
REGISTER_MESSAGE(ExecutionConfirmMessageFactory, "470", Extend204702);


struct ExecutionConfirm : public codec::BinaryCodec {
    int32_t partitionNo;
    int64_t reportIndex;
    std::string applId;
    std::string reportingPbuid;
    std::string submittingPbuid;
    std::string securityId;
    std::string securityIdsource;
    uint16_t ownerType;
    std::string clearingFirm;
    int64_t transactTime;
    std::string userInfo;
    std::string orderId;
    std::string clOrdId;
    std::string quoteMsgId;
    std::string origClOrdId;
    std::string execId;
    std::string execType;
    std::string ordStatus;
    uint16_t ordRejReason;
    int64_t leavesQty;
    int64_t cumQty;
    std::string side;
    std::string ordType;
    int64_t orderQty;
    int64_t price;
    std::string accountId;
    std::string branchId;
    std::string orderRestrictions;
    std::unique_ptr<codec::BinaryCodec> applExtend;

    void encode(ByteBuf& buf) const override {
        buf.write_i32(partitionNo);
        buf.write_i64(reportIndex);
        codec::write_fixed_string(buf, applId, 3);
        codec::write_fixed_string(buf, reportingPbuid, 6);
        codec::write_fixed_string(buf, submittingPbuid, 6);
        codec::write_fixed_string(buf, securityId, 8);
        codec::write_fixed_string(buf, securityIdsource, 4);
        buf.write_u16(ownerType);
        codec::write_fixed_string(buf, clearingFirm, 2);
        buf.write_i64(transactTime);
        codec::write_fixed_string(buf, userInfo, 8);
        codec::write_fixed_string(buf, orderId, 16);
        codec::write_fixed_string(buf, clOrdId, 10);
        codec::write_fixed_string(buf, quoteMsgId, 10);
        codec::write_fixed_string(buf, origClOrdId, 10);
        codec::write_fixed_string(buf, execId, 16);
        codec::write_fixed_string(buf, execType, 1);
        codec::write_fixed_string(buf, ordStatus, 1);
        buf.write_u16(ordRejReason);
        buf.write_i64(leavesQty);
        buf.write_i64(cumQty);
        codec::write_fixed_string(buf, side, 1);
        codec::write_fixed_string(buf, ordType, 1);
        buf.write_i64(orderQty);
        buf.write_i64(price);
        codec::write_fixed_string(buf, accountId, 12);
        codec::write_fixed_string(buf, branchId, 4);
        codec::write_fixed_string(buf, orderRestrictions, 4);
        applExtend->encode(buf);
    }
    

    void decode(ByteBuf& buf) override {
        partitionNo = buf.read_i32();
        reportIndex = buf.read_i64();
        applId = codec::read_fixed_string(buf, 3);
        reportingPbuid = codec::read_fixed_string(buf, 6);
        submittingPbuid = codec::read_fixed_string(buf, 6);
        securityId = codec::read_fixed_string(buf, 8);
        securityIdsource = codec::read_fixed_string(buf, 4);
        ownerType = buf.read_u16();
        clearingFirm = codec::read_fixed_string(buf, 2);
        transactTime = buf.read_i64();
        userInfo = codec::read_fixed_string(buf, 8);
        orderId = codec::read_fixed_string(buf, 16);
        clOrdId = codec::read_fixed_string(buf, 10);
        quoteMsgId = codec::read_fixed_string(buf, 10);
        origClOrdId = codec::read_fixed_string(buf, 10);
        execId = codec::read_fixed_string(buf, 16);
        execType = codec::read_fixed_string(buf, 1);
        ordStatus = codec::read_fixed_string(buf, 1);
        ordRejReason = buf.read_u16();
        leavesQty = buf.read_i64();
        cumQty = buf.read_i64();
        side = codec::read_fixed_string(buf, 1);
        ordType = codec::read_fixed_string(buf, 1);
        orderQty = buf.read_i64();
        price = buf.read_i64();
        accountId = codec::read_fixed_string(buf, 12);
        branchId = codec::read_fixed_string(buf, 4);
        orderRestrictions = codec::read_fixed_string(buf, 4);
        applExtend = ExecutionConfirmMessageFactory::getInstance().create(applId);
        applExtend->decode(buf);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const ExecutionConfirm*>(&other);
        if(!checkType) return false;
        return partitionNo == checkType->partitionNo
               && reportIndex == checkType->reportIndex
               && applId == checkType->applId
               && reportingPbuid == checkType->reportingPbuid
               && submittingPbuid == checkType->submittingPbuid
               && securityId == checkType->securityId
               && securityIdsource == checkType->securityIdsource
               && ownerType == checkType->ownerType
               && clearingFirm == checkType->clearingFirm
               && transactTime == checkType->transactTime
               && userInfo == checkType->userInfo
               && orderId == checkType->orderId
               && clOrdId == checkType->clOrdId
               && quoteMsgId == checkType->quoteMsgId
               && origClOrdId == checkType->origClOrdId
               && execId == checkType->execId
               && execType == checkType->execType
               && ordStatus == checkType->ordStatus
               && ordRejReason == checkType->ordRejReason
               && leavesQty == checkType->leavesQty
               && cumQty == checkType->cumQty
               && side == checkType->side
               && ordType == checkType->ordType
               && orderQty == checkType->orderQty
               && price == checkType->price
               && accountId == checkType->accountId
               && branchId == checkType->branchId
               && orderRestrictions == checkType->orderRestrictions
               && applExtend->equals(*checkType->applExtend);
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "ExecutionConfirm { "
        << "PartitionNo: " << std::to_string(partitionNo)
        << ", "
        << "ReportIndex: " << std::to_string(reportIndex)
        << ", "
        << "ApplID: " << applId
        << ", "
        << "ReportingPBUID: " << reportingPbuid
        << ", "
        << "SubmittingPBUID: " << submittingPbuid
        << ", "
        << "SecurityID: " << securityId
        << ", "
        << "SecurityIDSource: " << securityIdsource
        << ", "
        << "OwnerType: " << std::to_string(ownerType)
        << ", "
        << "ClearingFirm: " << clearingFirm
        << ", "
        << "TransactTime: " << std::to_string(transactTime)
        << ", "
        << "UserInfo: " << userInfo
        << ", "
        << "OrderID: " << orderId
        << ", "
        << "ClOrdID: " << clOrdId
        << ", "
        << "QuoteMsgID: " << quoteMsgId
        << ", "
        << "OrigClOrdID: " << origClOrdId
        << ", "
        << "ExecID: " << execId
        << ", "
        << "ExecType: " << execType
        << ", "
        << "OrdStatus: " << ordStatus
        << ", "
        << "OrdRejReason: " << std::to_string(ordRejReason)
        << ", "
        << "LeavesQty: " << std::to_string(leavesQty)
        << ", "
        << "CumQty: " << std::to_string(cumQty)
        << ", "
        << "Side: " << side
        << ", "
        << "OrdType: " << ordType
        << ", "
        << "OrderQty: " << std::to_string(orderQty)
        << ", "
        << "Price: " << std::to_string(price)
        << ", "
        << "AccountID: " << accountId
        << ", "
        << "BranchID: " << branchId
        << ", "
        << "OrderRestrictions: " << orderRestrictions
        << ", "
        << "ApplExtend: " << applExtend->toString()
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const ExecutionConfirm& pkt) {
    return os << pkt.toString();
}





struct Extend200402 : public codec::BinaryCodec {
    int64_t stopPx;
    int64_t minQty;
    uint16_t maxPriceLevels;
    std::string timeInForce;
    std::string positionEffect;
    uint8_t coveredOrUncovered;
    std::string contractAccountCode;
    std::string secondaryOrderId;

    void encode(ByteBuf& buf) const override {
        buf.write_i64(stopPx);
        buf.write_i64(minQty);
        buf.write_u16(maxPriceLevels);
        codec::write_fixed_string(buf, timeInForce, 1);
        codec::write_fixed_string(buf, positionEffect, 1);
        buf.write_u8(coveredOrUncovered);
        codec::write_fixed_string(buf, contractAccountCode, 6);
        codec::write_fixed_string(buf, secondaryOrderId, 16);
    }
    

    void decode(ByteBuf& buf) override {
        stopPx = buf.read_i64();
        minQty = buf.read_i64();
        maxPriceLevels = buf.read_u16();
        timeInForce = codec::read_fixed_string(buf, 1);
        positionEffect = codec::read_fixed_string(buf, 1);
        coveredOrUncovered = buf.read_u8();
        contractAccountCode = codec::read_fixed_string(buf, 6);
        secondaryOrderId = codec::read_fixed_string(buf, 16);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const Extend200402*>(&other);
        if(!checkType) return false;
        return stopPx == checkType->stopPx
               && minQty == checkType->minQty
               && maxPriceLevels == checkType->maxPriceLevels
               && timeInForce == checkType->timeInForce
               && positionEffect == checkType->positionEffect
               && coveredOrUncovered == checkType->coveredOrUncovered
               && contractAccountCode == checkType->contractAccountCode
               && secondaryOrderId == checkType->secondaryOrderId;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "Extend200402 { "
        << "StopPx: " << std::to_string(stopPx)
        << ", "
        << "MinQty: " << std::to_string(minQty)
        << ", "
        << "MaxPriceLevels: " << std::to_string(maxPriceLevels)
        << ", "
        << "TimeInForce: " << timeInForce
        << ", "
        << "PositionEffect: " << positionEffect
        << ", "
        << "CoveredOrUncovered: " << static_cast<unsigned>(coveredOrUncovered)
        << ", "
        << "ContractAccountCode: " << contractAccountCode
        << ", "
        << "SecondaryOrderID: " << secondaryOrderId
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const Extend200402& pkt) {
    return os << pkt.toString();
}





struct Extend201202 : public codec::BinaryCodec {
    std::string insufficientSecurityId;
    uint32_t noSecurity;
    std::string underlyingSecurityId;
    std::string underlyingSecurityIdsource;
    int64_t deliveryQty;
    int64_t substCash;

    void encode(ByteBuf& buf) const override {
        codec::write_fixed_string(buf, insufficientSecurityId, 8);
        buf.write_u32(noSecurity);
        codec::write_fixed_string(buf, underlyingSecurityId, 8);
        codec::write_fixed_string(buf, underlyingSecurityIdsource, 4);
        buf.write_i64(deliveryQty);
        buf.write_i64(substCash);
    }
    

    void decode(ByteBuf& buf) override {
        insufficientSecurityId = codec::read_fixed_string(buf, 8);
        noSecurity = buf.read_u32();
        underlyingSecurityId = codec::read_fixed_string(buf, 8);
        underlyingSecurityIdsource = codec::read_fixed_string(buf, 4);
        deliveryQty = buf.read_i64();
        substCash = buf.read_i64();
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const Extend201202*>(&other);
        if(!checkType) return false;
        return insufficientSecurityId == checkType->insufficientSecurityId
               && noSecurity == checkType->noSecurity
               && underlyingSecurityId == checkType->underlyingSecurityId
               && underlyingSecurityIdsource == checkType->underlyingSecurityIdsource
               && deliveryQty == checkType->deliveryQty
               && substCash == checkType->substCash;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "Extend201202 { "
        << "InsufficientSecurityID: " << insufficientSecurityId
        << ", "
        << "NoSecurity: " << std::to_string(noSecurity)
        << ", "
        << "UnderlyingSecurityID: " << underlyingSecurityId
        << ", "
        << "UnderlyingSecurityIDSource: " << underlyingSecurityIdsource
        << ", "
        << "DeliveryQty: " << std::to_string(deliveryQty)
        << ", "
        << "SubstCash: " << std::to_string(substCash)
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const Extend201202& pkt) {
    return os << pkt.toString();
}









struct Extend203102 : public codec::BinaryCodec {
    std::string insufficientSecurityId;
    uint32_t noSecurity;
    std::string underlyingSecurityId;
    std::string underlyingSecurityIdsource;
    int64_t deliveryQty;

    void encode(ByteBuf& buf) const override {
        codec::write_fixed_string(buf, insufficientSecurityId, 8);
        buf.write_u32(noSecurity);
        codec::write_fixed_string(buf, underlyingSecurityId, 8);
        codec::write_fixed_string(buf, underlyingSecurityIdsource, 4);
        buf.write_i64(deliveryQty);
    }
    

    void decode(ByteBuf& buf) override {
        insufficientSecurityId = codec::read_fixed_string(buf, 8);
        noSecurity = buf.read_u32();
        underlyingSecurityId = codec::read_fixed_string(buf, 8);
        underlyingSecurityIdsource = codec::read_fixed_string(buf, 4);
        deliveryQty = buf.read_i64();
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const Extend203102*>(&other);
        if(!checkType) return false;
        return insufficientSecurityId == checkType->insufficientSecurityId
               && noSecurity == checkType->noSecurity
               && underlyingSecurityId == checkType->underlyingSecurityId
               && underlyingSecurityIdsource == checkType->underlyingSecurityIdsource
               && deliveryQty == checkType->deliveryQty;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "Extend203102 { "
        << "InsufficientSecurityID: " << insufficientSecurityId
        << ", "
        << "NoSecurity: " << std::to_string(noSecurity)
        << ", "
        << "UnderlyingSecurityID: " << underlyingSecurityId
        << ", "
        << "UnderlyingSecurityIDSource: " << underlyingSecurityIdsource
        << ", "
        << "DeliveryQty: " << std::to_string(deliveryQty)
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const Extend203102& pkt) {
    return os << pkt.toString();
}








struct Extend200115 : public codec::BinaryCodec {
    std::string cashMargin;

    void encode(ByteBuf& buf) const override {
        codec::write_fixed_string(buf, cashMargin, 1);
    }
    

    void decode(ByteBuf& buf) override {
        cashMargin = codec::read_fixed_string(buf, 1);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const Extend200115*>(&other);
        if(!checkType) return false;
        return cashMargin == checkType->cashMargin;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "Extend200115 { "
        << "CashMargin: " << cashMargin
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const Extend200115& pkt) {
    return os << pkt.toString();
}


struct Extend200215 : public codec::BinaryCodec {
    uint32_t maturityDate;

    void encode(ByteBuf& buf) const override {
        buf.write_u32(maturityDate);
    }
    

    void decode(ByteBuf& buf) override {
        maturityDate = buf.read_u32();
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const Extend200215*>(&other);
        if(!checkType) return false;
        return maturityDate == checkType->maturityDate;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "Extend200215 { "
        << "MaturityDate: " << std::to_string(maturityDate)
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const Extend200215& pkt) {
    return os << pkt.toString();
}


struct Extend200315 : public codec::BinaryCodec {
    uint32_t maturityDate;

    void encode(ByteBuf& buf) const override {
        buf.write_u32(maturityDate);
    }
    

    void decode(ByteBuf& buf) override {
        maturityDate = buf.read_u32();
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const Extend200315*>(&other);
        if(!checkType) return false;
        return maturityDate == checkType->maturityDate;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "Extend200315 { "
        << "MaturityDate: " << std::to_string(maturityDate)
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const Extend200315& pkt) {
    return os << pkt.toString();
}


struct Extend200515 : public codec::BinaryCodec {
    std::string confirmId;
    std::string cashMargin;

    void encode(ByteBuf& buf) const override {
        codec::write_fixed_string(buf, confirmId, 8);
        codec::write_fixed_string(buf, cashMargin, 1);
    }
    

    void decode(ByteBuf& buf) override {
        confirmId = codec::read_fixed_string(buf, 8);
        cashMargin = codec::read_fixed_string(buf, 1);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const Extend200515*>(&other);
        if(!checkType) return false;
        return confirmId == checkType->confirmId
               && cashMargin == checkType->cashMargin;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "Extend200515 { "
        << "ConfirmID: " << confirmId
        << ", "
        << "CashMargin: " << cashMargin
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const Extend200515& pkt) {
    return os << pkt.toString();
}


struct Extend200615 : public codec::BinaryCodec {
    std::string cashMargin;

    void encode(ByteBuf& buf) const override {
        codec::write_fixed_string(buf, cashMargin, 1);
    }
    

    void decode(ByteBuf& buf) override {
        cashMargin = codec::read_fixed_string(buf, 1);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const Extend200615*>(&other);
        if(!checkType) return false;
        return cashMargin == checkType->cashMargin;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "Extend200615 { "
        << "CashMargin: " << cashMargin
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const Extend200615& pkt) {
    return os << pkt.toString();
}


struct Extend200715 : public codec::BinaryCodec {
    uint16_t expirationDays;
    uint8_t expirationType;
    uint32_t maturityDate;
    std::string shareProperty;

    void encode(ByteBuf& buf) const override {
        buf.write_u16(expirationDays);
        buf.write_u8(expirationType);
        buf.write_u32(maturityDate);
        codec::write_fixed_string(buf, shareProperty, 2);
    }
    

    void decode(ByteBuf& buf) override {
        expirationDays = buf.read_u16();
        expirationType = buf.read_u8();
        maturityDate = buf.read_u32();
        shareProperty = codec::read_fixed_string(buf, 2);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const Extend200715*>(&other);
        if(!checkType) return false;
        return expirationDays == checkType->expirationDays
               && expirationType == checkType->expirationType
               && maturityDate == checkType->maturityDate
               && shareProperty == checkType->shareProperty;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "Extend200715 { "
        << "ExpirationDays: " << std::to_string(expirationDays)
        << ", "
        << "ExpirationType: " << static_cast<unsigned>(expirationType)
        << ", "
        << "MaturityDate: " << std::to_string(maturityDate)
        << ", "
        << "ShareProperty: " << shareProperty
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const Extend200715& pkt) {
    return os << pkt.toString();
}


struct Extend206315 : public codec::BinaryCodec {
    std::string cashMargin;

    void encode(ByteBuf& buf) const override {
        codec::write_fixed_string(buf, cashMargin, 1);
    }
    

    void decode(ByteBuf& buf) override {
        cashMargin = codec::read_fixed_string(buf, 1);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const Extend206315*>(&other);
        if(!checkType) return false;
        return cashMargin == checkType->cashMargin;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "Extend206315 { "
        << "CashMargin: " << cashMargin
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const Extend206315& pkt) {
    return os << pkt.toString();
}


struct Extend203715 : public codec::BinaryCodec {
    std::string cashMargin;

    void encode(ByteBuf& buf) const override {
        codec::write_fixed_string(buf, cashMargin, 1);
    }
    

    void decode(ByteBuf& buf) override {
        cashMargin = codec::read_fixed_string(buf, 1);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const Extend203715*>(&other);
        if(!checkType) return false;
        return cashMargin == checkType->cashMargin;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "Extend203715 { "
        << "CashMargin: " << cashMargin
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const Extend203715& pkt) {
    return os << pkt.toString();
}


struct Extend204115 : public codec::BinaryCodec {
    std::string cashMargin;
    uint16_t settlType;
    uint8_t settlPeriod;
    std::string counterpartyMemberId;
    std::string counterpartyInvestorType;
    std::string counterpartyInvestorId;
    std::string counterpartyInvestorName;
    std::string counterpartyTraderCode;

    void encode(ByteBuf& buf) const override {
        codec::write_fixed_string(buf, cashMargin, 1);
        buf.write_u16(settlType);
        buf.write_u8(settlPeriod);
        codec::write_fixed_string(buf, counterpartyMemberId, 6);
        codec::write_fixed_string(buf, counterpartyInvestorType, 2);
        codec::write_fixed_string(buf, counterpartyInvestorId, 10);
        codec::write_fixed_string(buf, counterpartyInvestorName, 120);
        codec::write_fixed_string(buf, counterpartyTraderCode, 8);
    }
    

    void decode(ByteBuf& buf) override {
        cashMargin = codec::read_fixed_string(buf, 1);
        settlType = buf.read_u16();
        settlPeriod = buf.read_u8();
        counterpartyMemberId = codec::read_fixed_string(buf, 6);
        counterpartyInvestorType = codec::read_fixed_string(buf, 2);
        counterpartyInvestorId = codec::read_fixed_string(buf, 10);
        counterpartyInvestorName = codec::read_fixed_string(buf, 120);
        counterpartyTraderCode = codec::read_fixed_string(buf, 8);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const Extend204115*>(&other);
        if(!checkType) return false;
        return cashMargin == checkType->cashMargin
               && settlType == checkType->settlType
               && settlPeriod == checkType->settlPeriod
               && counterpartyMemberId == checkType->counterpartyMemberId
               && counterpartyInvestorType == checkType->counterpartyInvestorType
               && counterpartyInvestorId == checkType->counterpartyInvestorId
               && counterpartyInvestorName == checkType->counterpartyInvestorName
               && counterpartyTraderCode == checkType->counterpartyTraderCode;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "Extend204115 { "
        << "CashMargin: " << cashMargin
        << ", "
        << "SettlType: " << std::to_string(settlType)
        << ", "
        << "SettlPeriod: " << static_cast<unsigned>(settlPeriod)
        << ", "
        << "CounterpartyMemberID: " << counterpartyMemberId
        << ", "
        << "CounterpartyInvestorType: " << counterpartyInvestorType
        << ", "
        << "CounterpartyInvestorID: " << counterpartyInvestorId
        << ", "
        << "CounterpartyInvestorName: " << counterpartyInvestorName
        << ", "
        << "CounterpartyTraderCode: " << counterpartyTraderCode
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const Extend204115& pkt) {
    return os << pkt.toString();
}


struct Extend204130 : public codec::BinaryCodec {
    std::string memberId;
    std::string investorType;
    std::string investorId;
    std::string investorName;
    std::string traderCode;
    std::string counterpartyMemberId;
    std::string counterpartyInvestorType;
    std::string counterpartyInvestorId;
    std::string counterpartyInvestorName;
    std::string counterpartyTraderCode;
    std::string secondaryOrderId;
    uint16_t bidTransType;
    uint16_t bidExecInstType;
    uint16_t settlType;
    uint8_t settlPeriod;
    std::string cashMargin;
    std::string memo;

    void encode(ByteBuf& buf) const override {
        codec::write_fixed_string(buf, memberId, 6);
        codec::write_fixed_string(buf, investorType, 2);
        codec::write_fixed_string(buf, investorId, 10);
        codec::write_fixed_string(buf, investorName, 120);
        codec::write_fixed_string(buf, traderCode, 8);
        codec::write_fixed_string(buf, counterpartyMemberId, 6);
        codec::write_fixed_string(buf, counterpartyInvestorType, 2);
        codec::write_fixed_string(buf, counterpartyInvestorId, 10);
        codec::write_fixed_string(buf, counterpartyInvestorName, 120);
        codec::write_fixed_string(buf, counterpartyTraderCode, 8);
        codec::write_fixed_string(buf, secondaryOrderId, 16);
        buf.write_u16(bidTransType);
        buf.write_u16(bidExecInstType);
        buf.write_u16(settlType);
        buf.write_u8(settlPeriod);
        codec::write_fixed_string(buf, cashMargin, 1);
        codec::write_fixed_string(buf, memo, 160);
    }
    

    void decode(ByteBuf& buf) override {
        memberId = codec::read_fixed_string(buf, 6);
        investorType = codec::read_fixed_string(buf, 2);
        investorId = codec::read_fixed_string(buf, 10);
        investorName = codec::read_fixed_string(buf, 120);
        traderCode = codec::read_fixed_string(buf, 8);
        counterpartyMemberId = codec::read_fixed_string(buf, 6);
        counterpartyInvestorType = codec::read_fixed_string(buf, 2);
        counterpartyInvestorId = codec::read_fixed_string(buf, 10);
        counterpartyInvestorName = codec::read_fixed_string(buf, 120);
        counterpartyTraderCode = codec::read_fixed_string(buf, 8);
        secondaryOrderId = codec::read_fixed_string(buf, 16);
        bidTransType = buf.read_u16();
        bidExecInstType = buf.read_u16();
        settlType = buf.read_u16();
        settlPeriod = buf.read_u8();
        cashMargin = codec::read_fixed_string(buf, 1);
        memo = codec::read_fixed_string(buf, 160);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const Extend204130*>(&other);
        if(!checkType) return false;
        return memberId == checkType->memberId
               && investorType == checkType->investorType
               && investorId == checkType->investorId
               && investorName == checkType->investorName
               && traderCode == checkType->traderCode
               && counterpartyMemberId == checkType->counterpartyMemberId
               && counterpartyInvestorType == checkType->counterpartyInvestorType
               && counterpartyInvestorId == checkType->counterpartyInvestorId
               && counterpartyInvestorName == checkType->counterpartyInvestorName
               && counterpartyTraderCode == checkType->counterpartyTraderCode
               && secondaryOrderId == checkType->secondaryOrderId
               && bidTransType == checkType->bidTransType
               && bidExecInstType == checkType->bidExecInstType
               && settlType == checkType->settlType
               && settlPeriod == checkType->settlPeriod
               && cashMargin == checkType->cashMargin
               && memo == checkType->memo;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "Extend204130 { "
        << "MemberID: " << memberId
        << ", "
        << "InvestorType: " << investorType
        << ", "
        << "InvestorID: " << investorId
        << ", "
        << "InvestorName: " << investorName
        << ", "
        << "TraderCode: " << traderCode
        << ", "
        << "CounterpartyMemberID: " << counterpartyMemberId
        << ", "
        << "CounterpartyInvestorType: " << counterpartyInvestorType
        << ", "
        << "CounterpartyInvestorID: " << counterpartyInvestorId
        << ", "
        << "CounterpartyInvestorName: " << counterpartyInvestorName
        << ", "
        << "CounterpartyTraderCode: " << counterpartyTraderCode
        << ", "
        << "SecondaryOrderID: " << secondaryOrderId
        << ", "
        << "BidTransType: " << std::to_string(bidTransType)
        << ", "
        << "BidExecInstType: " << std::to_string(bidExecInstType)
        << ", "
        << "SettlType: " << std::to_string(settlType)
        << ", "
        << "SettlPeriod: " << static_cast<unsigned>(settlPeriod)
        << ", "
        << "CashMargin: " << cashMargin
        << ", "
        << "Memo: " << memo
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const Extend204130& pkt) {
    return os << pkt.toString();
}


struct Extend204715 : public codec::BinaryCodec {
    uint16_t expirationDays;
    uint8_t expirationType;
    uint32_t maturityDate;
    std::string shareProperty;

    void encode(ByteBuf& buf) const override {
        buf.write_u16(expirationDays);
        buf.write_u8(expirationType);
        buf.write_u32(maturityDate);
        codec::write_fixed_string(buf, shareProperty, 2);
    }
    

    void decode(ByteBuf& buf) override {
        expirationDays = buf.read_u16();
        expirationType = buf.read_u8();
        maturityDate = buf.read_u32();
        shareProperty = codec::read_fixed_string(buf, 2);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const Extend204715*>(&other);
        if(!checkType) return false;
        return expirationDays == checkType->expirationDays
               && expirationType == checkType->expirationType
               && maturityDate == checkType->maturityDate
               && shareProperty == checkType->shareProperty;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "Extend204715 { "
        << "ExpirationDays: " << std::to_string(expirationDays)
        << ", "
        << "ExpirationType: " << static_cast<unsigned>(expirationType)
        << ", "
        << "MaturityDate: " << std::to_string(maturityDate)
        << ", "
        << "ShareProperty: " << shareProperty
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const Extend204715& pkt) {
    return os << pkt.toString();
}


struct ExecutionReportTag{};
using ExecutionReportMessageFactory = MessageFactory<std::string, codec::BinaryCodec, ExecutionReportTag>;
REGISTER_MESSAGE(ExecutionReportMessageFactory, "010", Extend200115);
REGISTER_MESSAGE(ExecutionReportMessageFactory, "020", Extend200215);
REGISTER_MESSAGE(ExecutionReportMessageFactory, "030", Extend200315);
REGISTER_MESSAGE(ExecutionReportMessageFactory, "051", Extend200515);
REGISTER_MESSAGE(ExecutionReportMessageFactory, "052", Extend200515);
REGISTER_MESSAGE(ExecutionReportMessageFactory, "056", Extend200515);
REGISTER_MESSAGE(ExecutionReportMessageFactory, "057", Extend200515);
REGISTER_MESSAGE(ExecutionReportMessageFactory, "060", Extend200615);
REGISTER_MESSAGE(ExecutionReportMessageFactory, "061", Extend200615);
REGISTER_MESSAGE(ExecutionReportMessageFactory, "070", Extend200715);
REGISTER_MESSAGE(ExecutionReportMessageFactory, "630", Extend206315);
REGISTER_MESSAGE(ExecutionReportMessageFactory, "370", Extend203715);
REGISTER_MESSAGE(ExecutionReportMessageFactory, "410", Extend204115);
REGISTER_MESSAGE(ExecutionReportMessageFactory, "412", Extend204115);
REGISTER_MESSAGE(ExecutionReportMessageFactory, "413", Extend204115);
REGISTER_MESSAGE(ExecutionReportMessageFactory, "415", Extend204115);
REGISTER_MESSAGE(ExecutionReportMessageFactory, "416", Extend204115);
REGISTER_MESSAGE(ExecutionReportMessageFactory, "417", Extend204130);
REGISTER_MESSAGE(ExecutionReportMessageFactory, "470", Extend204715);


struct ExecutionReport : public codec::BinaryCodec {
    int32_t partitionNo;
    int64_t reportIndex;
    std::string applId;
    std::string reportingPbuid;
    std::string submittingPbuid;
    std::string securityId;
    std::string securityIdsource;
    uint16_t ownerType;
    std::string clearingFirm;
    int64_t transactTime;
    std::string userInfo;
    std::string orderId;
    std::string clOrdId;
    std::string quoteMsgId;
    std::string execId;
    std::string execType;
    std::string ordStatus;
    int64_t lastPx;
    int64_t lastQty;
    int64_t leavesQty;
    int64_t cumQty;
    std::string side;
    std::string accountId;
    std::string branchId;
    std::unique_ptr<codec::BinaryCodec> applExtend;

    void encode(ByteBuf& buf) const override {
        buf.write_i32(partitionNo);
        buf.write_i64(reportIndex);
        codec::write_fixed_string(buf, applId, 3);
        codec::write_fixed_string(buf, reportingPbuid, 6);
        codec::write_fixed_string(buf, submittingPbuid, 6);
        codec::write_fixed_string(buf, securityId, 8);
        codec::write_fixed_string(buf, securityIdsource, 4);
        buf.write_u16(ownerType);
        codec::write_fixed_string(buf, clearingFirm, 2);
        buf.write_i64(transactTime);
        codec::write_fixed_string(buf, userInfo, 8);
        codec::write_fixed_string(buf, orderId, 16);
        codec::write_fixed_string(buf, clOrdId, 10);
        codec::write_fixed_string(buf, quoteMsgId, 10);
        codec::write_fixed_string(buf, execId, 16);
        codec::write_fixed_string(buf, execType, 1);
        codec::write_fixed_string(buf, ordStatus, 1);
        buf.write_i64(lastPx);
        buf.write_i64(lastQty);
        buf.write_i64(leavesQty);
        buf.write_i64(cumQty);
        codec::write_fixed_string(buf, side, 1);
        codec::write_fixed_string(buf, accountId, 12);
        codec::write_fixed_string(buf, branchId, 4);
        applExtend->encode(buf);
    }
    

    void decode(ByteBuf& buf) override {
        partitionNo = buf.read_i32();
        reportIndex = buf.read_i64();
        applId = codec::read_fixed_string(buf, 3);
        reportingPbuid = codec::read_fixed_string(buf, 6);
        submittingPbuid = codec::read_fixed_string(buf, 6);
        securityId = codec::read_fixed_string(buf, 8);
        securityIdsource = codec::read_fixed_string(buf, 4);
        ownerType = buf.read_u16();
        clearingFirm = codec::read_fixed_string(buf, 2);
        transactTime = buf.read_i64();
        userInfo = codec::read_fixed_string(buf, 8);
        orderId = codec::read_fixed_string(buf, 16);
        clOrdId = codec::read_fixed_string(buf, 10);
        quoteMsgId = codec::read_fixed_string(buf, 10);
        execId = codec::read_fixed_string(buf, 16);
        execType = codec::read_fixed_string(buf, 1);
        ordStatus = codec::read_fixed_string(buf, 1);
        lastPx = buf.read_i64();
        lastQty = buf.read_i64();
        leavesQty = buf.read_i64();
        cumQty = buf.read_i64();
        side = codec::read_fixed_string(buf, 1);
        accountId = codec::read_fixed_string(buf, 12);
        branchId = codec::read_fixed_string(buf, 4);
        applExtend = ExecutionReportMessageFactory::getInstance().create(applId);
        applExtend->decode(buf);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const ExecutionReport*>(&other);
        if(!checkType) return false;
        return partitionNo == checkType->partitionNo
               && reportIndex == checkType->reportIndex
               && applId == checkType->applId
               && reportingPbuid == checkType->reportingPbuid
               && submittingPbuid == checkType->submittingPbuid
               && securityId == checkType->securityId
               && securityIdsource == checkType->securityIdsource
               && ownerType == checkType->ownerType
               && clearingFirm == checkType->clearingFirm
               && transactTime == checkType->transactTime
               && userInfo == checkType->userInfo
               && orderId == checkType->orderId
               && clOrdId == checkType->clOrdId
               && quoteMsgId == checkType->quoteMsgId
               && execId == checkType->execId
               && execType == checkType->execType
               && ordStatus == checkType->ordStatus
               && lastPx == checkType->lastPx
               && lastQty == checkType->lastQty
               && leavesQty == checkType->leavesQty
               && cumQty == checkType->cumQty
               && side == checkType->side
               && accountId == checkType->accountId
               && branchId == checkType->branchId
               && applExtend->equals(*checkType->applExtend);
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "ExecutionReport { "
        << "PartitionNo: " << std::to_string(partitionNo)
        << ", "
        << "ReportIndex: " << std::to_string(reportIndex)
        << ", "
        << "ApplID: " << applId
        << ", "
        << "ReportingPBUID: " << reportingPbuid
        << ", "
        << "SubmittingPBUID: " << submittingPbuid
        << ", "
        << "SecurityID: " << securityId
        << ", "
        << "SecurityIDSource: " << securityIdsource
        << ", "
        << "OwnerType: " << std::to_string(ownerType)
        << ", "
        << "ClearingFirm: " << clearingFirm
        << ", "
        << "TransactTime: " << std::to_string(transactTime)
        << ", "
        << "UserInfo: " << userInfo
        << ", "
        << "OrderID: " << orderId
        << ", "
        << "ClOrdID: " << clOrdId
        << ", "
        << "QuoteMsgID: " << quoteMsgId
        << ", "
        << "ExecID: " << execId
        << ", "
        << "ExecType: " << execType
        << ", "
        << "OrdStatus: " << ordStatus
        << ", "
        << "LastPx: " << std::to_string(lastPx)
        << ", "
        << "LastQty: " << std::to_string(lastQty)
        << ", "
        << "LeavesQty: " << std::to_string(leavesQty)
        << ", "
        << "CumQty: " << std::to_string(cumQty)
        << ", "
        << "Side: " << side
        << ", "
        << "AccountID: " << accountId
        << ", "
        << "BranchID: " << branchId
        << ", "
        << "ApplExtend: " << applExtend->toString()
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const ExecutionReport& pkt) {
    return os << pkt.toString();
}





struct Extend200415 : public codec::BinaryCodec {
    std::string positionEffect;
    uint8_t coveredOrUncovered;
    std::string contractAccountCode;
    std::string secondaryOrderId;

    void encode(ByteBuf& buf) const override {
        codec::write_fixed_string(buf, positionEffect, 1);
        buf.write_u8(coveredOrUncovered);
        codec::write_fixed_string(buf, contractAccountCode, 6);
        codec::write_fixed_string(buf, secondaryOrderId, 16);
    }
    

    void decode(ByteBuf& buf) override {
        positionEffect = codec::read_fixed_string(buf, 1);
        coveredOrUncovered = buf.read_u8();
        contractAccountCode = codec::read_fixed_string(buf, 6);
        secondaryOrderId = codec::read_fixed_string(buf, 16);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const Extend200415*>(&other);
        if(!checkType) return false;
        return positionEffect == checkType->positionEffect
               && coveredOrUncovered == checkType->coveredOrUncovered
               && contractAccountCode == checkType->contractAccountCode
               && secondaryOrderId == checkType->secondaryOrderId;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "Extend200415 { "
        << "PositionEffect: " << positionEffect
        << ", "
        << "CoveredOrUncovered: " << static_cast<unsigned>(coveredOrUncovered)
        << ", "
        << "ContractAccountCode: " << contractAccountCode
        << ", "
        << "SecondaryOrderID: " << secondaryOrderId
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const Extend200415& pkt) {
    return os << pkt.toString();
}










struct OrderCancelRequest : public codec::BinaryCodec {
    std::string applId;
    std::string submittingPbuid;
    std::string securityId;
    std::string securityIdsource;
    uint16_t ownerType;
    std::string clearingFirm;
    int64_t transactTime;
    std::string userInfo;
    std::string clOrdId;
    std::string origClOrdId;
    std::string side;
    std::string orderId;
    int64_t orderQty;

    void encode(ByteBuf& buf) const override {
        codec::write_fixed_string(buf, applId, 3);
        codec::write_fixed_string(buf, submittingPbuid, 6);
        codec::write_fixed_string(buf, securityId, 8);
        codec::write_fixed_string(buf, securityIdsource, 4);
        buf.write_u16(ownerType);
        codec::write_fixed_string(buf, clearingFirm, 2);
        buf.write_i64(transactTime);
        codec::write_fixed_string(buf, userInfo, 8);
        codec::write_fixed_string(buf, clOrdId, 10);
        codec::write_fixed_string(buf, origClOrdId, 10);
        codec::write_fixed_string(buf, side, 1);
        codec::write_fixed_string(buf, orderId, 16);
        buf.write_i64(orderQty);
    }
    

    void decode(ByteBuf& buf) override {
        applId = codec::read_fixed_string(buf, 3);
        submittingPbuid = codec::read_fixed_string(buf, 6);
        securityId = codec::read_fixed_string(buf, 8);
        securityIdsource = codec::read_fixed_string(buf, 4);
        ownerType = buf.read_u16();
        clearingFirm = codec::read_fixed_string(buf, 2);
        transactTime = buf.read_i64();
        userInfo = codec::read_fixed_string(buf, 8);
        clOrdId = codec::read_fixed_string(buf, 10);
        origClOrdId = codec::read_fixed_string(buf, 10);
        side = codec::read_fixed_string(buf, 1);
        orderId = codec::read_fixed_string(buf, 16);
        orderQty = buf.read_i64();
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const OrderCancelRequest*>(&other);
        if(!checkType) return false;
        return applId == checkType->applId
               && submittingPbuid == checkType->submittingPbuid
               && securityId == checkType->securityId
               && securityIdsource == checkType->securityIdsource
               && ownerType == checkType->ownerType
               && clearingFirm == checkType->clearingFirm
               && transactTime == checkType->transactTime
               && userInfo == checkType->userInfo
               && clOrdId == checkType->clOrdId
               && origClOrdId == checkType->origClOrdId
               && side == checkType->side
               && orderId == checkType->orderId
               && orderQty == checkType->orderQty;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "OrderCancelRequest { "
        << "ApplID: " << applId
        << ", "
        << "SubmittingPBUID: " << submittingPbuid
        << ", "
        << "SecurityID: " << securityId
        << ", "
        << "SecurityIDSource: " << securityIdsource
        << ", "
        << "OwnerType: " << std::to_string(ownerType)
        << ", "
        << "ClearingFirm: " << clearingFirm
        << ", "
        << "TransactTime: " << std::to_string(transactTime)
        << ", "
        << "UserInfo: " << userInfo
        << ", "
        << "ClOrdID: " << clOrdId
        << ", "
        << "OrigClOrdID: " << origClOrdId
        << ", "
        << "Side: " << side
        << ", "
        << "OrderID: " << orderId
        << ", "
        << "OrderQty: " << std::to_string(orderQty)
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const OrderCancelRequest& pkt) {
    return os << pkt.toString();
}


struct CancelReject : public codec::BinaryCodec {
    int32_t partitionNo;
    int64_t reportIndex;
    std::string applId;
    std::string reportingPbuid;
    std::string submittingPbuid;
    std::string securityId;
    std::string securityIdsource;
    uint16_t ownerType;
    std::string clearingFirm;
    int64_t transactTime;
    std::string userInfo;
    std::string clOrdId;
    std::string origClOrdId;
    std::string side;
    std::string ordStatus;
    uint16_t cxlRejReason;
    std::string rejectText;
    std::string orderId;

    void encode(ByteBuf& buf) const override {
        buf.write_i32(partitionNo);
        buf.write_i64(reportIndex);
        codec::write_fixed_string(buf, applId, 3);
        codec::write_fixed_string(buf, reportingPbuid, 6);
        codec::write_fixed_string(buf, submittingPbuid, 6);
        codec::write_fixed_string(buf, securityId, 8);
        codec::write_fixed_string(buf, securityIdsource, 4);
        buf.write_u16(ownerType);
        codec::write_fixed_string(buf, clearingFirm, 2);
        buf.write_i64(transactTime);
        codec::write_fixed_string(buf, userInfo, 8);
        codec::write_fixed_string(buf, clOrdId, 10);
        codec::write_fixed_string(buf, origClOrdId, 10);
        codec::write_fixed_string(buf, side, 1);
        codec::write_fixed_string(buf, ordStatus, 1);
        buf.write_u16(cxlRejReason);
        codec::write_fixed_string(buf, rejectText, 16);
        codec::write_fixed_string(buf, orderId, 16);
    }
    

    void decode(ByteBuf& buf) override {
        partitionNo = buf.read_i32();
        reportIndex = buf.read_i64();
        applId = codec::read_fixed_string(buf, 3);
        reportingPbuid = codec::read_fixed_string(buf, 6);
        submittingPbuid = codec::read_fixed_string(buf, 6);
        securityId = codec::read_fixed_string(buf, 8);
        securityIdsource = codec::read_fixed_string(buf, 4);
        ownerType = buf.read_u16();
        clearingFirm = codec::read_fixed_string(buf, 2);
        transactTime = buf.read_i64();
        userInfo = codec::read_fixed_string(buf, 8);
        clOrdId = codec::read_fixed_string(buf, 10);
        origClOrdId = codec::read_fixed_string(buf, 10);
        side = codec::read_fixed_string(buf, 1);
        ordStatus = codec::read_fixed_string(buf, 1);
        cxlRejReason = buf.read_u16();
        rejectText = codec::read_fixed_string(buf, 16);
        orderId = codec::read_fixed_string(buf, 16);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const CancelReject*>(&other);
        if(!checkType) return false;
        return partitionNo == checkType->partitionNo
               && reportIndex == checkType->reportIndex
               && applId == checkType->applId
               && reportingPbuid == checkType->reportingPbuid
               && submittingPbuid == checkType->submittingPbuid
               && securityId == checkType->securityId
               && securityIdsource == checkType->securityIdsource
               && ownerType == checkType->ownerType
               && clearingFirm == checkType->clearingFirm
               && transactTime == checkType->transactTime
               && userInfo == checkType->userInfo
               && clOrdId == checkType->clOrdId
               && origClOrdId == checkType->origClOrdId
               && side == checkType->side
               && ordStatus == checkType->ordStatus
               && cxlRejReason == checkType->cxlRejReason
               && rejectText == checkType->rejectText
               && orderId == checkType->orderId;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "CancelReject { "
        << "PartitionNo: " << std::to_string(partitionNo)
        << ", "
        << "ReportIndex: " << std::to_string(reportIndex)
        << ", "
        << "ApplID: " << applId
        << ", "
        << "ReportingPBUID: " << reportingPbuid
        << ", "
        << "SubmittingPBUID: " << submittingPbuid
        << ", "
        << "SecurityID: " << securityId
        << ", "
        << "SecurityIDSource: " << securityIdsource
        << ", "
        << "OwnerType: " << std::to_string(ownerType)
        << ", "
        << "ClearingFirm: " << clearingFirm
        << ", "
        << "TransactTime: " << std::to_string(transactTime)
        << ", "
        << "UserInfo: " << userInfo
        << ", "
        << "ClOrdID: " << clOrdId
        << ", "
        << "OrigClOrdID: " << origClOrdId
        << ", "
        << "Side: " << side
        << ", "
        << "OrdStatus: " << ordStatus
        << ", "
        << "CxlRejReason: " << std::to_string(cxlRejReason)
        << ", "
        << "RejectText: " << rejectText
        << ", "
        << "OrderID: " << orderId
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const CancelReject& pkt) {
    return os << pkt.toString();
}


struct BusinessReject : public codec::BinaryCodec {
    std::string applId;
    int64_t transactTime;
    std::string submittingPbuid;
    std::string securityId;
    std::string securityIdsource;
    int64_t refSeqNum;
    uint32_t refMsgType;
    std::string businessRejectRefId;
    uint16_t businessRejectReason;
    std::string businessRejectText;

    void encode(ByteBuf& buf) const override {
        codec::write_fixed_string(buf, applId, 3);
        buf.write_i64(transactTime);
        codec::write_fixed_string(buf, submittingPbuid, 6);
        codec::write_fixed_string(buf, securityId, 8);
        codec::write_fixed_string(buf, securityIdsource, 4);
        buf.write_i64(refSeqNum);
        buf.write_u32(refMsgType);
        codec::write_fixed_string(buf, businessRejectRefId, 10);
        buf.write_u16(businessRejectReason);
        codec::write_fixed_string(buf, businessRejectText, 50);
    }
    

    void decode(ByteBuf& buf) override {
        applId = codec::read_fixed_string(buf, 3);
        transactTime = buf.read_i64();
        submittingPbuid = codec::read_fixed_string(buf, 6);
        securityId = codec::read_fixed_string(buf, 8);
        securityIdsource = codec::read_fixed_string(buf, 4);
        refSeqNum = buf.read_i64();
        refMsgType = buf.read_u32();
        businessRejectRefId = codec::read_fixed_string(buf, 10);
        businessRejectReason = buf.read_u16();
        businessRejectText = codec::read_fixed_string(buf, 50);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const BusinessReject*>(&other);
        if(!checkType) return false;
        return applId == checkType->applId
               && transactTime == checkType->transactTime
               && submittingPbuid == checkType->submittingPbuid
               && securityId == checkType->securityId
               && securityIdsource == checkType->securityIdsource
               && refSeqNum == checkType->refSeqNum
               && refMsgType == checkType->refMsgType
               && businessRejectRefId == checkType->businessRejectRefId
               && businessRejectReason == checkType->businessRejectReason
               && businessRejectText == checkType->businessRejectText;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "BusinessReject { "
        << "ApplID: " << applId
        << ", "
        << "TransactTime: " << std::to_string(transactTime)
        << ", "
        << "SubmittingPBUID: " << submittingPbuid
        << ", "
        << "SecurityID: " << securityId
        << ", "
        << "SecurityIDSource: " << securityIdsource
        << ", "
        << "RefSeqNum: " << std::to_string(refSeqNum)
        << ", "
        << "RefMsgType: " << std::to_string(refMsgType)
        << ", "
        << "BusinessRejectRefID: " << businessRejectRefId
        << ", "
        << "BusinessRejectReason: " << std::to_string(businessRejectReason)
        << ", "
        << "BusinessRejectText: " << businessRejectText
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const BusinessReject& pkt) {
    return os << pkt.toString();
}


struct PartitionReport : public codec::BinaryCodec {
    int32_t partitionNo;
    int64_t reportIndex;

    void encode(ByteBuf& buf) const override {
        buf.write_i32(partitionNo);
        buf.write_i64(reportIndex);
    }
    

    void decode(ByteBuf& buf) override {
        partitionNo = buf.read_i32();
        reportIndex = buf.read_i64();
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const PartitionReport*>(&other);
        if(!checkType) return false;
        return partitionNo == checkType->partitionNo
               && reportIndex == checkType->reportIndex;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "PartitionReport { "
        << "PartitionNo: " << std::to_string(partitionNo)
        << ", "
        << "ReportIndex: " << std::to_string(reportIndex)
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const PartitionReport& pkt) {
    return os << pkt.toString();
}


struct ReportSynchronization : public codec::BinaryCodec {
    std::vector<PartitionReport> partitionReport;

    void encode(ByteBuf& buf) const override {
        codec::write_object_List<uint32_t>(buf,partitionReport);
    }
    

    void decode(ByteBuf& buf) override {
        partitionReport = codec::read_object_List<uint32_t,PartitionReport>(buf);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const ReportSynchronization*>(&other);
        if(!checkType) return false;
        return partitionReport == checkType->partitionReport;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "ReportSynchronization { "
        << "PartitionReport: " << codec::join_vector<PartitionReport>(partitionReport)
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const ReportSynchronization& pkt) {
    return os << pkt.toString();
}



struct PlatformStateInfo : public codec::BinaryCodec {
    uint16_t platformId;
    uint16_t platformState;

    void encode(ByteBuf& buf) const override {
        buf.write_u16(platformId);
        buf.write_u16(platformState);
    }
    

    void decode(ByteBuf& buf) override {
        platformId = buf.read_u16();
        platformState = buf.read_u16();
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const PlatformStateInfo*>(&other);
        if(!checkType) return false;
        return platformId == checkType->platformId
               && platformState == checkType->platformState;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "PlatformStateInfo { "
        << "PlatformID: " << std::to_string(platformId)
        << ", "
        << "PlatformState: " << std::to_string(platformState)
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const PlatformStateInfo& pkt) {
    return os << pkt.toString();
}


struct ReportFinished : public codec::BinaryCodec {
    int32_t partitionNo;
    int64_t reportIndex;
    uint16_t platformId;

    void encode(ByteBuf& buf) const override {
        buf.write_i32(partitionNo);
        buf.write_i64(reportIndex);
        buf.write_u16(platformId);
    }
    

    void decode(ByteBuf& buf) override {
        partitionNo = buf.read_i32();
        reportIndex = buf.read_i64();
        platformId = buf.read_u16();
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const ReportFinished*>(&other);
        if(!checkType) return false;
        return partitionNo == checkType->partitionNo
               && reportIndex == checkType->reportIndex
               && platformId == checkType->platformId;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "ReportFinished { "
        << "PartitionNo: " << std::to_string(partitionNo)
        << ", "
        << "ReportIndex: " << std::to_string(reportIndex)
        << ", "
        << "PlatformID: " << std::to_string(platformId)
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const ReportFinished& pkt) {
    return os << pkt.toString();
}


struct PlatformPartition : public codec::BinaryCodec {
    int32_t partitionNo;

    void encode(ByteBuf& buf) const override {
        buf.write_i32(partitionNo);
    }
    

    void decode(ByteBuf& buf) override {
        partitionNo = buf.read_i32();
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const PlatformPartition*>(&other);
        if(!checkType) return false;
        return partitionNo == checkType->partitionNo;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "PlatformPartition { "
        << "PartitionNo: " << std::to_string(partitionNo)
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const PlatformPartition& pkt) {
    return os << pkt.toString();
}


struct PlatformInfo : public codec::BinaryCodec {
    uint16_t platformId;
    std::vector<PlatformPartition> platformPartition;

    void encode(ByteBuf& buf) const override {
        buf.write_u16(platformId);
        codec::write_object_List<uint32_t>(buf,platformPartition);
    }
    

    void decode(ByteBuf& buf) override {
        platformId = buf.read_u16();
        platformPartition = codec::read_object_List<uint32_t,PlatformPartition>(buf);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const PlatformInfo*>(&other);
        if(!checkType) return false;
        return platformId == checkType->platformId
               && platformPartition == checkType->platformPartition;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "PlatformInfo { "
        << "PlatformID: " << std::to_string(platformId)
        << ", "
        << "PlatformPartition: " << codec::join_vector<PlatformPartition>(platformPartition)
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const PlatformInfo& pkt) {
    return os << pkt.toString();
}



struct TradingSessionStatus : public codec::BinaryCodec {
    std::string marketId;
    std::string marketSegmentId;
    std::string tradingSessionId;
    std::string tradingSessionSubId;
    uint16_t tradSesStatus;
    int64_t tradSesStartTime;
    int64_t tradSesEndTime;

    void encode(ByteBuf& buf) const override {
        codec::write_fixed_string(buf, marketId, 8);
        codec::write_fixed_string(buf, marketSegmentId, 8);
        codec::write_fixed_string(buf, tradingSessionId, 4);
        codec::write_fixed_string(buf, tradingSessionSubId, 4);
        buf.write_u16(tradSesStatus);
        buf.write_i64(tradSesStartTime);
        buf.write_i64(tradSesEndTime);
    }
    

    void decode(ByteBuf& buf) override {
        marketId = codec::read_fixed_string(buf, 8);
        marketSegmentId = codec::read_fixed_string(buf, 8);
        tradingSessionId = codec::read_fixed_string(buf, 4);
        tradingSessionSubId = codec::read_fixed_string(buf, 4);
        tradSesStatus = buf.read_u16();
        tradSesStartTime = buf.read_i64();
        tradSesEndTime = buf.read_i64();
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const TradingSessionStatus*>(&other);
        if(!checkType) return false;
        return marketId == checkType->marketId
               && marketSegmentId == checkType->marketSegmentId
               && tradingSessionId == checkType->tradingSessionId
               && tradingSessionSubId == checkType->tradingSessionSubId
               && tradSesStatus == checkType->tradSesStatus
               && tradSesStartTime == checkType->tradSesStartTime
               && tradSesEndTime == checkType->tradSesEndTime;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "TradingSessionStatus { "
        << "MarketID: " << marketId
        << ", "
        << "MarketSegmentID: " << marketSegmentId
        << ", "
        << "TradingSessionID: " << tradingSessionId
        << ", "
        << "TradingSessionSubID: " << tradingSessionSubId
        << ", "
        << "TradSesStatus: " << std::to_string(tradSesStatus)
        << ", "
        << "TradSesStartTime: " << std::to_string(tradSesStartTime)
        << ", "
        << "TradSesEndTime: " << std::to_string(tradSesEndTime)
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const TradingSessionStatus& pkt) {
    return os << pkt.toString();
}


struct SzseBinaryTag{};
using SzseBinaryMessageFactory = MessageFactory<uint32_t, codec::BinaryCodec, SzseBinaryTag>;
REGISTER_MESSAGE(SzseBinaryMessageFactory, 1, Logon);
REGISTER_MESSAGE(SzseBinaryMessageFactory, 2, Logout);
REGISTER_MESSAGE(SzseBinaryMessageFactory, 3, Heartbeat);
REGISTER_MESSAGE(SzseBinaryMessageFactory, 4, BusinessReject);
REGISTER_MESSAGE(SzseBinaryMessageFactory, 5, ReportSynchronization);
REGISTER_MESSAGE(SzseBinaryMessageFactory, 6, PlatformStateInfo);
REGISTER_MESSAGE(SzseBinaryMessageFactory, 7, ReportFinished);
REGISTER_MESSAGE(SzseBinaryMessageFactory, 9, PlatformPartition);
REGISTER_MESSAGE(SzseBinaryMessageFactory, 10, TradingSessionStatus);
REGISTER_MESSAGE(SzseBinaryMessageFactory, 100101, NewOrder);
REGISTER_MESSAGE(SzseBinaryMessageFactory, 100201, NewOrder);
REGISTER_MESSAGE(SzseBinaryMessageFactory, 100301, NewOrder);
REGISTER_MESSAGE(SzseBinaryMessageFactory, 100401, NewOrder);
REGISTER_MESSAGE(SzseBinaryMessageFactory, 100501, NewOrder);
REGISTER_MESSAGE(SzseBinaryMessageFactory, 100601, NewOrder);
REGISTER_MESSAGE(SzseBinaryMessageFactory, 100701, NewOrder);
REGISTER_MESSAGE(SzseBinaryMessageFactory, 101201, NewOrder);
REGISTER_MESSAGE(SzseBinaryMessageFactory, 101301, NewOrder);
REGISTER_MESSAGE(SzseBinaryMessageFactory, 101401, NewOrder);
REGISTER_MESSAGE(SzseBinaryMessageFactory, 101501, NewOrder);
REGISTER_MESSAGE(SzseBinaryMessageFactory, 101601, NewOrder);
REGISTER_MESSAGE(SzseBinaryMessageFactory, 101701, NewOrder);
REGISTER_MESSAGE(SzseBinaryMessageFactory, 101801, NewOrder);
REGISTER_MESSAGE(SzseBinaryMessageFactory, 101901, NewOrder);
REGISTER_MESSAGE(SzseBinaryMessageFactory, 102301, NewOrder);
REGISTER_MESSAGE(SzseBinaryMessageFactory, 102701, NewOrder);
REGISTER_MESSAGE(SzseBinaryMessageFactory, 102801, NewOrder);
REGISTER_MESSAGE(SzseBinaryMessageFactory, 102901, NewOrder);
REGISTER_MESSAGE(SzseBinaryMessageFactory, 103101, NewOrder);
REGISTER_MESSAGE(SzseBinaryMessageFactory, 106301, NewOrder);
REGISTER_MESSAGE(SzseBinaryMessageFactory, 103301, NewOrder);
REGISTER_MESSAGE(SzseBinaryMessageFactory, 103501, NewOrder);
REGISTER_MESSAGE(SzseBinaryMessageFactory, 103701, NewOrder);
REGISTER_MESSAGE(SzseBinaryMessageFactory, 104101, NewOrder);
REGISTER_MESSAGE(SzseBinaryMessageFactory, 104128, NewOrder);
REGISTER_MESSAGE(SzseBinaryMessageFactory, 104701, NewOrder);
REGISTER_MESSAGE(SzseBinaryMessageFactory, 200102, ExecutionConfirm);
REGISTER_MESSAGE(SzseBinaryMessageFactory, 200202, ExecutionConfirm);
REGISTER_MESSAGE(SzseBinaryMessageFactory, 200302, ExecutionConfirm);
REGISTER_MESSAGE(SzseBinaryMessageFactory, 200402, ExecutionConfirm);
REGISTER_MESSAGE(SzseBinaryMessageFactory, 200502, ExecutionConfirm);
REGISTER_MESSAGE(SzseBinaryMessageFactory, 200602, ExecutionConfirm);
REGISTER_MESSAGE(SzseBinaryMessageFactory, 200702, ExecutionConfirm);
REGISTER_MESSAGE(SzseBinaryMessageFactory, 201202, ExecutionConfirm);
REGISTER_MESSAGE(SzseBinaryMessageFactory, 201302, ExecutionConfirm);
REGISTER_MESSAGE(SzseBinaryMessageFactory, 201402, ExecutionConfirm);
REGISTER_MESSAGE(SzseBinaryMessageFactory, 201502, ExecutionConfirm);
REGISTER_MESSAGE(SzseBinaryMessageFactory, 201602, ExecutionConfirm);
REGISTER_MESSAGE(SzseBinaryMessageFactory, 201702, ExecutionConfirm);
REGISTER_MESSAGE(SzseBinaryMessageFactory, 201802, ExecutionConfirm);
REGISTER_MESSAGE(SzseBinaryMessageFactory, 201902, ExecutionConfirm);
REGISTER_MESSAGE(SzseBinaryMessageFactory, 202202, ExecutionConfirm);
REGISTER_MESSAGE(SzseBinaryMessageFactory, 202302, ExecutionConfirm);
REGISTER_MESSAGE(SzseBinaryMessageFactory, 202702, ExecutionConfirm);
REGISTER_MESSAGE(SzseBinaryMessageFactory, 202802, ExecutionConfirm);
REGISTER_MESSAGE(SzseBinaryMessageFactory, 202902, ExecutionConfirm);
REGISTER_MESSAGE(SzseBinaryMessageFactory, 203102, ExecutionConfirm);
REGISTER_MESSAGE(SzseBinaryMessageFactory, 206302, ExecutionConfirm);
REGISTER_MESSAGE(SzseBinaryMessageFactory, 203302, ExecutionConfirm);
REGISTER_MESSAGE(SzseBinaryMessageFactory, 203502, ExecutionConfirm);
REGISTER_MESSAGE(SzseBinaryMessageFactory, 203702, ExecutionConfirm);
REGISTER_MESSAGE(SzseBinaryMessageFactory, 204102, ExecutionConfirm);
REGISTER_MESSAGE(SzseBinaryMessageFactory, 204129, ExecutionConfirm);
REGISTER_MESSAGE(SzseBinaryMessageFactory, 204702, ExecutionConfirm);
REGISTER_MESSAGE(SzseBinaryMessageFactory, 200115, ExecutionReport);
REGISTER_MESSAGE(SzseBinaryMessageFactory, 200215, ExecutionReport);
REGISTER_MESSAGE(SzseBinaryMessageFactory, 200315, ExecutionReport);
REGISTER_MESSAGE(SzseBinaryMessageFactory, 200415, ExecutionReport);
REGISTER_MESSAGE(SzseBinaryMessageFactory, 200515, ExecutionReport);
REGISTER_MESSAGE(SzseBinaryMessageFactory, 200615, ExecutionReport);
REGISTER_MESSAGE(SzseBinaryMessageFactory, 200715, ExecutionReport);
REGISTER_MESSAGE(SzseBinaryMessageFactory, 206315, ExecutionReport);
REGISTER_MESSAGE(SzseBinaryMessageFactory, 203715, ExecutionReport);
REGISTER_MESSAGE(SzseBinaryMessageFactory, 204115, ExecutionReport);
REGISTER_MESSAGE(SzseBinaryMessageFactory, 204130, ExecutionReport);
REGISTER_MESSAGE(SzseBinaryMessageFactory, 190007, OrderCancelRequest);
REGISTER_MESSAGE(SzseBinaryMessageFactory, 290008, CancelReject);


struct SzseBinary : public codec::BinaryCodec {
    uint32_t msgType;
    uint32_t bodyLength;
    std::unique_ptr<codec::BinaryCodec> body;
    int32_t checksum;

    void encode(ByteBuf& buf) const override {
        buf.write_u32(msgType);
        auto bodyLengthPos = buf.writer_index();
        buf.write_u32(0);
        auto bodyStart = buf.writer_index();
        body->encode(buf);
        auto bodyEnd = buf.writer_index();
        auto bodyLen_ = static_cast<unsigned int>(bodyEnd - bodyStart);
        buf.write_u32_at(bodyLengthPos, bodyLen_);
        auto service = ChecksumServiceContext::instance().get<ByteBuf, int32_t>("SZSE_BIN");
        if(service != nullptr){
            auto cs = service->calc(buf);
            buf.write_i32(cs);
        } else {
            buf.write_i32(checksum);
        }
    }
    

    void decode(ByteBuf& buf) override {
        msgType = buf.read_u32();
        bodyLength = buf.read_u32();
        body = SzseBinaryMessageFactory::getInstance().create(msgType);
        body->decode(buf);
        checksum = buf.read_i32();
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const SzseBinary*>(&other);
        if(!checkType) return false;
        return msgType == checkType->msgType
               && bodyLength == checkType->bodyLength
               && body->equals(*checkType->body)
               && checksum == checkType->checksum;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "SzseBinary { "
        << "MsgType: " << std::to_string(msgType)
        << ", "
        << "BodyLength: " << std::to_string(bodyLength)
        << ", "
        << "Body: " << body->toString()
        << ", "
        << "Checksum: " << std::to_string(checksum)
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const SzseBinary& pkt) {
    return os << pkt.toString();
}


