// Copyright 2025 xinchentechnote
// Code generated by fin-protoc. DO NOT EDIT.
#pragma once
#include <cstdint>
#include <functional>
#include <iomanip>
#include <memory>
#include <string>
#include <unordered_map>
#include <vector>
#include <iostream>
#include "include/codec.hpp"
#include "include/bytebuf.hpp"
#include "include/checksum.hpp"
#include "message_factory.hpp"

struct Logon : public codec::BinaryCodec {
    std::string senderCompId;
    std::string targetCompId;
    int32_t heartBtInt;
    std::string password;
    std::string defaultApplVerId;

    void encode(ByteBuf& buf) const override {
        codec::write_fixed_string(buf, senderCompId, 20);
        codec::write_fixed_string(buf, targetCompId, 20);
        buf.write_i32_le(heartBtInt);
        codec::write_fixed_string(buf, password, 16);
        codec::write_fixed_string(buf, defaultApplVerId, 32);
    }
    

    void decode(ByteBuf& buf) override {
        senderCompId = codec::read_fixed_string(buf, 20);
        targetCompId = codec::read_fixed_string(buf, 20);
        heartBtInt = buf.read_i32_le();
        password = codec::read_fixed_string(buf, 16);
        defaultApplVerId = codec::read_fixed_string(buf, 32);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const Logon*>(&other);
        if(!checkType) return false;
        return senderCompId == checkType->senderCompId
               && targetCompId == checkType->targetCompId
               && heartBtInt == checkType->heartBtInt
               && password == checkType->password
               && defaultApplVerId == checkType->defaultApplVerId;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "Logon { "
        << "SenderCompID: " << senderCompId
        << ", "
        << "TargetCompID: " << targetCompId
        << ", "
        << "HeartBtInt: " << std::to_string(heartBtInt)
        << ", "
        << "Password: " << password
        << ", "
        << "DefaultApplVerID: " << defaultApplVerId
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const Logon& pkt) {
    return os << pkt.toString();
}


struct Logout : public codec::BinaryCodec {
    int32_t sessionStatus;
    std::string text;

    void encode(ByteBuf& buf) const override {
        buf.write_i32_le(sessionStatus);
        codec::write_fixed_string(buf, text, 200);
    }
    

    void decode(ByteBuf& buf) override {
        sessionStatus = buf.read_i32_le();
        text = codec::read_fixed_string(buf, 200);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const Logout*>(&other);
        if(!checkType) return false;
        return sessionStatus == checkType->sessionStatus
               && text == checkType->text;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "Logout { "
        << "SessionStatus: " << std::to_string(sessionStatus)
        << ", "
        << "Text: " << text
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const Logout& pkt) {
    return os << pkt.toString();
}


struct Heartbeat : public codec::BinaryCodec {

    void encode(ByteBuf& buf) const override {
    }
    

    void decode(ByteBuf& buf) override {
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const Heartbeat*>(&other);
        if(!checkType) return false;
        return true;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "Heartbeat { "
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const Heartbeat& pkt) {
    return os << pkt.toString();
}


struct ExtendNewOrder010 : public codec::BinaryCodec {
    int64_t stopPx;
    int64_t minQty;
    uint16_t maxPriceLevels;
    std::string timeInForce;
    std::string cashMargin;
    std::string settlType;
    std::string settlPeriod;

    void encode(ByteBuf& buf) const override {
        buf.write_i64_le(stopPx);
        buf.write_i64_le(minQty);
        buf.write_u16_le(maxPriceLevels);
        codec::write_fixed_string(buf, timeInForce, 1);
        codec::write_fixed_string(buf, cashMargin, 1);
        codec::write_fixed_string(buf, settlType, 1);
        codec::write_fixed_string(buf, settlPeriod, 1);
    }
    

    void decode(ByteBuf& buf) override {
        stopPx = buf.read_i64_le();
        minQty = buf.read_i64_le();
        maxPriceLevels = buf.read_u16_le();
        timeInForce = codec::read_fixed_string(buf, 1);
        cashMargin = codec::read_fixed_string(buf, 1);
        settlType = codec::read_fixed_string(buf, 1);
        settlPeriod = codec::read_fixed_string(buf, 1);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const ExtendNewOrder010*>(&other);
        if(!checkType) return false;
        return stopPx == checkType->stopPx
               && minQty == checkType->minQty
               && maxPriceLevels == checkType->maxPriceLevels
               && timeInForce == checkType->timeInForce
               && cashMargin == checkType->cashMargin
               && settlType == checkType->settlType
               && settlPeriod == checkType->settlPeriod;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "ExtendNewOrder010 { "
        << "StopPx: " << std::to_string(stopPx)
        << ", "
        << "MinQty: " << std::to_string(minQty)
        << ", "
        << "MaxPriceLevels: " << std::to_string(maxPriceLevels)
        << ", "
        << "TimeInForce: " << timeInForce
        << ", "
        << "CashMargin: " << cashMargin
        << ", "
        << "SettlType: " << settlType
        << ", "
        << "SettlPeriod: " << settlPeriod
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const ExtendNewOrder010& pkt) {
    return os << pkt.toString();
}


struct ExtendNewOrder040 : public codec::BinaryCodec {
    int64_t stopPx;
    int64_t minQty;
    uint16_t maxPriceLevels;
    std::string timeInForce;
    std::string cashMargin;

    void encode(ByteBuf& buf) const override {
        buf.write_i64_le(stopPx);
        buf.write_i64_le(minQty);
        buf.write_u16_le(maxPriceLevels);
        codec::write_fixed_string(buf, timeInForce, 1);
        codec::write_fixed_string(buf, cashMargin, 1);
    }
    

    void decode(ByteBuf& buf) override {
        stopPx = buf.read_i64_le();
        minQty = buf.read_i64_le();
        maxPriceLevels = buf.read_u16_le();
        timeInForce = codec::read_fixed_string(buf, 1);
        cashMargin = codec::read_fixed_string(buf, 1);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const ExtendNewOrder040*>(&other);
        if(!checkType) return false;
        return stopPx == checkType->stopPx
               && minQty == checkType->minQty
               && maxPriceLevels == checkType->maxPriceLevels
               && timeInForce == checkType->timeInForce
               && cashMargin == checkType->cashMargin;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "ExtendNewOrder040 { "
        << "StopPx: " << std::to_string(stopPx)
        << ", "
        << "MinQty: " << std::to_string(minQty)
        << ", "
        << "MaxPriceLevels: " << std::to_string(maxPriceLevels)
        << ", "
        << "TimeInForce: " << timeInForce
        << ", "
        << "CashMargin: " << cashMargin
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const ExtendNewOrder040& pkt) {
    return os << pkt.toString();
}


struct ExtendNewOrder041 : public codec::BinaryCodec {

    void encode(ByteBuf& buf) const override {
    }
    

    void decode(ByteBuf& buf) override {
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const ExtendNewOrder041*>(&other);
        if(!checkType) return false;
        return true;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "ExtendNewOrder041 { "
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const ExtendNewOrder041& pkt) {
    return os << pkt.toString();
}


struct ExtendNewOrder042 : public codec::BinaryCodec {

    void encode(ByteBuf& buf) const override {
    }
    

    void decode(ByteBuf& buf) override {
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const ExtendNewOrder042*>(&other);
        if(!checkType) return false;
        return true;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "ExtendNewOrder042 { "
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const ExtendNewOrder042& pkt) {
    return os << pkt.toString();
}


struct ExtendNewOrder043 : public codec::BinaryCodec {

    void encode(ByteBuf& buf) const override {
    }
    

    void decode(ByteBuf& buf) override {
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const ExtendNewOrder043*>(&other);
        if(!checkType) return false;
        return true;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "ExtendNewOrder043 { "
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const ExtendNewOrder043& pkt) {
    return os << pkt.toString();
}


struct ExtendNewOrder044 : public codec::BinaryCodec {

    void encode(ByteBuf& buf) const override {
    }
    

    void decode(ByteBuf& buf) override {
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const ExtendNewOrder044*>(&other);
        if(!checkType) return false;
        return true;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "ExtendNewOrder044 { "
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const ExtendNewOrder044& pkt) {
    return os << pkt.toString();
}


struct ExtendNewOrder045 : public codec::BinaryCodec {

    void encode(ByteBuf& buf) const override {
    }
    

    void decode(ByteBuf& buf) override {
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const ExtendNewOrder045*>(&other);
        if(!checkType) return false;
        return true;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "ExtendNewOrder045 { "
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const ExtendNewOrder045& pkt) {
    return os << pkt.toString();
}


struct ExtendNewOrder050 : public codec::BinaryCodec {
    uint16_t expirationDays;
    uint8_t expirationType;
    std::string shareProperty;

    void encode(ByteBuf& buf) const override {
        buf.write_u16_le(expirationDays);
        buf.write_u8(expirationType);
        codec::write_fixed_string(buf, shareProperty, 2);
    }
    

    void decode(ByteBuf& buf) override {
        expirationDays = buf.read_u16_le();
        expirationType = buf.read_u8();
        shareProperty = codec::read_fixed_string(buf, 2);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const ExtendNewOrder050*>(&other);
        if(!checkType) return false;
        return expirationDays == checkType->expirationDays
               && expirationType == checkType->expirationType
               && shareProperty == checkType->shareProperty;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "ExtendNewOrder050 { "
        << "ExpirationDays: " << std::to_string(expirationDays)
        << ", "
        << "ExpirationType: " << static_cast<unsigned>(expirationType)
        << ", "
        << "ShareProperty: " << shareProperty
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const ExtendNewOrder050& pkt) {
    return os << pkt.toString();
}


struct NewOrderTag{};
using NewOrderMessageFactory = MessageFactory<std::string, codec::BinaryCodec, NewOrderTag>;
REGISTER_MESSAGE(NewOrderMessageFactory, "010", ExtendNewOrder010);
REGISTER_MESSAGE(NewOrderMessageFactory, "040", ExtendNewOrder040);
REGISTER_MESSAGE(NewOrderMessageFactory, "041", ExtendNewOrder041);
REGISTER_MESSAGE(NewOrderMessageFactory, "042", ExtendNewOrder042);
REGISTER_MESSAGE(NewOrderMessageFactory, "043", ExtendNewOrder043);
REGISTER_MESSAGE(NewOrderMessageFactory, "044", ExtendNewOrder044);
REGISTER_MESSAGE(NewOrderMessageFactory, "045", ExtendNewOrder045);
REGISTER_MESSAGE(NewOrderMessageFactory, "050", ExtendNewOrder050);


struct NewOrder : public codec::BinaryCodec {
    std::string applId;
    std::string submittingPbuid;
    std::string securityId;
    std::string securityIdsource;
    uint16_t ownerType;
    std::string clearingFirm;
    int64_t transactTime;
    std::string userInfo;
    std::string clOrdId;
    std::string accountId;
    std::string branchId;
    std::string orderRestrictions;
    std::string side;
    std::string ordType;
    int64_t orderQty;
    int64_t price;
    std::unique_ptr<codec::BinaryCodec> applExtend;

    void encode(ByteBuf& buf) const override {
        codec::write_fixed_string(buf, applId, 3);
        codec::write_fixed_string(buf, submittingPbuid, 6);
        codec::write_fixed_string(buf, securityId, 8);
        codec::write_fixed_string(buf, securityIdsource, 4);
        buf.write_u16_le(ownerType);
        codec::write_fixed_string(buf, clearingFirm, 2);
        buf.write_i64_le(transactTime);
        codec::write_fixed_string(buf, userInfo, 32);
        codec::write_fixed_string(buf, clOrdId, 10);
        codec::write_fixed_string(buf, accountId, 10);
        codec::write_fixed_string(buf, branchId, 2);
        codec::write_fixed_string(buf, orderRestrictions, 4);
        codec::write_fixed_string(buf, side, 1);
        codec::write_fixed_string(buf, ordType, 1);
        buf.write_i64_le(orderQty);
        buf.write_i64_le(price);
        applExtend->encode(buf);
    }
    

    void decode(ByteBuf& buf) override {
        applId = codec::read_fixed_string(buf, 3);
        submittingPbuid = codec::read_fixed_string(buf, 6);
        securityId = codec::read_fixed_string(buf, 8);
        securityIdsource = codec::read_fixed_string(buf, 4);
        ownerType = buf.read_u16_le();
        clearingFirm = codec::read_fixed_string(buf, 2);
        transactTime = buf.read_i64_le();
        userInfo = codec::read_fixed_string(buf, 32);
        clOrdId = codec::read_fixed_string(buf, 10);
        accountId = codec::read_fixed_string(buf, 10);
        branchId = codec::read_fixed_string(buf, 2);
        orderRestrictions = codec::read_fixed_string(buf, 4);
        side = codec::read_fixed_string(buf, 1);
        ordType = codec::read_fixed_string(buf, 1);
        orderQty = buf.read_i64_le();
        price = buf.read_i64_le();
        applExtend = NewOrderMessageFactory::getInstance().create(applId);
        applExtend->decode(buf);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const NewOrder*>(&other);
        if(!checkType) return false;
        return applId == checkType->applId
               && submittingPbuid == checkType->submittingPbuid
               && securityId == checkType->securityId
               && securityIdsource == checkType->securityIdsource
               && ownerType == checkType->ownerType
               && clearingFirm == checkType->clearingFirm
               && transactTime == checkType->transactTime
               && userInfo == checkType->userInfo
               && clOrdId == checkType->clOrdId
               && accountId == checkType->accountId
               && branchId == checkType->branchId
               && orderRestrictions == checkType->orderRestrictions
               && side == checkType->side
               && ordType == checkType->ordType
               && orderQty == checkType->orderQty
               && price == checkType->price
               && applExtend->equals(*checkType->applExtend);
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "NewOrder { "
        << "ApplID: " << applId
        << ", "
        << "SubmittingPBUID: " << submittingPbuid
        << ", "
        << "SecurityID: " << securityId
        << ", "
        << "SecurityIDSource: " << securityIdsource
        << ", "
        << "OwnerType: " << std::to_string(ownerType)
        << ", "
        << "ClearingFirm: " << clearingFirm
        << ", "
        << "TransactTime: " << std::to_string(transactTime)
        << ", "
        << "UserInfo: " << userInfo
        << ", "
        << "ClOrdID: " << clOrdId
        << ", "
        << "AccountID: " << accountId
        << ", "
        << "BranchID: " << branchId
        << ", "
        << "OrderRestrictions: " << orderRestrictions
        << ", "
        << "Side: " << side
        << ", "
        << "OrdType: " << ordType
        << ", "
        << "OrderQty: " << std::to_string(orderQty)
        << ", "
        << "Price: " << std::to_string(price)
        << ", "
        << "ApplExtend: " << applExtend->toString()
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const NewOrder& pkt) {
    return os << pkt.toString();
}










struct OrderCancelRequest : public codec::BinaryCodec {
    std::string applId;
    std::string submittingPbuid;
    std::string securityId;
    std::string securityIdsource;
    uint16_t ownerType;
    std::string clearingFirm;
    int64_t transactTime;
    std::string userInfo;
    std::string clOrdId;
    std::string origClOrdId;
    std::string accountId;
    std::string branchId;
    std::string orderId;
    int64_t orderQty;

    void encode(ByteBuf& buf) const override {
        codec::write_fixed_string(buf, applId, 3);
        codec::write_fixed_string(buf, submittingPbuid, 6);
        codec::write_fixed_string(buf, securityId, 8);
        codec::write_fixed_string(buf, securityIdsource, 4);
        buf.write_u16_le(ownerType);
        codec::write_fixed_string(buf, clearingFirm, 2);
        buf.write_i64_le(transactTime);
        codec::write_fixed_string(buf, userInfo, 32);
        codec::write_fixed_string(buf, clOrdId, 10);
        codec::write_fixed_string(buf, origClOrdId, 10);
        codec::write_fixed_string(buf, accountId, 10);
        codec::write_fixed_string(buf, branchId, 2);
        codec::write_fixed_string(buf, orderId, 16);
        buf.write_i64_le(orderQty);
    }
    

    void decode(ByteBuf& buf) override {
        applId = codec::read_fixed_string(buf, 3);
        submittingPbuid = codec::read_fixed_string(buf, 6);
        securityId = codec::read_fixed_string(buf, 8);
        securityIdsource = codec::read_fixed_string(buf, 4);
        ownerType = buf.read_u16_le();
        clearingFirm = codec::read_fixed_string(buf, 2);
        transactTime = buf.read_i64_le();
        userInfo = codec::read_fixed_string(buf, 32);
        clOrdId = codec::read_fixed_string(buf, 10);
        origClOrdId = codec::read_fixed_string(buf, 10);
        accountId = codec::read_fixed_string(buf, 10);
        branchId = codec::read_fixed_string(buf, 2);
        orderId = codec::read_fixed_string(buf, 16);
        orderQty = buf.read_i64_le();
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const OrderCancelRequest*>(&other);
        if(!checkType) return false;
        return applId == checkType->applId
               && submittingPbuid == checkType->submittingPbuid
               && securityId == checkType->securityId
               && securityIdsource == checkType->securityIdsource
               && ownerType == checkType->ownerType
               && clearingFirm == checkType->clearingFirm
               && transactTime == checkType->transactTime
               && userInfo == checkType->userInfo
               && clOrdId == checkType->clOrdId
               && origClOrdId == checkType->origClOrdId
               && accountId == checkType->accountId
               && branchId == checkType->branchId
               && orderId == checkType->orderId
               && orderQty == checkType->orderQty;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "OrderCancelRequest { "
        << "ApplID: " << applId
        << ", "
        << "SubmittingPBUID: " << submittingPbuid
        << ", "
        << "SecurityID: " << securityId
        << ", "
        << "SecurityIDSource: " << securityIdsource
        << ", "
        << "OwnerType: " << std::to_string(ownerType)
        << ", "
        << "ClearingFirm: " << clearingFirm
        << ", "
        << "TransactTime: " << std::to_string(transactTime)
        << ", "
        << "UserInfo: " << userInfo
        << ", "
        << "ClOrdID: " << clOrdId
        << ", "
        << "OrigClOrdID: " << origClOrdId
        << ", "
        << "AccountID: " << accountId
        << ", "
        << "BranchID: " << branchId
        << ", "
        << "OrderID: " << orderId
        << ", "
        << "OrderQty: " << std::to_string(orderQty)
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const OrderCancelRequest& pkt) {
    return os << pkt.toString();
}


struct CancelReject : public codec::BinaryCodec {
    int32_t partitionNo;
    int64_t reportIndex;
    std::string applId;
    std::string reportingPbuid;
    std::string submittingPbuid;
    std::string securityId;
    std::string securityIdsource;
    uint16_t ownerType;
    std::string clearingFirm;
    int64_t transactTime;
    std::string userInfo;
    std::string clOrdId;
    std::string origClOrdId;
    std::string accountId;
    std::string branchId;
    std::string ordStatus;
    uint16_t cxlRejReason;
    std::string rejectText;
    std::string orderId;

    void encode(ByteBuf& buf) const override {
        buf.write_i32_le(partitionNo);
        buf.write_i64_le(reportIndex);
        codec::write_fixed_string(buf, applId, 3);
        codec::write_fixed_string(buf, reportingPbuid, 6);
        codec::write_fixed_string(buf, submittingPbuid, 6);
        codec::write_fixed_string(buf, securityId, 8);
        codec::write_fixed_string(buf, securityIdsource, 4);
        buf.write_u16_le(ownerType);
        codec::write_fixed_string(buf, clearingFirm, 2);
        buf.write_i64_le(transactTime);
        codec::write_fixed_string(buf, userInfo, 32);
        codec::write_fixed_string(buf, clOrdId, 10);
        codec::write_fixed_string(buf, origClOrdId, 10);
        codec::write_fixed_string(buf, accountId, 10);
        codec::write_fixed_string(buf, branchId, 2);
        codec::write_fixed_string(buf, ordStatus, 1);
        buf.write_u16_le(cxlRejReason);
        codec::write_fixed_string(buf, rejectText, 16);
        codec::write_fixed_string(buf, orderId, 16);
    }
    

    void decode(ByteBuf& buf) override {
        partitionNo = buf.read_i32_le();
        reportIndex = buf.read_i64_le();
        applId = codec::read_fixed_string(buf, 3);
        reportingPbuid = codec::read_fixed_string(buf, 6);
        submittingPbuid = codec::read_fixed_string(buf, 6);
        securityId = codec::read_fixed_string(buf, 8);
        securityIdsource = codec::read_fixed_string(buf, 4);
        ownerType = buf.read_u16_le();
        clearingFirm = codec::read_fixed_string(buf, 2);
        transactTime = buf.read_i64_le();
        userInfo = codec::read_fixed_string(buf, 32);
        clOrdId = codec::read_fixed_string(buf, 10);
        origClOrdId = codec::read_fixed_string(buf, 10);
        accountId = codec::read_fixed_string(buf, 10);
        branchId = codec::read_fixed_string(buf, 2);
        ordStatus = codec::read_fixed_string(buf, 1);
        cxlRejReason = buf.read_u16_le();
        rejectText = codec::read_fixed_string(buf, 16);
        orderId = codec::read_fixed_string(buf, 16);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const CancelReject*>(&other);
        if(!checkType) return false;
        return partitionNo == checkType->partitionNo
               && reportIndex == checkType->reportIndex
               && applId == checkType->applId
               && reportingPbuid == checkType->reportingPbuid
               && submittingPbuid == checkType->submittingPbuid
               && securityId == checkType->securityId
               && securityIdsource == checkType->securityIdsource
               && ownerType == checkType->ownerType
               && clearingFirm == checkType->clearingFirm
               && transactTime == checkType->transactTime
               && userInfo == checkType->userInfo
               && clOrdId == checkType->clOrdId
               && origClOrdId == checkType->origClOrdId
               && accountId == checkType->accountId
               && branchId == checkType->branchId
               && ordStatus == checkType->ordStatus
               && cxlRejReason == checkType->cxlRejReason
               && rejectText == checkType->rejectText
               && orderId == checkType->orderId;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "CancelReject { "
        << "PartitionNo: " << std::to_string(partitionNo)
        << ", "
        << "ReportIndex: " << std::to_string(reportIndex)
        << ", "
        << "ApplID: " << applId
        << ", "
        << "ReportingPBUID: " << reportingPbuid
        << ", "
        << "SubmittingPBUID: " << submittingPbuid
        << ", "
        << "SecurityID: " << securityId
        << ", "
        << "SecurityIDSource: " << securityIdsource
        << ", "
        << "OwnerType: " << std::to_string(ownerType)
        << ", "
        << "ClearingFirm: " << clearingFirm
        << ", "
        << "TransactTime: " << std::to_string(transactTime)
        << ", "
        << "UserInfo: " << userInfo
        << ", "
        << "ClOrdID: " << clOrdId
        << ", "
        << "OrigClOrdID: " << origClOrdId
        << ", "
        << "AccountID: " << accountId
        << ", "
        << "BranchID: " << branchId
        << ", "
        << "OrdStatus: " << ordStatus
        << ", "
        << "CxlRejReason: " << std::to_string(cxlRejReason)
        << ", "
        << "RejectText: " << rejectText
        << ", "
        << "OrderID: " << orderId
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const CancelReject& pkt) {
    return os << pkt.toString();
}


struct ConfirmExtend010 : public codec::BinaryCodec {
    int64_t stopPx;
    int64_t minQty;
    uint16_t maxPriceLevels;
    std::string timeInForce;
    std::string cashMargin;

    void encode(ByteBuf& buf) const override {
        buf.write_i64_le(stopPx);
        buf.write_i64_le(minQty);
        buf.write_u16_le(maxPriceLevels);
        codec::write_fixed_string(buf, timeInForce, 1);
        codec::write_fixed_string(buf, cashMargin, 1);
    }
    

    void decode(ByteBuf& buf) override {
        stopPx = buf.read_i64_le();
        minQty = buf.read_i64_le();
        maxPriceLevels = buf.read_u16_le();
        timeInForce = codec::read_fixed_string(buf, 1);
        cashMargin = codec::read_fixed_string(buf, 1);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const ConfirmExtend010*>(&other);
        if(!checkType) return false;
        return stopPx == checkType->stopPx
               && minQty == checkType->minQty
               && maxPriceLevels == checkType->maxPriceLevels
               && timeInForce == checkType->timeInForce
               && cashMargin == checkType->cashMargin;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "ConfirmExtend010 { "
        << "StopPx: " << std::to_string(stopPx)
        << ", "
        << "MinQty: " << std::to_string(minQty)
        << ", "
        << "MaxPriceLevels: " << std::to_string(maxPriceLevels)
        << ", "
        << "TimeInForce: " << timeInForce
        << ", "
        << "CashMargin: " << cashMargin
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const ConfirmExtend010& pkt) {
    return os << pkt.toString();
}


struct ConfirmExtend040 : public codec::BinaryCodec {
    int64_t stopPx;
    int64_t minQty;
    uint16_t maxPriceLevels;
    std::string timeInForce;
    std::string cashMargin;

    void encode(ByteBuf& buf) const override {
        buf.write_i64_le(stopPx);
        buf.write_i64_le(minQty);
        buf.write_u16_le(maxPriceLevels);
        codec::write_fixed_string(buf, timeInForce, 1);
        codec::write_fixed_string(buf, cashMargin, 1);
    }
    

    void decode(ByteBuf& buf) override {
        stopPx = buf.read_i64_le();
        minQty = buf.read_i64_le();
        maxPriceLevels = buf.read_u16_le();
        timeInForce = codec::read_fixed_string(buf, 1);
        cashMargin = codec::read_fixed_string(buf, 1);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const ConfirmExtend040*>(&other);
        if(!checkType) return false;
        return stopPx == checkType->stopPx
               && minQty == checkType->minQty
               && maxPriceLevels == checkType->maxPriceLevels
               && timeInForce == checkType->timeInForce
               && cashMargin == checkType->cashMargin;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "ConfirmExtend040 { "
        << "StopPx: " << std::to_string(stopPx)
        << ", "
        << "MinQty: " << std::to_string(minQty)
        << ", "
        << "MaxPriceLevels: " << std::to_string(maxPriceLevels)
        << ", "
        << "TimeInForce: " << timeInForce
        << ", "
        << "CashMargin: " << cashMargin
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const ConfirmExtend040& pkt) {
    return os << pkt.toString();
}


struct ConfirmExtend041 : public codec::BinaryCodec {

    void encode(ByteBuf& buf) const override {
    }
    

    void decode(ByteBuf& buf) override {
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const ConfirmExtend041*>(&other);
        if(!checkType) return false;
        return true;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "ConfirmExtend041 { "
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const ConfirmExtend041& pkt) {
    return os << pkt.toString();
}


struct ConfirmExtend042 : public codec::BinaryCodec {

    void encode(ByteBuf& buf) const override {
    }
    

    void decode(ByteBuf& buf) override {
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const ConfirmExtend042*>(&other);
        if(!checkType) return false;
        return true;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "ConfirmExtend042 { "
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const ConfirmExtend042& pkt) {
    return os << pkt.toString();
}


struct ConfirmExtend043 : public codec::BinaryCodec {

    void encode(ByteBuf& buf) const override {
    }
    

    void decode(ByteBuf& buf) override {
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const ConfirmExtend043*>(&other);
        if(!checkType) return false;
        return true;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "ConfirmExtend043 { "
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const ConfirmExtend043& pkt) {
    return os << pkt.toString();
}


struct ConfirmExtend044 : public codec::BinaryCodec {

    void encode(ByteBuf& buf) const override {
    }
    

    void decode(ByteBuf& buf) override {
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const ConfirmExtend044*>(&other);
        if(!checkType) return false;
        return true;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "ConfirmExtend044 { "
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const ConfirmExtend044& pkt) {
    return os << pkt.toString();
}


struct ConfirmExtend045 : public codec::BinaryCodec {

    void encode(ByteBuf& buf) const override {
    }
    

    void decode(ByteBuf& buf) override {
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const ConfirmExtend045*>(&other);
        if(!checkType) return false;
        return true;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "ConfirmExtend045 { "
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const ConfirmExtend045& pkt) {
    return os << pkt.toString();
}


struct ConfirmExtend050 : public codec::BinaryCodec {
    uint16_t expirationDays;
    uint8_t expirationType;
    std::string shareProperty;

    void encode(ByteBuf& buf) const override {
        buf.write_u16_le(expirationDays);
        buf.write_u8(expirationType);
        codec::write_fixed_string(buf, shareProperty, 2);
    }
    

    void decode(ByteBuf& buf) override {
        expirationDays = buf.read_u16_le();
        expirationType = buf.read_u8();
        shareProperty = codec::read_fixed_string(buf, 2);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const ConfirmExtend050*>(&other);
        if(!checkType) return false;
        return expirationDays == checkType->expirationDays
               && expirationType == checkType->expirationType
               && shareProperty == checkType->shareProperty;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "ConfirmExtend050 { "
        << "ExpirationDays: " << std::to_string(expirationDays)
        << ", "
        << "ExpirationType: " << static_cast<unsigned>(expirationType)
        << ", "
        << "ShareProperty: " << shareProperty
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const ConfirmExtend050& pkt) {
    return os << pkt.toString();
}


struct ExecutionConfirmTag{};
using ExecutionConfirmMessageFactory = MessageFactory<std::string, codec::BinaryCodec, ExecutionConfirmTag>;
REGISTER_MESSAGE(ExecutionConfirmMessageFactory, "010", ConfirmExtend010);
REGISTER_MESSAGE(ExecutionConfirmMessageFactory, "040", ConfirmExtend040);
REGISTER_MESSAGE(ExecutionConfirmMessageFactory, "041", ConfirmExtend041);
REGISTER_MESSAGE(ExecutionConfirmMessageFactory, "042", ConfirmExtend042);
REGISTER_MESSAGE(ExecutionConfirmMessageFactory, "043", ConfirmExtend043);
REGISTER_MESSAGE(ExecutionConfirmMessageFactory, "044", ConfirmExtend044);
REGISTER_MESSAGE(ExecutionConfirmMessageFactory, "045", ConfirmExtend045);
REGISTER_MESSAGE(ExecutionConfirmMessageFactory, "050", ConfirmExtend050);


struct ExecutionConfirm : public codec::BinaryCodec {
    int32_t partitionNo;
    int64_t reportIndex;
    std::string applId;
    std::string reportingPbuid;
    std::string submittingPbuid;
    std::string securityId;
    std::string securityIdsource;
    uint16_t ownerType;
    std::string clearingFirm;
    int64_t transactTime;
    std::string userInfo;
    std::string orderId;
    std::string clOrdId;
    std::string origClOrdId;
    std::string execId;
    std::string execType;
    std::string ordStatus;
    uint16_t ordRejReason;
    int64_t leavesQty;
    int64_t cumQty;
    std::string side;
    std::string ordType;
    int64_t orderQty;
    int64_t price;
    std::string accountId;
    std::string branchId;
    std::string orderRestrictions;
    std::unique_ptr<codec::BinaryCodec> applExtend;

    void encode(ByteBuf& buf) const override {
        buf.write_i32_le(partitionNo);
        buf.write_i64_le(reportIndex);
        codec::write_fixed_string(buf, applId, 3);
        codec::write_fixed_string(buf, reportingPbuid, 6);
        codec::write_fixed_string(buf, submittingPbuid, 6);
        codec::write_fixed_string(buf, securityId, 8);
        codec::write_fixed_string(buf, securityIdsource, 4);
        buf.write_u16_le(ownerType);
        codec::write_fixed_string(buf, clearingFirm, 2);
        buf.write_i64_le(transactTime);
        codec::write_fixed_string(buf, userInfo, 32);
        codec::write_fixed_string(buf, orderId, 16);
        codec::write_fixed_string(buf, clOrdId, 10);
        codec::write_fixed_string(buf, origClOrdId, 10);
        codec::write_fixed_string(buf, execId, 16);
        codec::write_fixed_string(buf, execType, 1);
        codec::write_fixed_string(buf, ordStatus, 1);
        buf.write_u16_le(ordRejReason);
        buf.write_i64_le(leavesQty);
        buf.write_i64_le(cumQty);
        codec::write_fixed_string(buf, side, 1);
        codec::write_fixed_string(buf, ordType, 1);
        buf.write_i64_le(orderQty);
        buf.write_i64_le(price);
        codec::write_fixed_string(buf, accountId, 10);
        codec::write_fixed_string(buf, branchId, 2);
        codec::write_fixed_string(buf, orderRestrictions, 4);
        applExtend->encode(buf);
    }
    

    void decode(ByteBuf& buf) override {
        partitionNo = buf.read_i32_le();
        reportIndex = buf.read_i64_le();
        applId = codec::read_fixed_string(buf, 3);
        reportingPbuid = codec::read_fixed_string(buf, 6);
        submittingPbuid = codec::read_fixed_string(buf, 6);
        securityId = codec::read_fixed_string(buf, 8);
        securityIdsource = codec::read_fixed_string(buf, 4);
        ownerType = buf.read_u16_le();
        clearingFirm = codec::read_fixed_string(buf, 2);
        transactTime = buf.read_i64_le();
        userInfo = codec::read_fixed_string(buf, 32);
        orderId = codec::read_fixed_string(buf, 16);
        clOrdId = codec::read_fixed_string(buf, 10);
        origClOrdId = codec::read_fixed_string(buf, 10);
        execId = codec::read_fixed_string(buf, 16);
        execType = codec::read_fixed_string(buf, 1);
        ordStatus = codec::read_fixed_string(buf, 1);
        ordRejReason = buf.read_u16_le();
        leavesQty = buf.read_i64_le();
        cumQty = buf.read_i64_le();
        side = codec::read_fixed_string(buf, 1);
        ordType = codec::read_fixed_string(buf, 1);
        orderQty = buf.read_i64_le();
        price = buf.read_i64_le();
        accountId = codec::read_fixed_string(buf, 10);
        branchId = codec::read_fixed_string(buf, 2);
        orderRestrictions = codec::read_fixed_string(buf, 4);
        applExtend = ExecutionConfirmMessageFactory::getInstance().create(applId);
        applExtend->decode(buf);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const ExecutionConfirm*>(&other);
        if(!checkType) return false;
        return partitionNo == checkType->partitionNo
               && reportIndex == checkType->reportIndex
               && applId == checkType->applId
               && reportingPbuid == checkType->reportingPbuid
               && submittingPbuid == checkType->submittingPbuid
               && securityId == checkType->securityId
               && securityIdsource == checkType->securityIdsource
               && ownerType == checkType->ownerType
               && clearingFirm == checkType->clearingFirm
               && transactTime == checkType->transactTime
               && userInfo == checkType->userInfo
               && orderId == checkType->orderId
               && clOrdId == checkType->clOrdId
               && origClOrdId == checkType->origClOrdId
               && execId == checkType->execId
               && execType == checkType->execType
               && ordStatus == checkType->ordStatus
               && ordRejReason == checkType->ordRejReason
               && leavesQty == checkType->leavesQty
               && cumQty == checkType->cumQty
               && side == checkType->side
               && ordType == checkType->ordType
               && orderQty == checkType->orderQty
               && price == checkType->price
               && accountId == checkType->accountId
               && branchId == checkType->branchId
               && orderRestrictions == checkType->orderRestrictions
               && applExtend->equals(*checkType->applExtend);
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "ExecutionConfirm { "
        << "PartitionNo: " << std::to_string(partitionNo)
        << ", "
        << "ReportIndex: " << std::to_string(reportIndex)
        << ", "
        << "ApplID: " << applId
        << ", "
        << "ReportingPBUID: " << reportingPbuid
        << ", "
        << "SubmittingPBUID: " << submittingPbuid
        << ", "
        << "SecurityID: " << securityId
        << ", "
        << "SecurityIDSource: " << securityIdsource
        << ", "
        << "OwnerType: " << std::to_string(ownerType)
        << ", "
        << "ClearingFirm: " << clearingFirm
        << ", "
        << "TransactTime: " << std::to_string(transactTime)
        << ", "
        << "UserInfo: " << userInfo
        << ", "
        << "OrderID: " << orderId
        << ", "
        << "ClOrdID: " << clOrdId
        << ", "
        << "OrigClOrdID: " << origClOrdId
        << ", "
        << "ExecID: " << execId
        << ", "
        << "ExecType: " << execType
        << ", "
        << "OrdStatus: " << ordStatus
        << ", "
        << "OrdRejReason: " << std::to_string(ordRejReason)
        << ", "
        << "LeavesQty: " << std::to_string(leavesQty)
        << ", "
        << "CumQty: " << std::to_string(cumQty)
        << ", "
        << "Side: " << side
        << ", "
        << "OrdType: " << ordType
        << ", "
        << "OrderQty: " << std::to_string(orderQty)
        << ", "
        << "Price: " << std::to_string(price)
        << ", "
        << "AccountID: " << accountId
        << ", "
        << "BranchID: " << branchId
        << ", "
        << "OrderRestrictions: " << orderRestrictions
        << ", "
        << "ApplExtend: " << applExtend->toString()
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const ExecutionConfirm& pkt) {
    return os << pkt.toString();
}










struct ReportExtend010 : public codec::BinaryCodec {
    std::string cashMargin;
    std::string settlType;
    std::string settlPeriod;

    void encode(ByteBuf& buf) const override {
        codec::write_fixed_string(buf, cashMargin, 1);
        codec::write_fixed_string(buf, settlType, 1);
        codec::write_fixed_string(buf, settlPeriod, 1);
    }
    

    void decode(ByteBuf& buf) override {
        cashMargin = codec::read_fixed_string(buf, 1);
        settlType = codec::read_fixed_string(buf, 1);
        settlPeriod = codec::read_fixed_string(buf, 1);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const ReportExtend010*>(&other);
        if(!checkType) return false;
        return cashMargin == checkType->cashMargin
               && settlType == checkType->settlType
               && settlPeriod == checkType->settlPeriod;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "ReportExtend010 { "
        << "CashMargin: " << cashMargin
        << ", "
        << "SettlType: " << settlType
        << ", "
        << "SettlPeriod: " << settlPeriod
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const ReportExtend010& pkt) {
    return os << pkt.toString();
}


struct ReportExtend040 : public codec::BinaryCodec {
    std::string cashMargin;

    void encode(ByteBuf& buf) const override {
        codec::write_fixed_string(buf, cashMargin, 1);
    }
    

    void decode(ByteBuf& buf) override {
        cashMargin = codec::read_fixed_string(buf, 1);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const ReportExtend040*>(&other);
        if(!checkType) return false;
        return cashMargin == checkType->cashMargin;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "ReportExtend040 { "
        << "CashMargin: " << cashMargin
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const ReportExtend040& pkt) {
    return os << pkt.toString();
}


struct ReportExtend050 : public codec::BinaryCodec {
    uint16_t expirationDays;
    uint8_t expirationType;
    uint32_t maturityDate;
    std::string shareProperty;

    void encode(ByteBuf& buf) const override {
        buf.write_u16_le(expirationDays);
        buf.write_u8(expirationType);
        buf.write_u32_le(maturityDate);
        codec::write_fixed_string(buf, shareProperty, 2);
    }
    

    void decode(ByteBuf& buf) override {
        expirationDays = buf.read_u16_le();
        expirationType = buf.read_u8();
        maturityDate = buf.read_u32_le();
        shareProperty = codec::read_fixed_string(buf, 2);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const ReportExtend050*>(&other);
        if(!checkType) return false;
        return expirationDays == checkType->expirationDays
               && expirationType == checkType->expirationType
               && maturityDate == checkType->maturityDate
               && shareProperty == checkType->shareProperty;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "ReportExtend050 { "
        << "ExpirationDays: " << std::to_string(expirationDays)
        << ", "
        << "ExpirationType: " << static_cast<unsigned>(expirationType)
        << ", "
        << "MaturityDate: " << std::to_string(maturityDate)
        << ", "
        << "ShareProperty: " << shareProperty
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const ReportExtend050& pkt) {
    return os << pkt.toString();
}


struct ExecutionReportTag{};
using ExecutionReportMessageFactory = MessageFactory<std::string, codec::BinaryCodec, ExecutionReportTag>;
REGISTER_MESSAGE(ExecutionReportMessageFactory, "010", ReportExtend010);
REGISTER_MESSAGE(ExecutionReportMessageFactory, "040", ReportExtend040);
REGISTER_MESSAGE(ExecutionReportMessageFactory, "050", ReportExtend050);


struct ExecutionReport : public codec::BinaryCodec {
    int32_t partitionNo;
    int64_t reportIndex;
    std::string applId;
    std::string reportingPbuid;
    std::string submittingPbuid;
    std::string securityId;
    std::string securityIdsource;
    uint16_t ownerType;
    std::string clearingFirm;
    int64_t transactTime;
    std::string userInfo;
    std::string orderId;
    std::string clOrdId;
    std::string execId;
    std::string execType;
    std::string ordStatus;
    int64_t lastPx;
    int64_t lastQty;
    int64_t leavesQty;
    int64_t cumQty;
    std::string side;
    std::string accountId;
    std::string branchId;
    std::unique_ptr<codec::BinaryCodec> applExtend;

    void encode(ByteBuf& buf) const override {
        buf.write_i32_le(partitionNo);
        buf.write_i64_le(reportIndex);
        codec::write_fixed_string(buf, applId, 3);
        codec::write_fixed_string(buf, reportingPbuid, 6);
        codec::write_fixed_string(buf, submittingPbuid, 6);
        codec::write_fixed_string(buf, securityId, 8);
        codec::write_fixed_string(buf, securityIdsource, 4);
        buf.write_u16_le(ownerType);
        codec::write_fixed_string(buf, clearingFirm, 2);
        buf.write_i64_le(transactTime);
        codec::write_fixed_string(buf, userInfo, 32);
        codec::write_fixed_string(buf, orderId, 16);
        codec::write_fixed_string(buf, clOrdId, 10);
        codec::write_fixed_string(buf, execId, 16);
        codec::write_fixed_string(buf, execType, 1);
        codec::write_fixed_string(buf, ordStatus, 1);
        buf.write_i64_le(lastPx);
        buf.write_i64_le(lastQty);
        buf.write_i64_le(leavesQty);
        buf.write_i64_le(cumQty);
        codec::write_fixed_string(buf, side, 1);
        codec::write_fixed_string(buf, accountId, 10);
        codec::write_fixed_string(buf, branchId, 2);
        applExtend->encode(buf);
    }
    

    void decode(ByteBuf& buf) override {
        partitionNo = buf.read_i32_le();
        reportIndex = buf.read_i64_le();
        applId = codec::read_fixed_string(buf, 3);
        reportingPbuid = codec::read_fixed_string(buf, 6);
        submittingPbuid = codec::read_fixed_string(buf, 6);
        securityId = codec::read_fixed_string(buf, 8);
        securityIdsource = codec::read_fixed_string(buf, 4);
        ownerType = buf.read_u16_le();
        clearingFirm = codec::read_fixed_string(buf, 2);
        transactTime = buf.read_i64_le();
        userInfo = codec::read_fixed_string(buf, 32);
        orderId = codec::read_fixed_string(buf, 16);
        clOrdId = codec::read_fixed_string(buf, 10);
        execId = codec::read_fixed_string(buf, 16);
        execType = codec::read_fixed_string(buf, 1);
        ordStatus = codec::read_fixed_string(buf, 1);
        lastPx = buf.read_i64_le();
        lastQty = buf.read_i64_le();
        leavesQty = buf.read_i64_le();
        cumQty = buf.read_i64_le();
        side = codec::read_fixed_string(buf, 1);
        accountId = codec::read_fixed_string(buf, 10);
        branchId = codec::read_fixed_string(buf, 2);
        applExtend = ExecutionReportMessageFactory::getInstance().create(applId);
        applExtend->decode(buf);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const ExecutionReport*>(&other);
        if(!checkType) return false;
        return partitionNo == checkType->partitionNo
               && reportIndex == checkType->reportIndex
               && applId == checkType->applId
               && reportingPbuid == checkType->reportingPbuid
               && submittingPbuid == checkType->submittingPbuid
               && securityId == checkType->securityId
               && securityIdsource == checkType->securityIdsource
               && ownerType == checkType->ownerType
               && clearingFirm == checkType->clearingFirm
               && transactTime == checkType->transactTime
               && userInfo == checkType->userInfo
               && orderId == checkType->orderId
               && clOrdId == checkType->clOrdId
               && execId == checkType->execId
               && execType == checkType->execType
               && ordStatus == checkType->ordStatus
               && lastPx == checkType->lastPx
               && lastQty == checkType->lastQty
               && leavesQty == checkType->leavesQty
               && cumQty == checkType->cumQty
               && side == checkType->side
               && accountId == checkType->accountId
               && branchId == checkType->branchId
               && applExtend->equals(*checkType->applExtend);
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "ExecutionReport { "
        << "PartitionNo: " << std::to_string(partitionNo)
        << ", "
        << "ReportIndex: " << std::to_string(reportIndex)
        << ", "
        << "ApplID: " << applId
        << ", "
        << "ReportingPBUID: " << reportingPbuid
        << ", "
        << "SubmittingPBUID: " << submittingPbuid
        << ", "
        << "SecurityID: " << securityId
        << ", "
        << "SecurityIDSource: " << securityIdsource
        << ", "
        << "OwnerType: " << std::to_string(ownerType)
        << ", "
        << "ClearingFirm: " << clearingFirm
        << ", "
        << "TransactTime: " << std::to_string(transactTime)
        << ", "
        << "UserInfo: " << userInfo
        << ", "
        << "OrderID: " << orderId
        << ", "
        << "ClOrdID: " << clOrdId
        << ", "
        << "ExecID: " << execId
        << ", "
        << "ExecType: " << execType
        << ", "
        << "OrdStatus: " << ordStatus
        << ", "
        << "LastPx: " << std::to_string(lastPx)
        << ", "
        << "LastQty: " << std::to_string(lastQty)
        << ", "
        << "LeavesQty: " << std::to_string(leavesQty)
        << ", "
        << "CumQty: " << std::to_string(cumQty)
        << ", "
        << "Side: " << side
        << ", "
        << "AccountID: " << accountId
        << ", "
        << "BranchID: " << branchId
        << ", "
        << "ApplExtend: " << applExtend->toString()
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const ExecutionReport& pkt) {
    return os << pkt.toString();
}





struct QuoteExtend070 : public codec::BinaryCodec {
    std::string branchId;
    std::string quoteId;
    std::string quoteRespId;
    uint8_t privateQuote;
    int64_t validUntilTime;
    uint8_t priceType;
    std::string cashMargin;
    std::string counterPartyPbuid;
    std::string memo;

    void encode(ByteBuf& buf) const override {
        codec::write_fixed_string(buf, branchId, 2);
        codec::write_fixed_string(buf, quoteId, 10);
        codec::write_fixed_string(buf, quoteRespId, 10);
        buf.write_u8(privateQuote);
        buf.write_i64_le(validUntilTime);
        buf.write_u8(priceType);
        codec::write_fixed_string(buf, cashMargin, 1);
        codec::write_fixed_string(buf, counterPartyPbuid, 6);
        codec::write_fixed_string(buf, memo, 120);
    }
    

    void decode(ByteBuf& buf) override {
        branchId = codec::read_fixed_string(buf, 2);
        quoteId = codec::read_fixed_string(buf, 10);
        quoteRespId = codec::read_fixed_string(buf, 10);
        privateQuote = buf.read_u8();
        validUntilTime = buf.read_i64_le();
        priceType = buf.read_u8();
        cashMargin = codec::read_fixed_string(buf, 1);
        counterPartyPbuid = codec::read_fixed_string(buf, 6);
        memo = codec::read_fixed_string(buf, 120);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const QuoteExtend070*>(&other);
        if(!checkType) return false;
        return branchId == checkType->branchId
               && quoteId == checkType->quoteId
               && quoteRespId == checkType->quoteRespId
               && privateQuote == checkType->privateQuote
               && validUntilTime == checkType->validUntilTime
               && priceType == checkType->priceType
               && cashMargin == checkType->cashMargin
               && counterPartyPbuid == checkType->counterPartyPbuid
               && memo == checkType->memo;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "QuoteExtend070 { "
        << "BranchID: " << branchId
        << ", "
        << "QuoteID: " << quoteId
        << ", "
        << "QuoteRespID: " << quoteRespId
        << ", "
        << "PrivateQuote: " << static_cast<unsigned>(privateQuote)
        << ", "
        << "ValidUntilTime: " << std::to_string(validUntilTime)
        << ", "
        << "PriceType: " << static_cast<unsigned>(priceType)
        << ", "
        << "CashMargin: " << cashMargin
        << ", "
        << "CounterPartyPBUID: " << counterPartyPbuid
        << ", "
        << "Memo: " << memo
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const QuoteExtend070& pkt) {
    return os << pkt.toString();
}


struct QuoteExtend071 : public codec::BinaryCodec {

    void encode(ByteBuf& buf) const override {
    }
    

    void decode(ByteBuf& buf) override {
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const QuoteExtend071*>(&other);
        if(!checkType) return false;
        return true;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "QuoteExtend071 { "
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const QuoteExtend071& pkt) {
    return os << pkt.toString();
}


struct QuoteTag{};
using QuoteMessageFactory = MessageFactory<std::string, codec::BinaryCodec, QuoteTag>;
REGISTER_MESSAGE(QuoteMessageFactory, "070", QuoteExtend070);
REGISTER_MESSAGE(QuoteMessageFactory, "071", QuoteExtend071);


struct Quote : public codec::BinaryCodec {
    std::string applId;
    std::string submittingPbuid;
    std::string securityId;
    std::string securityIdsource;
    uint16_t ownerType;
    std::string clearingFirm;
    int64_t transactTime;
    std::string userInfo;
    std::string quoteMsgId;
    std::string accountId;
    std::string quoteReqId;
    uint8_t quoteType;
    int64_t bidPx;
    int64_t offerPx;
    int64_t bidSize;
    int64_t offerSize;
    std::unique_ptr<codec::BinaryCodec> applExtend;

    void encode(ByteBuf& buf) const override {
        codec::write_fixed_string(buf, applId, 3);
        codec::write_fixed_string(buf, submittingPbuid, 6);
        codec::write_fixed_string(buf, securityId, 8);
        codec::write_fixed_string(buf, securityIdsource, 4);
        buf.write_u16_le(ownerType);
        codec::write_fixed_string(buf, clearingFirm, 2);
        buf.write_i64_le(transactTime);
        codec::write_fixed_string(buf, userInfo, 32);
        codec::write_fixed_string(buf, quoteMsgId, 10);
        codec::write_fixed_string(buf, accountId, 10);
        codec::write_fixed_string(buf, quoteReqId, 10);
        buf.write_u8(quoteType);
        buf.write_i64_le(bidPx);
        buf.write_i64_le(offerPx);
        buf.write_i64_le(bidSize);
        buf.write_i64_le(offerSize);
        applExtend->encode(buf);
    }
    

    void decode(ByteBuf& buf) override {
        applId = codec::read_fixed_string(buf, 3);
        submittingPbuid = codec::read_fixed_string(buf, 6);
        securityId = codec::read_fixed_string(buf, 8);
        securityIdsource = codec::read_fixed_string(buf, 4);
        ownerType = buf.read_u16_le();
        clearingFirm = codec::read_fixed_string(buf, 2);
        transactTime = buf.read_i64_le();
        userInfo = codec::read_fixed_string(buf, 32);
        quoteMsgId = codec::read_fixed_string(buf, 10);
        accountId = codec::read_fixed_string(buf, 10);
        quoteReqId = codec::read_fixed_string(buf, 10);
        quoteType = buf.read_u8();
        bidPx = buf.read_i64_le();
        offerPx = buf.read_i64_le();
        bidSize = buf.read_i64_le();
        offerSize = buf.read_i64_le();
        applExtend = QuoteMessageFactory::getInstance().create(applId);
        applExtend->decode(buf);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const Quote*>(&other);
        if(!checkType) return false;
        return applId == checkType->applId
               && submittingPbuid == checkType->submittingPbuid
               && securityId == checkType->securityId
               && securityIdsource == checkType->securityIdsource
               && ownerType == checkType->ownerType
               && clearingFirm == checkType->clearingFirm
               && transactTime == checkType->transactTime
               && userInfo == checkType->userInfo
               && quoteMsgId == checkType->quoteMsgId
               && accountId == checkType->accountId
               && quoteReqId == checkType->quoteReqId
               && quoteType == checkType->quoteType
               && bidPx == checkType->bidPx
               && offerPx == checkType->offerPx
               && bidSize == checkType->bidSize
               && offerSize == checkType->offerSize
               && applExtend->equals(*checkType->applExtend);
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "Quote { "
        << "ApplID: " << applId
        << ", "
        << "SubmittingPBUID: " << submittingPbuid
        << ", "
        << "SecurityID: " << securityId
        << ", "
        << "SecurityIDSource: " << securityIdsource
        << ", "
        << "OwnerType: " << std::to_string(ownerType)
        << ", "
        << "ClearingFirm: " << clearingFirm
        << ", "
        << "TransactTime: " << std::to_string(transactTime)
        << ", "
        << "UserInfo: " << userInfo
        << ", "
        << "QuoteMsgID: " << quoteMsgId
        << ", "
        << "AccountID: " << accountId
        << ", "
        << "QuoteReqID: " << quoteReqId
        << ", "
        << "QuoteType: " << static_cast<unsigned>(quoteType)
        << ", "
        << "BidPx: " << std::to_string(bidPx)
        << ", "
        << "OfferPx: " << std::to_string(offerPx)
        << ", "
        << "BidSize: " << std::to_string(bidSize)
        << ", "
        << "OfferSize: " << std::to_string(offerSize)
        << ", "
        << "ApplExtend: " << applExtend->toString()
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const Quote& pkt) {
    return os << pkt.toString();
}




struct Quote1 : public codec::BinaryCodec {
    std::string quoteId;
    int64_t quotePrice;
    int64_t quoteQty;

    void encode(ByteBuf& buf) const override {
        codec::write_fixed_string(buf, quoteId, 10);
        buf.write_i64_le(quotePrice);
        buf.write_i64_le(quoteQty);
    }
    

    void decode(ByteBuf& buf) override {
        quoteId = codec::read_fixed_string(buf, 10);
        quotePrice = buf.read_i64_le();
        quoteQty = buf.read_i64_le();
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const Quote1*>(&other);
        if(!checkType) return false;
        return quoteId == checkType->quoteId
               && quotePrice == checkType->quotePrice
               && quoteQty == checkType->quoteQty;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "Quote1 { "
        << "QuoteID: " << quoteId
        << ", "
        << "QuotePrice: " << std::to_string(quotePrice)
        << ", "
        << "QuoteQty: " << std::to_string(quoteQty)
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const Quote1& pkt) {
    return os << pkt.toString();
}


struct QuoteStatusReportExtend070 : public codec::BinaryCodec {
    std::string branchId;
    std::string orderId;
    std::string execId;
    std::string quoteRespId;
    uint8_t privateQuote;
    std::string side;
    uint8_t priceType;
    int64_t validUntilTime;
    std::string cashMargin;
    std::string counterPartyPbuid;
    std::string memo;
    std::vector<Quote1> quote1;

    void encode(ByteBuf& buf) const override {
        codec::write_fixed_string(buf, branchId, 2);
        codec::write_fixed_string(buf, orderId, 16);
        codec::write_fixed_string(buf, execId, 16);
        codec::write_fixed_string(buf, quoteRespId, 10);
        buf.write_u8(privateQuote);
        codec::write_fixed_string(buf, side, 1);
        buf.write_u8(priceType);
        buf.write_i64_le(validUntilTime);
        codec::write_fixed_string(buf, cashMargin, 1);
        codec::write_fixed_string(buf, counterPartyPbuid, 6);
        codec::write_fixed_string(buf, memo, 120);
        codec::write_object_List_le<uint16_t>(buf,quote1);
    }
    

    void decode(ByteBuf& buf) override {
        branchId = codec::read_fixed_string(buf, 2);
        orderId = codec::read_fixed_string(buf, 16);
        execId = codec::read_fixed_string(buf, 16);
        quoteRespId = codec::read_fixed_string(buf, 10);
        privateQuote = buf.read_u8();
        side = codec::read_fixed_string(buf, 1);
        priceType = buf.read_u8();
        validUntilTime = buf.read_i64_le();
        cashMargin = codec::read_fixed_string(buf, 1);
        counterPartyPbuid = codec::read_fixed_string(buf, 6);
        memo = codec::read_fixed_string(buf, 120);
        quote1 = codec::read_object_List_le<uint16_t,Quote1>(buf);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const QuoteStatusReportExtend070*>(&other);
        if(!checkType) return false;
        return branchId == checkType->branchId
               && orderId == checkType->orderId
               && execId == checkType->execId
               && quoteRespId == checkType->quoteRespId
               && privateQuote == checkType->privateQuote
               && side == checkType->side
               && priceType == checkType->priceType
               && validUntilTime == checkType->validUntilTime
               && cashMargin == checkType->cashMargin
               && counterPartyPbuid == checkType->counterPartyPbuid
               && memo == checkType->memo
               && quote1 == checkType->quote1;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "QuoteStatusReportExtend070 { "
        << "BranchID: " << branchId
        << ", "
        << "OrderID: " << orderId
        << ", "
        << "ExecID: " << execId
        << ", "
        << "QuoteRespID: " << quoteRespId
        << ", "
        << "PrivateQuote: " << static_cast<unsigned>(privateQuote)
        << ", "
        << "Side: " << side
        << ", "
        << "PriceType: " << static_cast<unsigned>(priceType)
        << ", "
        << "ValidUntilTime: " << std::to_string(validUntilTime)
        << ", "
        << "CashMargin: " << cashMargin
        << ", "
        << "CounterPartyPBUID: " << counterPartyPbuid
        << ", "
        << "Memo: " << memo
        << ", "
        << "Quote1: " << codec::join_vector<Quote1>(quote1)
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const QuoteStatusReportExtend070& pkt) {
    return os << pkt.toString();
}


struct QuoteStatusReportTag{};
using QuoteStatusReportMessageFactory = MessageFactory<std::string, codec::BinaryCodec, QuoteStatusReportTag>;
REGISTER_MESSAGE(QuoteStatusReportMessageFactory, "070", QuoteStatusReportExtend070);


struct QuoteStatusReport : public codec::BinaryCodec {
    int32_t partitionNo;
    int64_t reportIndex;
    std::string applId;
    std::string reportingPbuid;
    std::string submittingPbuid;
    std::string securityId;
    std::string securityIdsource;
    uint16_t ownerType;
    std::string clearingFirm;
    int64_t transactTime;
    std::string userInfo;
    std::string quoteMsgId;
    std::string accountId;
    std::string quoteReqId;
    uint64_t quoteRjectReason;
    uint8_t quoteType;
    int64_t bidPx;
    int64_t offerPx;
    int64_t bidSize;
    int64_t offerSize;
    std::unique_ptr<codec::BinaryCodec> applExtend;

    void encode(ByteBuf& buf) const override {
        buf.write_i32_le(partitionNo);
        buf.write_i64_le(reportIndex);
        codec::write_fixed_string(buf, applId, 3);
        codec::write_fixed_string(buf, reportingPbuid, 6);
        codec::write_fixed_string(buf, submittingPbuid, 6);
        codec::write_fixed_string(buf, securityId, 8);
        codec::write_fixed_string(buf, securityIdsource, 4);
        buf.write_u16_le(ownerType);
        codec::write_fixed_string(buf, clearingFirm, 2);
        buf.write_i64_le(transactTime);
        codec::write_fixed_string(buf, userInfo, 32);
        codec::write_fixed_string(buf, quoteMsgId, 10);
        codec::write_fixed_string(buf, accountId, 10);
        codec::write_fixed_string(buf, quoteReqId, 10);
        buf.write_u64_le(quoteRjectReason);
        buf.write_u8(quoteType);
        buf.write_i64_le(bidPx);
        buf.write_i64_le(offerPx);
        buf.write_i64_le(bidSize);
        buf.write_i64_le(offerSize);
        applExtend->encode(buf);
    }
    

    void decode(ByteBuf& buf) override {
        partitionNo = buf.read_i32_le();
        reportIndex = buf.read_i64_le();
        applId = codec::read_fixed_string(buf, 3);
        reportingPbuid = codec::read_fixed_string(buf, 6);
        submittingPbuid = codec::read_fixed_string(buf, 6);
        securityId = codec::read_fixed_string(buf, 8);
        securityIdsource = codec::read_fixed_string(buf, 4);
        ownerType = buf.read_u16_le();
        clearingFirm = codec::read_fixed_string(buf, 2);
        transactTime = buf.read_i64_le();
        userInfo = codec::read_fixed_string(buf, 32);
        quoteMsgId = codec::read_fixed_string(buf, 10);
        accountId = codec::read_fixed_string(buf, 10);
        quoteReqId = codec::read_fixed_string(buf, 10);
        quoteRjectReason = buf.read_u64_le();
        quoteType = buf.read_u8();
        bidPx = buf.read_i64_le();
        offerPx = buf.read_i64_le();
        bidSize = buf.read_i64_le();
        offerSize = buf.read_i64_le();
        applExtend = QuoteStatusReportMessageFactory::getInstance().create(applId);
        applExtend->decode(buf);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const QuoteStatusReport*>(&other);
        if(!checkType) return false;
        return partitionNo == checkType->partitionNo
               && reportIndex == checkType->reportIndex
               && applId == checkType->applId
               && reportingPbuid == checkType->reportingPbuid
               && submittingPbuid == checkType->submittingPbuid
               && securityId == checkType->securityId
               && securityIdsource == checkType->securityIdsource
               && ownerType == checkType->ownerType
               && clearingFirm == checkType->clearingFirm
               && transactTime == checkType->transactTime
               && userInfo == checkType->userInfo
               && quoteMsgId == checkType->quoteMsgId
               && accountId == checkType->accountId
               && quoteReqId == checkType->quoteReqId
               && quoteRjectReason == checkType->quoteRjectReason
               && quoteType == checkType->quoteType
               && bidPx == checkType->bidPx
               && offerPx == checkType->offerPx
               && bidSize == checkType->bidSize
               && offerSize == checkType->offerSize
               && applExtend->equals(*checkType->applExtend);
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "QuoteStatusReport { "
        << "PartitionNo: " << std::to_string(partitionNo)
        << ", "
        << "ReportIndex: " << std::to_string(reportIndex)
        << ", "
        << "ApplID: " << applId
        << ", "
        << "ReportingPBUID: " << reportingPbuid
        << ", "
        << "SubmittingPBUID: " << submittingPbuid
        << ", "
        << "SecurityID: " << securityId
        << ", "
        << "SecurityIDSource: " << securityIdsource
        << ", "
        << "OwnerType: " << std::to_string(ownerType)
        << ", "
        << "ClearingFirm: " << clearingFirm
        << ", "
        << "TransactTime: " << std::to_string(transactTime)
        << ", "
        << "UserInfo: " << userInfo
        << ", "
        << "QuoteMsgID: " << quoteMsgId
        << ", "
        << "AccountID: " << accountId
        << ", "
        << "QuoteReqID: " << quoteReqId
        << ", "
        << "QuoteRjectReason: " << std::to_string(quoteRjectReason)
        << ", "
        << "QuoteType: " << static_cast<unsigned>(quoteType)
        << ", "
        << "BidPx: " << std::to_string(bidPx)
        << ", "
        << "OfferPx: " << std::to_string(offerPx)
        << ", "
        << "BidSize: " << std::to_string(bidSize)
        << ", "
        << "OfferSize: " << std::to_string(offerSize)
        << ", "
        << "ApplExtend: " << applExtend->toString()
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const QuoteStatusReport& pkt) {
    return os << pkt.toString();
}



struct Quote2 : public codec::BinaryCodec {
    std::string quoteId;
    int64_t quotePrice;
    int64_t quoteQty;

    void encode(ByteBuf& buf) const override {
        codec::write_fixed_string(buf, quoteId, 10);
        buf.write_i64_le(quotePrice);
        buf.write_i64_le(quoteQty);
    }
    

    void decode(ByteBuf& buf) override {
        quoteId = codec::read_fixed_string(buf, 10);
        quotePrice = buf.read_i64_le();
        quoteQty = buf.read_i64_le();
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const Quote2*>(&other);
        if(!checkType) return false;
        return quoteId == checkType->quoteId
               && quotePrice == checkType->quotePrice
               && quoteQty == checkType->quoteQty;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "Quote2 { "
        << "QuoteID: " << quoteId
        << ", "
        << "QuotePrice: " << std::to_string(quotePrice)
        << ", "
        << "QuoteQty: " << std::to_string(quoteQty)
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const Quote2& pkt) {
    return os << pkt.toString();
}


struct QuoteResponseExtend070 : public codec::BinaryCodec {
    std::string cashMargin;

    void encode(ByteBuf& buf) const override {
        codec::write_fixed_string(buf, cashMargin, 1);
    }
    

    void decode(ByteBuf& buf) override {
        cashMargin = codec::read_fixed_string(buf, 1);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const QuoteResponseExtend070*>(&other);
        if(!checkType) return false;
        return cashMargin == checkType->cashMargin;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "QuoteResponseExtend070 { "
        << "CashMargin: " << cashMargin
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const QuoteResponseExtend070& pkt) {
    return os << pkt.toString();
}


struct QuoteResponseTag{};
using QuoteResponseMessageFactory = MessageFactory<std::string, codec::BinaryCodec, QuoteResponseTag>;
REGISTER_MESSAGE(QuoteResponseMessageFactory, "070", QuoteResponseExtend070);


struct QuoteResponse : public codec::BinaryCodec {
    std::string applId;
    std::string reportingPbuid;
    std::string submittingPbuid;
    std::string securityId;
    std::string securityIdsource;
    uint16_t ownerType;
    std::string clearingFirm;
    int64_t transactTime;
    std::string userInfo;
    std::string clOrdId;
    std::string accountId;
    std::string branchId;
    std::string quoteRespId;
    uint8_t quoteRespType;
    std::string side;
    int64_t validUntilTime;
    uint8_t quoteType;
    uint8_t priceType;
    std::vector<Quote2> quote2;
    std::unique_ptr<codec::BinaryCodec> applExtend;

    void encode(ByteBuf& buf) const override {
        codec::write_fixed_string(buf, applId, 3);
        codec::write_fixed_string(buf, reportingPbuid, 6);
        codec::write_fixed_string(buf, submittingPbuid, 6);
        codec::write_fixed_string(buf, securityId, 8);
        codec::write_fixed_string(buf, securityIdsource, 4);
        buf.write_u16_le(ownerType);
        codec::write_fixed_string(buf, clearingFirm, 2);
        buf.write_i64_le(transactTime);
        codec::write_fixed_string(buf, userInfo, 32);
        codec::write_fixed_string(buf, clOrdId, 10);
        codec::write_fixed_string(buf, accountId, 10);
        codec::write_fixed_string(buf, branchId, 2);
        codec::write_fixed_string(buf, quoteRespId, 10);
        buf.write_u8(quoteRespType);
        codec::write_fixed_string(buf, side, 1);
        buf.write_i64_le(validUntilTime);
        buf.write_u8(quoteType);
        buf.write_u8(priceType);
        codec::write_object_List_le<uint16_t>(buf,quote2);
        applExtend->encode(buf);
    }
    

    void decode(ByteBuf& buf) override {
        applId = codec::read_fixed_string(buf, 3);
        reportingPbuid = codec::read_fixed_string(buf, 6);
        submittingPbuid = codec::read_fixed_string(buf, 6);
        securityId = codec::read_fixed_string(buf, 8);
        securityIdsource = codec::read_fixed_string(buf, 4);
        ownerType = buf.read_u16_le();
        clearingFirm = codec::read_fixed_string(buf, 2);
        transactTime = buf.read_i64_le();
        userInfo = codec::read_fixed_string(buf, 32);
        clOrdId = codec::read_fixed_string(buf, 10);
        accountId = codec::read_fixed_string(buf, 10);
        branchId = codec::read_fixed_string(buf, 2);
        quoteRespId = codec::read_fixed_string(buf, 10);
        quoteRespType = buf.read_u8();
        side = codec::read_fixed_string(buf, 1);
        validUntilTime = buf.read_i64_le();
        quoteType = buf.read_u8();
        priceType = buf.read_u8();
        quote2 = codec::read_object_List_le<uint16_t,Quote2>(buf);
        applExtend = QuoteResponseMessageFactory::getInstance().create(applId);
        applExtend->decode(buf);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const QuoteResponse*>(&other);
        if(!checkType) return false;
        return applId == checkType->applId
               && reportingPbuid == checkType->reportingPbuid
               && submittingPbuid == checkType->submittingPbuid
               && securityId == checkType->securityId
               && securityIdsource == checkType->securityIdsource
               && ownerType == checkType->ownerType
               && clearingFirm == checkType->clearingFirm
               && transactTime == checkType->transactTime
               && userInfo == checkType->userInfo
               && clOrdId == checkType->clOrdId
               && accountId == checkType->accountId
               && branchId == checkType->branchId
               && quoteRespId == checkType->quoteRespId
               && quoteRespType == checkType->quoteRespType
               && side == checkType->side
               && validUntilTime == checkType->validUntilTime
               && quoteType == checkType->quoteType
               && priceType == checkType->priceType
               && quote2 == checkType->quote2
               && applExtend->equals(*checkType->applExtend);
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "QuoteResponse { "
        << "ApplID: " << applId
        << ", "
        << "ReportingPBUID: " << reportingPbuid
        << ", "
        << "SubmittingPBUID: " << submittingPbuid
        << ", "
        << "SecurityID: " << securityId
        << ", "
        << "SecurityIDSource: " << securityIdsource
        << ", "
        << "OwnerType: " << std::to_string(ownerType)
        << ", "
        << "ClearingFirm: " << clearingFirm
        << ", "
        << "TransactTime: " << std::to_string(transactTime)
        << ", "
        << "UserInfo: " << userInfo
        << ", "
        << "ClOrdID: " << clOrdId
        << ", "
        << "AccountID: " << accountId
        << ", "
        << "BranchID: " << branchId
        << ", "
        << "QuoteRespID: " << quoteRespId
        << ", "
        << "QuoteRespType: " << static_cast<unsigned>(quoteRespType)
        << ", "
        << "Side: " << side
        << ", "
        << "ValidUntilTime: " << std::to_string(validUntilTime)
        << ", "
        << "QuoteType: " << static_cast<unsigned>(quoteType)
        << ", "
        << "PriceType: " << static_cast<unsigned>(priceType)
        << ", "
        << "Quote2: " << codec::join_vector<Quote2>(quote2)
        << ", "
        << "ApplExtend: " << applExtend->toString()
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const QuoteResponse& pkt) {
    return os << pkt.toString();
}



struct AllegeQuoteExtend070 : public codec::BinaryCodec {
    std::string cashMargin;
    std::string counterPartyPbuid;

    void encode(ByteBuf& buf) const override {
        codec::write_fixed_string(buf, cashMargin, 1);
        codec::write_fixed_string(buf, counterPartyPbuid, 6);
    }
    

    void decode(ByteBuf& buf) override {
        cashMargin = codec::read_fixed_string(buf, 1);
        counterPartyPbuid = codec::read_fixed_string(buf, 6);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const AllegeQuoteExtend070*>(&other);
        if(!checkType) return false;
        return cashMargin == checkType->cashMargin
               && counterPartyPbuid == checkType->counterPartyPbuid;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "AllegeQuoteExtend070 { "
        << "CashMargin: " << cashMargin
        << ", "
        << "CounterPartyPBUID: " << counterPartyPbuid
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const AllegeQuoteExtend070& pkt) {
    return os << pkt.toString();
}


struct AllegeQuoteTag{};
using AllegeQuoteMessageFactory = MessageFactory<std::string, codec::BinaryCodec, AllegeQuoteTag>;
REGISTER_MESSAGE(AllegeQuoteMessageFactory, "070", AllegeQuoteExtend070);


struct AllegeQuote : public codec::BinaryCodec {
    int32_t partitionNo;
    int64_t reportIndex;
    std::string applId;
    std::string reportingPbuid;
    std::string submittingPbuid;
    std::string securityId;
    std::string securityIdsource;
    uint16_t ownerType;
    std::string clearingFirm;
    int64_t transactTime;
    std::string userInfo;
    std::string orderId;
    std::string execId;
    std::string clOrdId;
    std::string accountId;
    std::string quoteReqId;
    std::string quoteId;
    std::string quoteRespId;
    uint8_t quoteType;
    int64_t bidPx;
    int64_t offerPx;
    int64_t bidSize;
    int64_t offerSize;
    uint8_t privateQuote;
    int64_t validUntilTime;
    uint8_t priceType;
    std::string memo;
    std::unique_ptr<codec::BinaryCodec> applExtend;

    void encode(ByteBuf& buf) const override {
        buf.write_i32_le(partitionNo);
        buf.write_i64_le(reportIndex);
        codec::write_fixed_string(buf, applId, 3);
        codec::write_fixed_string(buf, reportingPbuid, 6);
        codec::write_fixed_string(buf, submittingPbuid, 6);
        codec::write_fixed_string(buf, securityId, 8);
        codec::write_fixed_string(buf, securityIdsource, 4);
        buf.write_u16_le(ownerType);
        codec::write_fixed_string(buf, clearingFirm, 2);
        buf.write_i64_le(transactTime);
        codec::write_fixed_string(buf, userInfo, 32);
        codec::write_fixed_string(buf, orderId, 16);
        codec::write_fixed_string(buf, execId, 16);
        codec::write_fixed_string(buf, clOrdId, 10);
        codec::write_fixed_string(buf, accountId, 10);
        codec::write_fixed_string(buf, quoteReqId, 10);
        codec::write_fixed_string(buf, quoteId, 10);
        codec::write_fixed_string(buf, quoteRespId, 10);
        buf.write_u8(quoteType);
        buf.write_i64_le(bidPx);
        buf.write_i64_le(offerPx);
        buf.write_i64_le(bidSize);
        buf.write_i64_le(offerSize);
        buf.write_u8(privateQuote);
        buf.write_i64_le(validUntilTime);
        buf.write_u8(priceType);
        codec::write_fixed_string(buf, memo, 120);
        applExtend->encode(buf);
    }
    

    void decode(ByteBuf& buf) override {
        partitionNo = buf.read_i32_le();
        reportIndex = buf.read_i64_le();
        applId = codec::read_fixed_string(buf, 3);
        reportingPbuid = codec::read_fixed_string(buf, 6);
        submittingPbuid = codec::read_fixed_string(buf, 6);
        securityId = codec::read_fixed_string(buf, 8);
        securityIdsource = codec::read_fixed_string(buf, 4);
        ownerType = buf.read_u16_le();
        clearingFirm = codec::read_fixed_string(buf, 2);
        transactTime = buf.read_i64_le();
        userInfo = codec::read_fixed_string(buf, 32);
        orderId = codec::read_fixed_string(buf, 16);
        execId = codec::read_fixed_string(buf, 16);
        clOrdId = codec::read_fixed_string(buf, 10);
        accountId = codec::read_fixed_string(buf, 10);
        quoteReqId = codec::read_fixed_string(buf, 10);
        quoteId = codec::read_fixed_string(buf, 10);
        quoteRespId = codec::read_fixed_string(buf, 10);
        quoteType = buf.read_u8();
        bidPx = buf.read_i64_le();
        offerPx = buf.read_i64_le();
        bidSize = buf.read_i64_le();
        offerSize = buf.read_i64_le();
        privateQuote = buf.read_u8();
        validUntilTime = buf.read_i64_le();
        priceType = buf.read_u8();
        memo = codec::read_fixed_string(buf, 120);
        applExtend = AllegeQuoteMessageFactory::getInstance().create(applId);
        applExtend->decode(buf);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const AllegeQuote*>(&other);
        if(!checkType) return false;
        return partitionNo == checkType->partitionNo
               && reportIndex == checkType->reportIndex
               && applId == checkType->applId
               && reportingPbuid == checkType->reportingPbuid
               && submittingPbuid == checkType->submittingPbuid
               && securityId == checkType->securityId
               && securityIdsource == checkType->securityIdsource
               && ownerType == checkType->ownerType
               && clearingFirm == checkType->clearingFirm
               && transactTime == checkType->transactTime
               && userInfo == checkType->userInfo
               && orderId == checkType->orderId
               && execId == checkType->execId
               && clOrdId == checkType->clOrdId
               && accountId == checkType->accountId
               && quoteReqId == checkType->quoteReqId
               && quoteId == checkType->quoteId
               && quoteRespId == checkType->quoteRespId
               && quoteType == checkType->quoteType
               && bidPx == checkType->bidPx
               && offerPx == checkType->offerPx
               && bidSize == checkType->bidSize
               && offerSize == checkType->offerSize
               && privateQuote == checkType->privateQuote
               && validUntilTime == checkType->validUntilTime
               && priceType == checkType->priceType
               && memo == checkType->memo
               && applExtend->equals(*checkType->applExtend);
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "AllegeQuote { "
        << "PartitionNo: " << std::to_string(partitionNo)
        << ", "
        << "ReportIndex: " << std::to_string(reportIndex)
        << ", "
        << "ApplID: " << applId
        << ", "
        << "ReportingPBUID: " << reportingPbuid
        << ", "
        << "SubmittingPBUID: " << submittingPbuid
        << ", "
        << "SecurityID: " << securityId
        << ", "
        << "SecurityIDSource: " << securityIdsource
        << ", "
        << "OwnerType: " << std::to_string(ownerType)
        << ", "
        << "ClearingFirm: " << clearingFirm
        << ", "
        << "TransactTime: " << std::to_string(transactTime)
        << ", "
        << "UserInfo: " << userInfo
        << ", "
        << "OrderID: " << orderId
        << ", "
        << "ExecID: " << execId
        << ", "
        << "ClOrdID: " << clOrdId
        << ", "
        << "AccountID: " << accountId
        << ", "
        << "QuoteReqID: " << quoteReqId
        << ", "
        << "QuoteID: " << quoteId
        << ", "
        << "QuoteRespID: " << quoteRespId
        << ", "
        << "QuoteType: " << static_cast<unsigned>(quoteType)
        << ", "
        << "BidPx: " << std::to_string(bidPx)
        << ", "
        << "OfferPx: " << std::to_string(offerPx)
        << ", "
        << "BidSize: " << std::to_string(bidSize)
        << ", "
        << "OfferSize: " << std::to_string(offerSize)
        << ", "
        << "PrivateQuote: " << static_cast<unsigned>(privateQuote)
        << ", "
        << "ValidUntilTime: " << std::to_string(validUntilTime)
        << ", "
        << "PriceType: " << static_cast<unsigned>(priceType)
        << ", "
        << "Memo: " << memo
        << ", "
        << "ApplExtend: " << applExtend->toString()
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const AllegeQuote& pkt) {
    return os << pkt.toString();
}



struct AllegeQuoteResponse : public codec::BinaryCodec {
    int32_t partitionNo;
    int64_t reportIndex;
    std::string applId;
    std::string reportingPbuid;
    std::string submittingPbuid;
    std::string securityId;
    std::string securityIdsource;
    uint16_t ownerType;
    std::string clearingFirm;
    int64_t transactTime;
    std::string userInfo;
    std::string orderId;
    std::string execId;
    std::string clOrdId;
    std::string accountId;
    std::string quoteId;
    std::string quoteRespId;
    uint8_t quoteRespType;
    uint8_t privateQuote;
    int64_t orderQty;
    int64_t price;
    int64_t validUntilTime;
    uint8_t quoteType;
    uint8_t priceType;

    void encode(ByteBuf& buf) const override {
        buf.write_i32_le(partitionNo);
        buf.write_i64_le(reportIndex);
        codec::write_fixed_string(buf, applId, 3);
        codec::write_fixed_string(buf, reportingPbuid, 6);
        codec::write_fixed_string(buf, submittingPbuid, 6);
        codec::write_fixed_string(buf, securityId, 8);
        codec::write_fixed_string(buf, securityIdsource, 4);
        buf.write_u16_le(ownerType);
        codec::write_fixed_string(buf, clearingFirm, 2);
        buf.write_i64_le(transactTime);
        codec::write_fixed_string(buf, userInfo, 32);
        codec::write_fixed_string(buf, orderId, 16);
        codec::write_fixed_string(buf, execId, 16);
        codec::write_fixed_string(buf, clOrdId, 10);
        codec::write_fixed_string(buf, accountId, 10);
        codec::write_fixed_string(buf, quoteId, 10);
        codec::write_fixed_string(buf, quoteRespId, 10);
        buf.write_u8(quoteRespType);
        buf.write_u8(privateQuote);
        buf.write_i64_le(orderQty);
        buf.write_i64_le(price);
        buf.write_i64_le(validUntilTime);
        buf.write_u8(quoteType);
        buf.write_u8(priceType);
    }
    

    void decode(ByteBuf& buf) override {
        partitionNo = buf.read_i32_le();
        reportIndex = buf.read_i64_le();
        applId = codec::read_fixed_string(buf, 3);
        reportingPbuid = codec::read_fixed_string(buf, 6);
        submittingPbuid = codec::read_fixed_string(buf, 6);
        securityId = codec::read_fixed_string(buf, 8);
        securityIdsource = codec::read_fixed_string(buf, 4);
        ownerType = buf.read_u16_le();
        clearingFirm = codec::read_fixed_string(buf, 2);
        transactTime = buf.read_i64_le();
        userInfo = codec::read_fixed_string(buf, 32);
        orderId = codec::read_fixed_string(buf, 16);
        execId = codec::read_fixed_string(buf, 16);
        clOrdId = codec::read_fixed_string(buf, 10);
        accountId = codec::read_fixed_string(buf, 10);
        quoteId = codec::read_fixed_string(buf, 10);
        quoteRespId = codec::read_fixed_string(buf, 10);
        quoteRespType = buf.read_u8();
        privateQuote = buf.read_u8();
        orderQty = buf.read_i64_le();
        price = buf.read_i64_le();
        validUntilTime = buf.read_i64_le();
        quoteType = buf.read_u8();
        priceType = buf.read_u8();
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const AllegeQuoteResponse*>(&other);
        if(!checkType) return false;
        return partitionNo == checkType->partitionNo
               && reportIndex == checkType->reportIndex
               && applId == checkType->applId
               && reportingPbuid == checkType->reportingPbuid
               && submittingPbuid == checkType->submittingPbuid
               && securityId == checkType->securityId
               && securityIdsource == checkType->securityIdsource
               && ownerType == checkType->ownerType
               && clearingFirm == checkType->clearingFirm
               && transactTime == checkType->transactTime
               && userInfo == checkType->userInfo
               && orderId == checkType->orderId
               && execId == checkType->execId
               && clOrdId == checkType->clOrdId
               && accountId == checkType->accountId
               && quoteId == checkType->quoteId
               && quoteRespId == checkType->quoteRespId
               && quoteRespType == checkType->quoteRespType
               && privateQuote == checkType->privateQuote
               && orderQty == checkType->orderQty
               && price == checkType->price
               && validUntilTime == checkType->validUntilTime
               && quoteType == checkType->quoteType
               && priceType == checkType->priceType;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "AllegeQuoteResponse { "
        << "PartitionNo: " << std::to_string(partitionNo)
        << ", "
        << "ReportIndex: " << std::to_string(reportIndex)
        << ", "
        << "ApplID: " << applId
        << ", "
        << "ReportingPBUID: " << reportingPbuid
        << ", "
        << "SubmittingPBUID: " << submittingPbuid
        << ", "
        << "SecurityID: " << securityId
        << ", "
        << "SecurityIDSource: " << securityIdsource
        << ", "
        << "OwnerType: " << std::to_string(ownerType)
        << ", "
        << "ClearingFirm: " << clearingFirm
        << ", "
        << "TransactTime: " << std::to_string(transactTime)
        << ", "
        << "UserInfo: " << userInfo
        << ", "
        << "OrderID: " << orderId
        << ", "
        << "ExecID: " << execId
        << ", "
        << "ClOrdID: " << clOrdId
        << ", "
        << "AccountID: " << accountId
        << ", "
        << "QuoteID: " << quoteId
        << ", "
        << "QuoteRespID: " << quoteRespId
        << ", "
        << "QuoteRespType: " << static_cast<unsigned>(quoteRespType)
        << ", "
        << "PrivateQuote: " << static_cast<unsigned>(privateQuote)
        << ", "
        << "OrderQty: " << std::to_string(orderQty)
        << ", "
        << "Price: " << std::to_string(price)
        << ", "
        << "ValidUntilTime: " << std::to_string(validUntilTime)
        << ", "
        << "QuoteType: " << static_cast<unsigned>(quoteType)
        << ", "
        << "PriceType: " << static_cast<unsigned>(priceType)
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const AllegeQuoteResponse& pkt) {
    return os << pkt.toString();
}


struct TradeCaptureReportExtend031 : public codec::BinaryCodec {
    std::string memberId;
    std::string traderCode;
    std::string counterPartyMemberId;
    std::string counterPartyTraderCode;
    std::string settlType;
    std::string settlPeriod;
    std::string cashMargin;
    std::string memo;

    void encode(ByteBuf& buf) const override {
        codec::write_fixed_string(buf, memberId, 6);
        codec::write_fixed_string(buf, traderCode, 5);
        codec::write_fixed_string(buf, counterPartyMemberId, 6);
        codec::write_fixed_string(buf, counterPartyTraderCode, 5);
        codec::write_fixed_string(buf, settlType, 1);
        codec::write_fixed_string(buf, settlPeriod, 1);
        codec::write_fixed_string(buf, cashMargin, 1);
        codec::write_fixed_string(buf, memo, 120);
    }
    

    void decode(ByteBuf& buf) override {
        memberId = codec::read_fixed_string(buf, 6);
        traderCode = codec::read_fixed_string(buf, 5);
        counterPartyMemberId = codec::read_fixed_string(buf, 6);
        counterPartyTraderCode = codec::read_fixed_string(buf, 5);
        settlType = codec::read_fixed_string(buf, 1);
        settlPeriod = codec::read_fixed_string(buf, 1);
        cashMargin = codec::read_fixed_string(buf, 1);
        memo = codec::read_fixed_string(buf, 120);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const TradeCaptureReportExtend031*>(&other);
        if(!checkType) return false;
        return memberId == checkType->memberId
               && traderCode == checkType->traderCode
               && counterPartyMemberId == checkType->counterPartyMemberId
               && counterPartyTraderCode == checkType->counterPartyTraderCode
               && settlType == checkType->settlType
               && settlPeriod == checkType->settlPeriod
               && cashMargin == checkType->cashMargin
               && memo == checkType->memo;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "TradeCaptureReportExtend031 { "
        << "MemberID: " << memberId
        << ", "
        << "TraderCode: " << traderCode
        << ", "
        << "CounterPartyMemberID: " << counterPartyMemberId
        << ", "
        << "CounterPartyTraderCode: " << counterPartyTraderCode
        << ", "
        << "SettlType: " << settlType
        << ", "
        << "SettlPeriod: " << settlPeriod
        << ", "
        << "CashMargin: " << cashMargin
        << ", "
        << "Memo: " << memo
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const TradeCaptureReportExtend031& pkt) {
    return os << pkt.toString();
}


struct TradeCaptureReportExtend051 : public codec::BinaryCodec {
    uint16_t expirationDays;
    uint8_t expirationType;
    std::string shareProperty;

    void encode(ByteBuf& buf) const override {
        buf.write_u16_le(expirationDays);
        buf.write_u8(expirationType);
        codec::write_fixed_string(buf, shareProperty, 2);
    }
    

    void decode(ByteBuf& buf) override {
        expirationDays = buf.read_u16_le();
        expirationType = buf.read_u8();
        shareProperty = codec::read_fixed_string(buf, 2);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const TradeCaptureReportExtend051*>(&other);
        if(!checkType) return false;
        return expirationDays == checkType->expirationDays
               && expirationType == checkType->expirationType
               && shareProperty == checkType->shareProperty;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "TradeCaptureReportExtend051 { "
        << "ExpirationDays: " << std::to_string(expirationDays)
        << ", "
        << "ExpirationType: " << static_cast<unsigned>(expirationType)
        << ", "
        << "ShareProperty: " << shareProperty
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const TradeCaptureReportExtend051& pkt) {
    return os << pkt.toString();
}


struct TradeCaptureReportExtend060 : public codec::BinaryCodec {

    void encode(ByteBuf& buf) const override {
    }
    

    void decode(ByteBuf& buf) override {
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const TradeCaptureReportExtend060*>(&other);
        if(!checkType) return false;
        return true;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "TradeCaptureReportExtend060 { "
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const TradeCaptureReportExtend060& pkt) {
    return os << pkt.toString();
}


struct TradeCaptureReportExtend061 : public codec::BinaryCodec {

    void encode(ByteBuf& buf) const override {
    }
    

    void decode(ByteBuf& buf) override {
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const TradeCaptureReportExtend061*>(&other);
        if(!checkType) return false;
        return true;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "TradeCaptureReportExtend061 { "
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const TradeCaptureReportExtend061& pkt) {
    return os << pkt.toString();
}


struct TradeCaptureReportExtend062 : public codec::BinaryCodec {
    std::string cashMargin;

    void encode(ByteBuf& buf) const override {
        codec::write_fixed_string(buf, cashMargin, 1);
    }
    

    void decode(ByteBuf& buf) override {
        cashMargin = codec::read_fixed_string(buf, 1);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const TradeCaptureReportExtend062*>(&other);
        if(!checkType) return false;
        return cashMargin == checkType->cashMargin;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "TradeCaptureReportExtend062 { "
        << "CashMargin: " << cashMargin
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const TradeCaptureReportExtend062& pkt) {
    return os << pkt.toString();
}


struct TradeCaptureReportTag{};
using TradeCaptureReportMessageFactory = MessageFactory<std::string, codec::BinaryCodec, TradeCaptureReportTag>;
REGISTER_MESSAGE(TradeCaptureReportMessageFactory, "031", TradeCaptureReportExtend031);
REGISTER_MESSAGE(TradeCaptureReportMessageFactory, "051", TradeCaptureReportExtend051);
REGISTER_MESSAGE(TradeCaptureReportMessageFactory, "060", TradeCaptureReportExtend060);
REGISTER_MESSAGE(TradeCaptureReportMessageFactory, "061", TradeCaptureReportExtend061);
REGISTER_MESSAGE(TradeCaptureReportMessageFactory, "062", TradeCaptureReportExtend062);


struct TradeCaptureReport : public codec::BinaryCodec {
    std::string applId;
    std::string submittingPbuid;
    std::string securityId;
    std::string securityIdsource;
    uint16_t ownerType;
    std::string clearingFirm;
    int64_t transactTime;
    std::string userInfo;
    std::string tradeReportId;
    uint8_t tradeReportType;
    uint8_t tradeReportTransType;
    std::string tradeHandlingInstr;
    std::string tradeReportRefId;
    int64_t lastPx;
    int64_t lastQty;
    uint16_t trdType;
    uint16_t trdSubType;
    uint32_t confirmId;
    std::string side;
    std::string pbuid;
    std::string accountId;
    std::string branchId;
    std::string counterPartyPbuid;
    std::string counterPartyAccountId;
    std::string counterPartyBranchId;
    std::unique_ptr<codec::BinaryCodec> applExtend;

    void encode(ByteBuf& buf) const override {
        codec::write_fixed_string(buf, applId, 3);
        codec::write_fixed_string(buf, submittingPbuid, 6);
        codec::write_fixed_string(buf, securityId, 8);
        codec::write_fixed_string(buf, securityIdsource, 4);
        buf.write_u16_le(ownerType);
        codec::write_fixed_string(buf, clearingFirm, 2);
        buf.write_i64_le(transactTime);
        codec::write_fixed_string(buf, userInfo, 32);
        codec::write_fixed_string(buf, tradeReportId, 10);
        buf.write_u8(tradeReportType);
        buf.write_u8(tradeReportTransType);
        codec::write_fixed_string(buf, tradeHandlingInstr, 1);
        codec::write_fixed_string(buf, tradeReportRefId, 10);
        buf.write_i64_le(lastPx);
        buf.write_i64_le(lastQty);
        buf.write_u16_le(trdType);
        buf.write_u16_le(trdSubType);
        buf.write_u32_le(confirmId);
        codec::write_fixed_string(buf, side, 1);
        codec::write_fixed_string(buf, pbuid, 6);
        codec::write_fixed_string(buf, accountId, 10);
        codec::write_fixed_string(buf, branchId, 2);
        codec::write_fixed_string(buf, counterPartyPbuid, 6);
        codec::write_fixed_string(buf, counterPartyAccountId, 10);
        codec::write_fixed_string(buf, counterPartyBranchId, 2);
        applExtend->encode(buf);
    }
    

    void decode(ByteBuf& buf) override {
        applId = codec::read_fixed_string(buf, 3);
        submittingPbuid = codec::read_fixed_string(buf, 6);
        securityId = codec::read_fixed_string(buf, 8);
        securityIdsource = codec::read_fixed_string(buf, 4);
        ownerType = buf.read_u16_le();
        clearingFirm = codec::read_fixed_string(buf, 2);
        transactTime = buf.read_i64_le();
        userInfo = codec::read_fixed_string(buf, 32);
        tradeReportId = codec::read_fixed_string(buf, 10);
        tradeReportType = buf.read_u8();
        tradeReportTransType = buf.read_u8();
        tradeHandlingInstr = codec::read_fixed_string(buf, 1);
        tradeReportRefId = codec::read_fixed_string(buf, 10);
        lastPx = buf.read_i64_le();
        lastQty = buf.read_i64_le();
        trdType = buf.read_u16_le();
        trdSubType = buf.read_u16_le();
        confirmId = buf.read_u32_le();
        side = codec::read_fixed_string(buf, 1);
        pbuid = codec::read_fixed_string(buf, 6);
        accountId = codec::read_fixed_string(buf, 10);
        branchId = codec::read_fixed_string(buf, 2);
        counterPartyPbuid = codec::read_fixed_string(buf, 6);
        counterPartyAccountId = codec::read_fixed_string(buf, 10);
        counterPartyBranchId = codec::read_fixed_string(buf, 2);
        applExtend = TradeCaptureReportMessageFactory::getInstance().create(applId);
        applExtend->decode(buf);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const TradeCaptureReport*>(&other);
        if(!checkType) return false;
        return applId == checkType->applId
               && submittingPbuid == checkType->submittingPbuid
               && securityId == checkType->securityId
               && securityIdsource == checkType->securityIdsource
               && ownerType == checkType->ownerType
               && clearingFirm == checkType->clearingFirm
               && transactTime == checkType->transactTime
               && userInfo == checkType->userInfo
               && tradeReportId == checkType->tradeReportId
               && tradeReportType == checkType->tradeReportType
               && tradeReportTransType == checkType->tradeReportTransType
               && tradeHandlingInstr == checkType->tradeHandlingInstr
               && tradeReportRefId == checkType->tradeReportRefId
               && lastPx == checkType->lastPx
               && lastQty == checkType->lastQty
               && trdType == checkType->trdType
               && trdSubType == checkType->trdSubType
               && confirmId == checkType->confirmId
               && side == checkType->side
               && pbuid == checkType->pbuid
               && accountId == checkType->accountId
               && branchId == checkType->branchId
               && counterPartyPbuid == checkType->counterPartyPbuid
               && counterPartyAccountId == checkType->counterPartyAccountId
               && counterPartyBranchId == checkType->counterPartyBranchId
               && applExtend->equals(*checkType->applExtend);
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "TradeCaptureReport { "
        << "ApplID: " << applId
        << ", "
        << "SubmittingPBUID: " << submittingPbuid
        << ", "
        << "SecurityID: " << securityId
        << ", "
        << "SecurityIDSource: " << securityIdsource
        << ", "
        << "OwnerType: " << std::to_string(ownerType)
        << ", "
        << "ClearingFirm: " << clearingFirm
        << ", "
        << "TransactTime: " << std::to_string(transactTime)
        << ", "
        << "UserInfo: " << userInfo
        << ", "
        << "TradeReportID: " << tradeReportId
        << ", "
        << "TradeReportType: " << static_cast<unsigned>(tradeReportType)
        << ", "
        << "TradeReportTransType: " << static_cast<unsigned>(tradeReportTransType)
        << ", "
        << "TradeHandlingInstr: " << tradeHandlingInstr
        << ", "
        << "TradeReportRefID: " << tradeReportRefId
        << ", "
        << "LastPx: " << std::to_string(lastPx)
        << ", "
        << "LastQty: " << std::to_string(lastQty)
        << ", "
        << "TrdType: " << std::to_string(trdType)
        << ", "
        << "TrdSubType: " << std::to_string(trdSubType)
        << ", "
        << "ConfirmID: " << std::to_string(confirmId)
        << ", "
        << "Side: " << side
        << ", "
        << "PBUID: " << pbuid
        << ", "
        << "AccountID: " << accountId
        << ", "
        << "BranchID: " << branchId
        << ", "
        << "CounterPartyPBUID: " << counterPartyPbuid
        << ", "
        << "CounterPartyAccountID: " << counterPartyAccountId
        << ", "
        << "CounterPartyBranchID: " << counterPartyBranchId
        << ", "
        << "ApplExtend: " << applExtend->toString()
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const TradeCaptureReport& pkt) {
    return os << pkt.toString();
}







struct TradeCaptureReportAckExtend031 : public codec::BinaryCodec {
    std::string memberId;
    std::string traderCode;
    std::string counterPartyMemberId;
    std::string counterPartyTraderCode;
    std::string settlType;
    std::string settlPeriod;
    std::string cashMargin;
    std::string memo;

    void encode(ByteBuf& buf) const override {
        codec::write_fixed_string(buf, memberId, 6);
        codec::write_fixed_string(buf, traderCode, 5);
        codec::write_fixed_string(buf, counterPartyMemberId, 6);
        codec::write_fixed_string(buf, counterPartyTraderCode, 5);
        codec::write_fixed_string(buf, settlType, 1);
        codec::write_fixed_string(buf, settlPeriod, 1);
        codec::write_fixed_string(buf, cashMargin, 1);
        codec::write_fixed_string(buf, memo, 120);
    }
    

    void decode(ByteBuf& buf) override {
        memberId = codec::read_fixed_string(buf, 6);
        traderCode = codec::read_fixed_string(buf, 5);
        counterPartyMemberId = codec::read_fixed_string(buf, 6);
        counterPartyTraderCode = codec::read_fixed_string(buf, 5);
        settlType = codec::read_fixed_string(buf, 1);
        settlPeriod = codec::read_fixed_string(buf, 1);
        cashMargin = codec::read_fixed_string(buf, 1);
        memo = codec::read_fixed_string(buf, 120);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const TradeCaptureReportAckExtend031*>(&other);
        if(!checkType) return false;
        return memberId == checkType->memberId
               && traderCode == checkType->traderCode
               && counterPartyMemberId == checkType->counterPartyMemberId
               && counterPartyTraderCode == checkType->counterPartyTraderCode
               && settlType == checkType->settlType
               && settlPeriod == checkType->settlPeriod
               && cashMargin == checkType->cashMargin
               && memo == checkType->memo;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "TradeCaptureReportAckExtend031 { "
        << "MemberID: " << memberId
        << ", "
        << "TraderCode: " << traderCode
        << ", "
        << "CounterPartyMemberID: " << counterPartyMemberId
        << ", "
        << "CounterPartyTraderCode: " << counterPartyTraderCode
        << ", "
        << "SettlType: " << settlType
        << ", "
        << "SettlPeriod: " << settlPeriod
        << ", "
        << "CashMargin: " << cashMargin
        << ", "
        << "Memo: " << memo
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const TradeCaptureReportAckExtend031& pkt) {
    return os << pkt.toString();
}


struct TradeCaptureReportAckExtend051 : public codec::BinaryCodec {
    uint16_t expirationDays;
    uint8_t expirationType;
    std::string shareProperty;

    void encode(ByteBuf& buf) const override {
        buf.write_u16_le(expirationDays);
        buf.write_u8(expirationType);
        codec::write_fixed_string(buf, shareProperty, 2);
    }
    

    void decode(ByteBuf& buf) override {
        expirationDays = buf.read_u16_le();
        expirationType = buf.read_u8();
        shareProperty = codec::read_fixed_string(buf, 2);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const TradeCaptureReportAckExtend051*>(&other);
        if(!checkType) return false;
        return expirationDays == checkType->expirationDays
               && expirationType == checkType->expirationType
               && shareProperty == checkType->shareProperty;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "TradeCaptureReportAckExtend051 { "
        << "ExpirationDays: " << std::to_string(expirationDays)
        << ", "
        << "ExpirationType: " << static_cast<unsigned>(expirationType)
        << ", "
        << "ShareProperty: " << shareProperty
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const TradeCaptureReportAckExtend051& pkt) {
    return os << pkt.toString();
}


struct TradeCaptureReportAckExtend060 : public codec::BinaryCodec {

    void encode(ByteBuf& buf) const override {
    }
    

    void decode(ByteBuf& buf) override {
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const TradeCaptureReportAckExtend060*>(&other);
        if(!checkType) return false;
        return true;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "TradeCaptureReportAckExtend060 { "
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const TradeCaptureReportAckExtend060& pkt) {
    return os << pkt.toString();
}


struct TradeCaptureReportAckExtend061 : public codec::BinaryCodec {

    void encode(ByteBuf& buf) const override {
    }
    

    void decode(ByteBuf& buf) override {
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const TradeCaptureReportAckExtend061*>(&other);
        if(!checkType) return false;
        return true;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "TradeCaptureReportAckExtend061 { "
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const TradeCaptureReportAckExtend061& pkt) {
    return os << pkt.toString();
}


struct TradeCaptureReportAckExtend062 : public codec::BinaryCodec {
    std::string cashMargin;

    void encode(ByteBuf& buf) const override {
        codec::write_fixed_string(buf, cashMargin, 1);
    }
    

    void decode(ByteBuf& buf) override {
        cashMargin = codec::read_fixed_string(buf, 1);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const TradeCaptureReportAckExtend062*>(&other);
        if(!checkType) return false;
        return cashMargin == checkType->cashMargin;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "TradeCaptureReportAckExtend062 { "
        << "CashMargin: " << cashMargin
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const TradeCaptureReportAckExtend062& pkt) {
    return os << pkt.toString();
}


struct TradeCaptureReportAckTag{};
using TradeCaptureReportAckMessageFactory = MessageFactory<std::string, codec::BinaryCodec, TradeCaptureReportAckTag>;
REGISTER_MESSAGE(TradeCaptureReportAckMessageFactory, "031", TradeCaptureReportAckExtend031);
REGISTER_MESSAGE(TradeCaptureReportAckMessageFactory, "051", TradeCaptureReportAckExtend051);
REGISTER_MESSAGE(TradeCaptureReportAckMessageFactory, "060", TradeCaptureReportAckExtend060);
REGISTER_MESSAGE(TradeCaptureReportAckMessageFactory, "061", TradeCaptureReportAckExtend061);
REGISTER_MESSAGE(TradeCaptureReportAckMessageFactory, "062", TradeCaptureReportAckExtend062);


struct TradeCaptureReportAck : public codec::BinaryCodec {
    int32_t partitionNo;
    int64_t reportIndex;
    std::string applId;
    std::string reportingPbuid;
    std::string submittingPbuid;
    std::string securityId;
    std::string securityIdsource;
    uint16_t ownerType;
    std::string clearingFirm;
    int64_t transactTime;
    std::string userInfo;
    std::string tradeId;
    std::string tradeReportId;
    uint8_t tradeReportType;
    uint8_t tradeReportTransType;
    std::string tradeHandlingInstr;
    std::string tradeReportRefId;
    uint8_t trdAckStatus;
    uint8_t trdRptStatus;
    uint16_t tradeReportRejectReason;
    int64_t lastPx;
    int64_t lastQty;
    uint16_t trdType;
    uint16_t trdSubType;
    uint32_t confirmId;
    std::string execId;
    std::string side;
    std::string pbuid;
    std::string accountId;
    std::string branchId;
    std::string counterPartyPbuid;
    std::string counterPartyAccountId;
    std::string counterPartyBranchId;
    std::unique_ptr<codec::BinaryCodec> applExtend;

    void encode(ByteBuf& buf) const override {
        buf.write_i32_le(partitionNo);
        buf.write_i64_le(reportIndex);
        codec::write_fixed_string(buf, applId, 3);
        codec::write_fixed_string(buf, reportingPbuid, 6);
        codec::write_fixed_string(buf, submittingPbuid, 6);
        codec::write_fixed_string(buf, securityId, 8);
        codec::write_fixed_string(buf, securityIdsource, 4);
        buf.write_u16_le(ownerType);
        codec::write_fixed_string(buf, clearingFirm, 2);
        buf.write_i64_le(transactTime);
        codec::write_fixed_string(buf, userInfo, 32);
        codec::write_fixed_string(buf, tradeId, 16);
        codec::write_fixed_string(buf, tradeReportId, 10);
        buf.write_u8(tradeReportType);
        buf.write_u8(tradeReportTransType);
        codec::write_fixed_string(buf, tradeHandlingInstr, 1);
        codec::write_fixed_string(buf, tradeReportRefId, 10);
        buf.write_u8(trdAckStatus);
        buf.write_u8(trdRptStatus);
        buf.write_u16_le(tradeReportRejectReason);
        buf.write_i64_le(lastPx);
        buf.write_i64_le(lastQty);
        buf.write_u16_le(trdType);
        buf.write_u16_le(trdSubType);
        buf.write_u32_le(confirmId);
        codec::write_fixed_string(buf, execId, 16);
        codec::write_fixed_string(buf, side, 1);
        codec::write_fixed_string(buf, pbuid, 6);
        codec::write_fixed_string(buf, accountId, 10);
        codec::write_fixed_string(buf, branchId, 2);
        codec::write_fixed_string(buf, counterPartyPbuid, 6);
        codec::write_fixed_string(buf, counterPartyAccountId, 10);
        codec::write_fixed_string(buf, counterPartyBranchId, 2);
        applExtend->encode(buf);
    }
    

    void decode(ByteBuf& buf) override {
        partitionNo = buf.read_i32_le();
        reportIndex = buf.read_i64_le();
        applId = codec::read_fixed_string(buf, 3);
        reportingPbuid = codec::read_fixed_string(buf, 6);
        submittingPbuid = codec::read_fixed_string(buf, 6);
        securityId = codec::read_fixed_string(buf, 8);
        securityIdsource = codec::read_fixed_string(buf, 4);
        ownerType = buf.read_u16_le();
        clearingFirm = codec::read_fixed_string(buf, 2);
        transactTime = buf.read_i64_le();
        userInfo = codec::read_fixed_string(buf, 32);
        tradeId = codec::read_fixed_string(buf, 16);
        tradeReportId = codec::read_fixed_string(buf, 10);
        tradeReportType = buf.read_u8();
        tradeReportTransType = buf.read_u8();
        tradeHandlingInstr = codec::read_fixed_string(buf, 1);
        tradeReportRefId = codec::read_fixed_string(buf, 10);
        trdAckStatus = buf.read_u8();
        trdRptStatus = buf.read_u8();
        tradeReportRejectReason = buf.read_u16_le();
        lastPx = buf.read_i64_le();
        lastQty = buf.read_i64_le();
        trdType = buf.read_u16_le();
        trdSubType = buf.read_u16_le();
        confirmId = buf.read_u32_le();
        execId = codec::read_fixed_string(buf, 16);
        side = codec::read_fixed_string(buf, 1);
        pbuid = codec::read_fixed_string(buf, 6);
        accountId = codec::read_fixed_string(buf, 10);
        branchId = codec::read_fixed_string(buf, 2);
        counterPartyPbuid = codec::read_fixed_string(buf, 6);
        counterPartyAccountId = codec::read_fixed_string(buf, 10);
        counterPartyBranchId = codec::read_fixed_string(buf, 2);
        applExtend = TradeCaptureReportAckMessageFactory::getInstance().create(applId);
        applExtend->decode(buf);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const TradeCaptureReportAck*>(&other);
        if(!checkType) return false;
        return partitionNo == checkType->partitionNo
               && reportIndex == checkType->reportIndex
               && applId == checkType->applId
               && reportingPbuid == checkType->reportingPbuid
               && submittingPbuid == checkType->submittingPbuid
               && securityId == checkType->securityId
               && securityIdsource == checkType->securityIdsource
               && ownerType == checkType->ownerType
               && clearingFirm == checkType->clearingFirm
               && transactTime == checkType->transactTime
               && userInfo == checkType->userInfo
               && tradeId == checkType->tradeId
               && tradeReportId == checkType->tradeReportId
               && tradeReportType == checkType->tradeReportType
               && tradeReportTransType == checkType->tradeReportTransType
               && tradeHandlingInstr == checkType->tradeHandlingInstr
               && tradeReportRefId == checkType->tradeReportRefId
               && trdAckStatus == checkType->trdAckStatus
               && trdRptStatus == checkType->trdRptStatus
               && tradeReportRejectReason == checkType->tradeReportRejectReason
               && lastPx == checkType->lastPx
               && lastQty == checkType->lastQty
               && trdType == checkType->trdType
               && trdSubType == checkType->trdSubType
               && confirmId == checkType->confirmId
               && execId == checkType->execId
               && side == checkType->side
               && pbuid == checkType->pbuid
               && accountId == checkType->accountId
               && branchId == checkType->branchId
               && counterPartyPbuid == checkType->counterPartyPbuid
               && counterPartyAccountId == checkType->counterPartyAccountId
               && counterPartyBranchId == checkType->counterPartyBranchId
               && applExtend->equals(*checkType->applExtend);
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "TradeCaptureReportAck { "
        << "PartitionNo: " << std::to_string(partitionNo)
        << ", "
        << "ReportIndex: " << std::to_string(reportIndex)
        << ", "
        << "ApplID: " << applId
        << ", "
        << "ReportingPBUID: " << reportingPbuid
        << ", "
        << "SubmittingPBUID: " << submittingPbuid
        << ", "
        << "SecurityID: " << securityId
        << ", "
        << "SecurityIDSource: " << securityIdsource
        << ", "
        << "OwnerType: " << std::to_string(ownerType)
        << ", "
        << "ClearingFirm: " << clearingFirm
        << ", "
        << "TransactTime: " << std::to_string(transactTime)
        << ", "
        << "UserInfo: " << userInfo
        << ", "
        << "TradeID: " << tradeId
        << ", "
        << "TradeReportID: " << tradeReportId
        << ", "
        << "TradeReportType: " << static_cast<unsigned>(tradeReportType)
        << ", "
        << "TradeReportTransType: " << static_cast<unsigned>(tradeReportTransType)
        << ", "
        << "TradeHandlingInstr: " << tradeHandlingInstr
        << ", "
        << "TradeReportRefID: " << tradeReportRefId
        << ", "
        << "TrdAckStatus: " << static_cast<unsigned>(trdAckStatus)
        << ", "
        << "TrdRptStatus: " << static_cast<unsigned>(trdRptStatus)
        << ", "
        << "TradeReportRejectReason: " << std::to_string(tradeReportRejectReason)
        << ", "
        << "LastPx: " << std::to_string(lastPx)
        << ", "
        << "LastQty: " << std::to_string(lastQty)
        << ", "
        << "TrdType: " << std::to_string(trdType)
        << ", "
        << "TrdSubType: " << std::to_string(trdSubType)
        << ", "
        << "ConfirmID: " << std::to_string(confirmId)
        << ", "
        << "ExecID: " << execId
        << ", "
        << "Side: " << side
        << ", "
        << "PBUID: " << pbuid
        << ", "
        << "AccountID: " << accountId
        << ", "
        << "BranchID: " << branchId
        << ", "
        << "CounterPartyPBUID: " << counterPartyPbuid
        << ", "
        << "CounterPartyAccountID: " << counterPartyAccountId
        << ", "
        << "CounterPartyBranchID: " << counterPartyBranchId
        << ", "
        << "ApplExtend: " << applExtend->toString()
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const TradeCaptureReportAck& pkt) {
    return os << pkt.toString();
}







struct TradeCaptureConfirmExtend031 : public codec::BinaryCodec {
    std::string memberId;
    std::string traderCode;
    std::string counterPartyMemberId;
    std::string counterPartyTraderCode;
    std::string settlType;
    std::string settlPeriod;
    std::string cashMargin;
    std::string memo;

    void encode(ByteBuf& buf) const override {
        codec::write_fixed_string(buf, memberId, 6);
        codec::write_fixed_string(buf, traderCode, 5);
        codec::write_fixed_string(buf, counterPartyMemberId, 6);
        codec::write_fixed_string(buf, counterPartyTraderCode, 5);
        codec::write_fixed_string(buf, settlType, 1);
        codec::write_fixed_string(buf, settlPeriod, 1);
        codec::write_fixed_string(buf, cashMargin, 1);
        codec::write_fixed_string(buf, memo, 120);
    }
    

    void decode(ByteBuf& buf) override {
        memberId = codec::read_fixed_string(buf, 6);
        traderCode = codec::read_fixed_string(buf, 5);
        counterPartyMemberId = codec::read_fixed_string(buf, 6);
        counterPartyTraderCode = codec::read_fixed_string(buf, 5);
        settlType = codec::read_fixed_string(buf, 1);
        settlPeriod = codec::read_fixed_string(buf, 1);
        cashMargin = codec::read_fixed_string(buf, 1);
        memo = codec::read_fixed_string(buf, 120);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const TradeCaptureConfirmExtend031*>(&other);
        if(!checkType) return false;
        return memberId == checkType->memberId
               && traderCode == checkType->traderCode
               && counterPartyMemberId == checkType->counterPartyMemberId
               && counterPartyTraderCode == checkType->counterPartyTraderCode
               && settlType == checkType->settlType
               && settlPeriod == checkType->settlPeriod
               && cashMargin == checkType->cashMargin
               && memo == checkType->memo;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "TradeCaptureConfirmExtend031 { "
        << "MemberID: " << memberId
        << ", "
        << "TraderCode: " << traderCode
        << ", "
        << "CounterPartyMemberID: " << counterPartyMemberId
        << ", "
        << "CounterPartyTraderCode: " << counterPartyTraderCode
        << ", "
        << "SettlType: " << settlType
        << ", "
        << "SettlPeriod: " << settlPeriod
        << ", "
        << "CashMargin: " << cashMargin
        << ", "
        << "Memo: " << memo
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const TradeCaptureConfirmExtend031& pkt) {
    return os << pkt.toString();
}


struct TradeCaptureConfirmExtend051 : public codec::BinaryCodec {
    uint16_t expirationDays;
    uint8_t expirationType;
    uint32_t maturityDate;
    std::string shareProperty;

    void encode(ByteBuf& buf) const override {
        buf.write_u16_le(expirationDays);
        buf.write_u8(expirationType);
        buf.write_u32_le(maturityDate);
        codec::write_fixed_string(buf, shareProperty, 2);
    }
    

    void decode(ByteBuf& buf) override {
        expirationDays = buf.read_u16_le();
        expirationType = buf.read_u8();
        maturityDate = buf.read_u32_le();
        shareProperty = codec::read_fixed_string(buf, 2);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const TradeCaptureConfirmExtend051*>(&other);
        if(!checkType) return false;
        return expirationDays == checkType->expirationDays
               && expirationType == checkType->expirationType
               && maturityDate == checkType->maturityDate
               && shareProperty == checkType->shareProperty;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "TradeCaptureConfirmExtend051 { "
        << "ExpirationDays: " << std::to_string(expirationDays)
        << ", "
        << "ExpirationType: " << static_cast<unsigned>(expirationType)
        << ", "
        << "MaturityDate: " << std::to_string(maturityDate)
        << ", "
        << "ShareProperty: " << shareProperty
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const TradeCaptureConfirmExtend051& pkt) {
    return os << pkt.toString();
}


struct TradeCaptureConfirmExtend060 : public codec::BinaryCodec {

    void encode(ByteBuf& buf) const override {
    }
    

    void decode(ByteBuf& buf) override {
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const TradeCaptureConfirmExtend060*>(&other);
        if(!checkType) return false;
        return true;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "TradeCaptureConfirmExtend060 { "
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const TradeCaptureConfirmExtend060& pkt) {
    return os << pkt.toString();
}


struct TradeCaptureConfirmExtend061 : public codec::BinaryCodec {

    void encode(ByteBuf& buf) const override {
    }
    

    void decode(ByteBuf& buf) override {
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const TradeCaptureConfirmExtend061*>(&other);
        if(!checkType) return false;
        return true;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "TradeCaptureConfirmExtend061 { "
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const TradeCaptureConfirmExtend061& pkt) {
    return os << pkt.toString();
}


struct TradeCaptureConfirmExtend062 : public codec::BinaryCodec {
    std::string cashMargin;

    void encode(ByteBuf& buf) const override {
        codec::write_fixed_string(buf, cashMargin, 1);
    }
    

    void decode(ByteBuf& buf) override {
        cashMargin = codec::read_fixed_string(buf, 1);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const TradeCaptureConfirmExtend062*>(&other);
        if(!checkType) return false;
        return cashMargin == checkType->cashMargin;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "TradeCaptureConfirmExtend062 { "
        << "CashMargin: " << cashMargin
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const TradeCaptureConfirmExtend062& pkt) {
    return os << pkt.toString();
}


struct TradeCaptureConfirmTag{};
using TradeCaptureConfirmMessageFactory = MessageFactory<std::string, codec::BinaryCodec, TradeCaptureConfirmTag>;
REGISTER_MESSAGE(TradeCaptureConfirmMessageFactory, "031", TradeCaptureConfirmExtend031);
REGISTER_MESSAGE(TradeCaptureConfirmMessageFactory, "051", TradeCaptureConfirmExtend051);
REGISTER_MESSAGE(TradeCaptureConfirmMessageFactory, "060", TradeCaptureConfirmExtend060);
REGISTER_MESSAGE(TradeCaptureConfirmMessageFactory, "061", TradeCaptureConfirmExtend061);
REGISTER_MESSAGE(TradeCaptureConfirmMessageFactory, "062", TradeCaptureConfirmExtend062);


struct TradeCaptureConfirm : public codec::BinaryCodec {
    int32_t partitionNo;
    int64_t reportIndex;
    std::string applId;
    std::string reportingPbuid;
    std::string submittingPbuid;
    std::string securityId;
    std::string securityIdsource;
    uint16_t ownerType;
    std::string clearingFirm;
    int64_t transactTime;
    std::string userInfo;
    std::string tradeId;
    std::string tradeReportId;
    uint8_t tradeReportType;
    uint8_t tradeReportTransType;
    std::string tradeHandlingInstr;
    int64_t lastPx;
    int64_t lastQty;
    uint16_t trdType;
    uint16_t trdSubType;
    uint32_t confirmId;
    std::string execId;
    std::string side;
    std::string pbuid;
    std::string accountId;
    std::string branchId;
    std::string counterPartyPbuid;
    std::string counterPartyAccountId;
    std::string counterPartyBranchId;
    std::unique_ptr<codec::BinaryCodec> applExtend;

    void encode(ByteBuf& buf) const override {
        buf.write_i32_le(partitionNo);
        buf.write_i64_le(reportIndex);
        codec::write_fixed_string(buf, applId, 3);
        codec::write_fixed_string(buf, reportingPbuid, 6);
        codec::write_fixed_string(buf, submittingPbuid, 6);
        codec::write_fixed_string(buf, securityId, 8);
        codec::write_fixed_string(buf, securityIdsource, 4);
        buf.write_u16_le(ownerType);
        codec::write_fixed_string(buf, clearingFirm, 2);
        buf.write_i64_le(transactTime);
        codec::write_fixed_string(buf, userInfo, 32);
        codec::write_fixed_string(buf, tradeId, 16);
        codec::write_fixed_string(buf, tradeReportId, 10);
        buf.write_u8(tradeReportType);
        buf.write_u8(tradeReportTransType);
        codec::write_fixed_string(buf, tradeHandlingInstr, 1);
        buf.write_i64_le(lastPx);
        buf.write_i64_le(lastQty);
        buf.write_u16_le(trdType);
        buf.write_u16_le(trdSubType);
        buf.write_u32_le(confirmId);
        codec::write_fixed_string(buf, execId, 16);
        codec::write_fixed_string(buf, side, 1);
        codec::write_fixed_string(buf, pbuid, 6);
        codec::write_fixed_string(buf, accountId, 10);
        codec::write_fixed_string(buf, branchId, 2);
        codec::write_fixed_string(buf, counterPartyPbuid, 6);
        codec::write_fixed_string(buf, counterPartyAccountId, 10);
        codec::write_fixed_string(buf, counterPartyBranchId, 2);
        applExtend->encode(buf);
    }
    

    void decode(ByteBuf& buf) override {
        partitionNo = buf.read_i32_le();
        reportIndex = buf.read_i64_le();
        applId = codec::read_fixed_string(buf, 3);
        reportingPbuid = codec::read_fixed_string(buf, 6);
        submittingPbuid = codec::read_fixed_string(buf, 6);
        securityId = codec::read_fixed_string(buf, 8);
        securityIdsource = codec::read_fixed_string(buf, 4);
        ownerType = buf.read_u16_le();
        clearingFirm = codec::read_fixed_string(buf, 2);
        transactTime = buf.read_i64_le();
        userInfo = codec::read_fixed_string(buf, 32);
        tradeId = codec::read_fixed_string(buf, 16);
        tradeReportId = codec::read_fixed_string(buf, 10);
        tradeReportType = buf.read_u8();
        tradeReportTransType = buf.read_u8();
        tradeHandlingInstr = codec::read_fixed_string(buf, 1);
        lastPx = buf.read_i64_le();
        lastQty = buf.read_i64_le();
        trdType = buf.read_u16_le();
        trdSubType = buf.read_u16_le();
        confirmId = buf.read_u32_le();
        execId = codec::read_fixed_string(buf, 16);
        side = codec::read_fixed_string(buf, 1);
        pbuid = codec::read_fixed_string(buf, 6);
        accountId = codec::read_fixed_string(buf, 10);
        branchId = codec::read_fixed_string(buf, 2);
        counterPartyPbuid = codec::read_fixed_string(buf, 6);
        counterPartyAccountId = codec::read_fixed_string(buf, 10);
        counterPartyBranchId = codec::read_fixed_string(buf, 2);
        applExtend = TradeCaptureConfirmMessageFactory::getInstance().create(applId);
        applExtend->decode(buf);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const TradeCaptureConfirm*>(&other);
        if(!checkType) return false;
        return partitionNo == checkType->partitionNo
               && reportIndex == checkType->reportIndex
               && applId == checkType->applId
               && reportingPbuid == checkType->reportingPbuid
               && submittingPbuid == checkType->submittingPbuid
               && securityId == checkType->securityId
               && securityIdsource == checkType->securityIdsource
               && ownerType == checkType->ownerType
               && clearingFirm == checkType->clearingFirm
               && transactTime == checkType->transactTime
               && userInfo == checkType->userInfo
               && tradeId == checkType->tradeId
               && tradeReportId == checkType->tradeReportId
               && tradeReportType == checkType->tradeReportType
               && tradeReportTransType == checkType->tradeReportTransType
               && tradeHandlingInstr == checkType->tradeHandlingInstr
               && lastPx == checkType->lastPx
               && lastQty == checkType->lastQty
               && trdType == checkType->trdType
               && trdSubType == checkType->trdSubType
               && confirmId == checkType->confirmId
               && execId == checkType->execId
               && side == checkType->side
               && pbuid == checkType->pbuid
               && accountId == checkType->accountId
               && branchId == checkType->branchId
               && counterPartyPbuid == checkType->counterPartyPbuid
               && counterPartyAccountId == checkType->counterPartyAccountId
               && counterPartyBranchId == checkType->counterPartyBranchId
               && applExtend->equals(*checkType->applExtend);
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "TradeCaptureConfirm { "
        << "PartitionNo: " << std::to_string(partitionNo)
        << ", "
        << "ReportIndex: " << std::to_string(reportIndex)
        << ", "
        << "ApplID: " << applId
        << ", "
        << "ReportingPBUID: " << reportingPbuid
        << ", "
        << "SubmittingPBUID: " << submittingPbuid
        << ", "
        << "SecurityID: " << securityId
        << ", "
        << "SecurityIDSource: " << securityIdsource
        << ", "
        << "OwnerType: " << std::to_string(ownerType)
        << ", "
        << "ClearingFirm: " << clearingFirm
        << ", "
        << "TransactTime: " << std::to_string(transactTime)
        << ", "
        << "UserInfo: " << userInfo
        << ", "
        << "TradeID: " << tradeId
        << ", "
        << "TradeReportID: " << tradeReportId
        << ", "
        << "TradeReportType: " << static_cast<unsigned>(tradeReportType)
        << ", "
        << "TradeReportTransType: " << static_cast<unsigned>(tradeReportTransType)
        << ", "
        << "TradeHandlingInstr: " << tradeHandlingInstr
        << ", "
        << "LastPx: " << std::to_string(lastPx)
        << ", "
        << "LastQty: " << std::to_string(lastQty)
        << ", "
        << "TrdType: " << std::to_string(trdType)
        << ", "
        << "TrdSubType: " << std::to_string(trdSubType)
        << ", "
        << "ConfirmID: " << std::to_string(confirmId)
        << ", "
        << "ExecID: " << execId
        << ", "
        << "Side: " << side
        << ", "
        << "PBUID: " << pbuid
        << ", "
        << "AccountID: " << accountId
        << ", "
        << "BranchID: " << branchId
        << ", "
        << "CounterPartyPBUID: " << counterPartyPbuid
        << ", "
        << "CounterPartyAccountID: " << counterPartyAccountId
        << ", "
        << "CounterPartyBranchID: " << counterPartyBranchId
        << ", "
        << "ApplExtend: " << applExtend->toString()
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const TradeCaptureConfirm& pkt) {
    return os << pkt.toString();
}







struct BusinessReject : public codec::BinaryCodec {
    std::string applId;
    int64_t transactTime;
    std::string submittingPbuid;
    std::string securityId;
    std::string securityIdsource;
    int64_t refSeqNum;
    uint32_t refMsgType;
    std::string businessRejectRefId;
    uint16_t businessRejectReason;
    std::string businessRejectText;

    void encode(ByteBuf& buf) const override {
        codec::write_fixed_string(buf, applId, 3);
        buf.write_i64_le(transactTime);
        codec::write_fixed_string(buf, submittingPbuid, 6);
        codec::write_fixed_string(buf, securityId, 8);
        codec::write_fixed_string(buf, securityIdsource, 4);
        buf.write_i64_le(refSeqNum);
        buf.write_u32_le(refMsgType);
        codec::write_fixed_string(buf, businessRejectRefId, 10);
        buf.write_u16_le(businessRejectReason);
        codec::write_fixed_string(buf, businessRejectText, 50);
    }
    

    void decode(ByteBuf& buf) override {
        applId = codec::read_fixed_string(buf, 3);
        transactTime = buf.read_i64_le();
        submittingPbuid = codec::read_fixed_string(buf, 6);
        securityId = codec::read_fixed_string(buf, 8);
        securityIdsource = codec::read_fixed_string(buf, 4);
        refSeqNum = buf.read_i64_le();
        refMsgType = buf.read_u32_le();
        businessRejectRefId = codec::read_fixed_string(buf, 10);
        businessRejectReason = buf.read_u16_le();
        businessRejectText = codec::read_fixed_string(buf, 50);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const BusinessReject*>(&other);
        if(!checkType) return false;
        return applId == checkType->applId
               && transactTime == checkType->transactTime
               && submittingPbuid == checkType->submittingPbuid
               && securityId == checkType->securityId
               && securityIdsource == checkType->securityIdsource
               && refSeqNum == checkType->refSeqNum
               && refMsgType == checkType->refMsgType
               && businessRejectRefId == checkType->businessRejectRefId
               && businessRejectReason == checkType->businessRejectReason
               && businessRejectText == checkType->businessRejectText;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "BusinessReject { "
        << "ApplID: " << applId
        << ", "
        << "TransactTime: " << std::to_string(transactTime)
        << ", "
        << "SubmittingPBUID: " << submittingPbuid
        << ", "
        << "SecurityID: " << securityId
        << ", "
        << "SecurityIDSource: " << securityIdsource
        << ", "
        << "RefSeqNum: " << std::to_string(refSeqNum)
        << ", "
        << "RefMsgType: " << std::to_string(refMsgType)
        << ", "
        << "BusinessRejectRefID: " << businessRejectRefId
        << ", "
        << "BusinessRejectReason: " << std::to_string(businessRejectReason)
        << ", "
        << "BusinessRejectText: " << businessRejectText
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const BusinessReject& pkt) {
    return os << pkt.toString();
}


struct ReportPartitionSync : public codec::BinaryCodec {
    int32_t partitionNo;
    int64_t reportIndex;

    void encode(ByteBuf& buf) const override {
        buf.write_i32_le(partitionNo);
        buf.write_i64_le(reportIndex);
    }
    

    void decode(ByteBuf& buf) override {
        partitionNo = buf.read_i32_le();
        reportIndex = buf.read_i64_le();
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const ReportPartitionSync*>(&other);
        if(!checkType) return false;
        return partitionNo == checkType->partitionNo
               && reportIndex == checkType->reportIndex;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "ReportPartitionSync { "
        << "PartitionNo: " << std::to_string(partitionNo)
        << ", "
        << "ReportIndex: " << std::to_string(reportIndex)
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const ReportPartitionSync& pkt) {
    return os << pkt.toString();
}


struct ReportSynchronization : public codec::BinaryCodec {
    std::vector<ReportPartitionSync> reportPartitionSync;

    void encode(ByteBuf& buf) const override {
        codec::write_object_List_le<uint16_t>(buf,reportPartitionSync);
    }
    

    void decode(ByteBuf& buf) override {
        reportPartitionSync = codec::read_object_List_le<uint16_t,ReportPartitionSync>(buf);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const ReportSynchronization*>(&other);
        if(!checkType) return false;
        return reportPartitionSync == checkType->reportPartitionSync;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "ReportSynchronization { "
        << "ReportPartitionSync: " << codec::join_vector<ReportPartitionSync>(reportPartitionSync)
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const ReportSynchronization& pkt) {
    return os << pkt.toString();
}


struct TradingSessionStatus : public codec::BinaryCodec {
    std::string marketId;
    std::string marketSegmentId;
    std::string tradingSessionId;
    std::string tradingSessionSubId;
    uint8_t tradSesStatus;
    int64_t tradSesStartTime;

    void encode(ByteBuf& buf) const override {
        codec::write_fixed_string(buf, marketId, 3);
        codec::write_fixed_string(buf, marketSegmentId, 3);
        codec::write_fixed_string(buf, tradingSessionId, 3);
        codec::write_fixed_string(buf, tradingSessionSubId, 3);
        buf.write_u8(tradSesStatus);
        buf.write_i64_le(tradSesStartTime);
    }
    

    void decode(ByteBuf& buf) override {
        marketId = codec::read_fixed_string(buf, 3);
        marketSegmentId = codec::read_fixed_string(buf, 3);
        tradingSessionId = codec::read_fixed_string(buf, 3);
        tradingSessionSubId = codec::read_fixed_string(buf, 3);
        tradSesStatus = buf.read_u8();
        tradSesStartTime = buf.read_i64_le();
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const TradingSessionStatus*>(&other);
        if(!checkType) return false;
        return marketId == checkType->marketId
               && marketSegmentId == checkType->marketSegmentId
               && tradingSessionId == checkType->tradingSessionId
               && tradingSessionSubId == checkType->tradingSessionSubId
               && tradSesStatus == checkType->tradSesStatus
               && tradSesStartTime == checkType->tradSesStartTime;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "TradingSessionStatus { "
        << "MarketID: " << marketId
        << ", "
        << "MarketSegmentID: " << marketSegmentId
        << ", "
        << "TradingSessionID: " << tradingSessionId
        << ", "
        << "TradingSessionSubID: " << tradingSessionSubId
        << ", "
        << "TradSesStatus: " << static_cast<unsigned>(tradSesStatus)
        << ", "
        << "TradSesStartTime: " << std::to_string(tradSesStartTime)
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const TradingSessionStatus& pkt) {
    return os << pkt.toString();
}


struct PlatformStateInfo : public codec::BinaryCodec {
    uint16_t platformId;
    uint16_t platformState;

    void encode(ByteBuf& buf) const override {
        buf.write_u16_le(platformId);
        buf.write_u16_le(platformState);
    }
    

    void decode(ByteBuf& buf) override {
        platformId = buf.read_u16_le();
        platformState = buf.read_u16_le();
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const PlatformStateInfo*>(&other);
        if(!checkType) return false;
        return platformId == checkType->platformId
               && platformState == checkType->platformState;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "PlatformStateInfo { "
        << "PlatformID: " << std::to_string(platformId)
        << ", "
        << "PlatformState: " << std::to_string(platformState)
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const PlatformStateInfo& pkt) {
    return os << pkt.toString();
}


struct ReportFinished : public codec::BinaryCodec {
    int32_t partitionNo;
    int64_t reportIndex;
    uint16_t platformId;

    void encode(ByteBuf& buf) const override {
        buf.write_i32_le(partitionNo);
        buf.write_i64_le(reportIndex);
        buf.write_u16_le(platformId);
    }
    

    void decode(ByteBuf& buf) override {
        partitionNo = buf.read_i32_le();
        reportIndex = buf.read_i64_le();
        platformId = buf.read_u16_le();
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const ReportFinished*>(&other);
        if(!checkType) return false;
        return partitionNo == checkType->partitionNo
               && reportIndex == checkType->reportIndex
               && platformId == checkType->platformId;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "ReportFinished { "
        << "PartitionNo: " << std::to_string(partitionNo)
        << ", "
        << "ReportIndex: " << std::to_string(reportIndex)
        << ", "
        << "PlatformID: " << std::to_string(platformId)
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const ReportFinished& pkt) {
    return os << pkt.toString();
}


struct NoPartitions : public codec::BinaryCodec {
    int32_t partitionNo;
    std::string partitionName;

    void encode(ByteBuf& buf) const override {
        buf.write_i32_le(partitionNo);
        codec::write_fixed_string(buf, partitionName, 20);
    }
    

    void decode(ByteBuf& buf) override {
        partitionNo = buf.read_i32_le();
        partitionName = codec::read_fixed_string(buf, 20);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const NoPartitions*>(&other);
        if(!checkType) return false;
        return partitionNo == checkType->partitionNo
               && partitionName == checkType->partitionName;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "NoPartitions { "
        << "PartitionNo: " << std::to_string(partitionNo)
        << ", "
        << "PartitionName: " << partitionName
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const NoPartitions& pkt) {
    return os << pkt.toString();
}


struct PlatformInfo : public codec::BinaryCodec {
    uint16_t platformId;
    std::vector<NoPartitions> noPartitions;

    void encode(ByteBuf& buf) const override {
        buf.write_u16_le(platformId);
        codec::write_object_List_le<uint16_t>(buf,noPartitions);
    }
    

    void decode(ByteBuf& buf) override {
        platformId = buf.read_u16_le();
        noPartitions = codec::read_object_List_le<uint16_t,NoPartitions>(buf);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const PlatformInfo*>(&other);
        if(!checkType) return false;
        return platformId == checkType->platformId
               && noPartitions == checkType->noPartitions;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "PlatformInfo { "
        << "PlatformID: " << std::to_string(platformId)
        << ", "
        << "NoPartitions: " << codec::join_vector<NoPartitions>(noPartitions)
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const PlatformInfo& pkt) {
    return os << pkt.toString();
}


struct BjseBinaryTag{};
using BjseBinaryMessageFactory = MessageFactory<uint32_t, codec::BinaryCodec, BjseBinaryTag>;
REGISTER_MESSAGE(BjseBinaryMessageFactory, 1, Logon);
REGISTER_MESSAGE(BjseBinaryMessageFactory, 2, Logout);
REGISTER_MESSAGE(BjseBinaryMessageFactory, 3, Heartbeat);
REGISTER_MESSAGE(BjseBinaryMessageFactory, 101000, NewOrder);
REGISTER_MESSAGE(BjseBinaryMessageFactory, 102000, OrderCancelRequest);
REGISTER_MESSAGE(BjseBinaryMessageFactory, 201000, CancelReject);
REGISTER_MESSAGE(BjseBinaryMessageFactory, 202010, ExecutionConfirm);
REGISTER_MESSAGE(BjseBinaryMessageFactory, 203010, ExecutionReport);
REGISTER_MESSAGE(BjseBinaryMessageFactory, 5, ReportSynchronization);
REGISTER_MESSAGE(BjseBinaryMessageFactory, 6, PlatformStateInfo);
REGISTER_MESSAGE(BjseBinaryMessageFactory, 7, ReportFinished);


struct BjseBinary : public codec::BinaryCodec {
    uint32_t msgType;
    uint32_t bodyLength;
    std::unique_ptr<codec::BinaryCodec> body;
    uint32_t checksum;

    void encode(ByteBuf& buf) const override {
        buf.write_u32_le(msgType);
        buf.write_u32_le(bodyLength);
        body->encode(buf);
        buf.write_u32_le(checksum);
    }
    

    void decode(ByteBuf& buf) override {
        msgType = buf.read_u32_le();
        bodyLength = buf.read_u32_le();
        body = BjseBinaryMessageFactory::getInstance().create(msgType);
        body->decode(buf);
        checksum = buf.read_u32_le();
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const BjseBinary*>(&other);
        if(!checkType) return false;
        return msgType == checkType->msgType
               && bodyLength == checkType->bodyLength
               && body->equals(*checkType->body)
               && checksum == checkType->checksum;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "BjseBinary { "
        << "MsgType: " << std::to_string(msgType)
        << ", "
        << "BodyLength: " << std::to_string(bodyLength)
        << ", "
        << "Body: " << body->toString()
        << ", "
        << "Checksum: " << std::to_string(checksum)
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const BjseBinary& pkt) {
    return os << pkt.toString();
}


