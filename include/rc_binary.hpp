// Copyright 2025 xinchentechnote
// Code generated by fin-protoc. DO NOT EDIT.
#pragma once
#include <cstdint>
#include <functional>
#include <iomanip>
#include <memory>
#include <string>
#include <unordered_map>
#include <vector>
#include <iostream>
#include "include/codec.hpp"
#include "include/bytebuf.hpp"
#include "include/checksum.hpp"
#include "message_factory.hpp"

struct NewOrder : public codec::BinaryCodec {
    std::string uniqueOrderId;
    std::string clOrdId;
    std::string securityId;
    std::string side;
    uint64_t price;
    uint64_t orderQty;
    std::string ordType;
    std::string account;

    void encode(ByteBuf& buf) const override {
        codec::write_string<uint32_t>(buf, uniqueOrderId);
        codec::write_string<uint32_t>(buf, clOrdId);
        codec::write_string<uint32_t>(buf, securityId);
        codec::write_fixed_string(buf, side, 1);
        buf.write_u64(price);
        buf.write_u64(orderQty);
        codec::write_fixed_string(buf, ordType, 1);
        codec::write_string<uint32_t>(buf, account);
    }
    

    void decode(ByteBuf& buf) override {
        uniqueOrderId = codec::read_string<uint32_t>(buf);
        clOrdId = codec::read_string<uint32_t>(buf);
        securityId = codec::read_string<uint32_t>(buf);
        side = codec::read_fixed_string(buf, 1);
        price = buf.read_u64();
        orderQty = buf.read_u64();
        ordType = codec::read_fixed_string(buf, 1);
        account = codec::read_string<uint32_t>(buf);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const NewOrder*>(&other);
        if(!checkType) return false;
        return uniqueOrderId == checkType->uniqueOrderId
               && clOrdId == checkType->clOrdId
               && securityId == checkType->securityId
               && side == checkType->side
               && price == checkType->price
               && orderQty == checkType->orderQty
               && ordType == checkType->ordType
               && account == checkType->account;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "NewOrder { "
        << "UniqueOrderID: " << uniqueOrderId
        << ", "
        << "ClOrdID: " << clOrdId
        << ", "
        << "SecurityID: " << securityId
        << ", "
        << "Side: " << side
        << ", "
        << "Price: " << std::to_string(price)
        << ", "
        << "OrderQty: " << std::to_string(orderQty)
        << ", "
        << "OrdType: " << ordType
        << ", "
        << "Account: " << account
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const NewOrder& pkt) {
    return os << pkt.toString();
}


struct OrderConfirm : public codec::BinaryCodec {
    std::string uniqueOrderId;
    std::string uniqueOrigOrderId;
    std::string clOrdId;
    std::string execType;
    uint32_t ordRejReason;
    std::string ordCnfmId;

    void encode(ByteBuf& buf) const override {
        codec::write_string<uint32_t>(buf, uniqueOrderId);
        codec::write_string<uint32_t>(buf, uniqueOrigOrderId);
        codec::write_string<uint32_t>(buf, clOrdId);
        codec::write_fixed_string(buf, execType, 1);
        buf.write_u32(ordRejReason);
        codec::write_string<uint32_t>(buf, ordCnfmId);
    }
    

    void decode(ByteBuf& buf) override {
        uniqueOrderId = codec::read_string<uint32_t>(buf);
        uniqueOrigOrderId = codec::read_string<uint32_t>(buf);
        clOrdId = codec::read_string<uint32_t>(buf);
        execType = codec::read_fixed_string(buf, 1);
        ordRejReason = buf.read_u32();
        ordCnfmId = codec::read_string<uint32_t>(buf);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const OrderConfirm*>(&other);
        if(!checkType) return false;
        return uniqueOrderId == checkType->uniqueOrderId
               && uniqueOrigOrderId == checkType->uniqueOrigOrderId
               && clOrdId == checkType->clOrdId
               && execType == checkType->execType
               && ordRejReason == checkType->ordRejReason
               && ordCnfmId == checkType->ordCnfmId;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "OrderConfirm { "
        << "UniqueOrderID: " << uniqueOrderId
        << ", "
        << "UniqueOrigOrderID: " << uniqueOrigOrderId
        << ", "
        << "ClOrdID: " << clOrdId
        << ", "
        << "ExecType: " << execType
        << ", "
        << "OrdRejReason: " << std::to_string(ordRejReason)
        << ", "
        << "OrdCnfmID: " << ordCnfmId
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const OrderConfirm& pkt) {
    return os << pkt.toString();
}


struct ExecutionReport : public codec::BinaryCodec {
    std::string uniqueOrderId;
    std::string clOrdId;
    std::string ordCnfmId;
    uint64_t lastPx;
    uint64_t lastQty;
    std::string ordStatus;

    void encode(ByteBuf& buf) const override {
        codec::write_string<uint32_t>(buf, uniqueOrderId);
        codec::write_string<uint32_t>(buf, clOrdId);
        codec::write_string<uint32_t>(buf, ordCnfmId);
        buf.write_u64(lastPx);
        buf.write_u64(lastQty);
        codec::write_fixed_string(buf, ordStatus, 1);
    }
    

    void decode(ByteBuf& buf) override {
        uniqueOrderId = codec::read_string<uint32_t>(buf);
        clOrdId = codec::read_string<uint32_t>(buf);
        ordCnfmId = codec::read_string<uint32_t>(buf);
        lastPx = buf.read_u64();
        lastQty = buf.read_u64();
        ordStatus = codec::read_fixed_string(buf, 1);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const ExecutionReport*>(&other);
        if(!checkType) return false;
        return uniqueOrderId == checkType->uniqueOrderId
               && clOrdId == checkType->clOrdId
               && ordCnfmId == checkType->ordCnfmId
               && lastPx == checkType->lastPx
               && lastQty == checkType->lastQty
               && ordStatus == checkType->ordStatus;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "ExecutionReport { "
        << "UniqueOrderID: " << uniqueOrderId
        << ", "
        << "ClOrdID: " << clOrdId
        << ", "
        << "OrdCnfmID: " << ordCnfmId
        << ", "
        << "LastPx: " << std::to_string(lastPx)
        << ", "
        << "LastQty: " << std::to_string(lastQty)
        << ", "
        << "OrdStatus: " << ordStatus
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const ExecutionReport& pkt) {
    return os << pkt.toString();
}


struct OrderCancel : public codec::BinaryCodec {
    std::string uniqueOrderId;
    std::string uniqueOrigOrderId;
    std::string clOrdId;
    std::string origClOrdId;
    std::string securityId;

    void encode(ByteBuf& buf) const override {
        codec::write_string<uint32_t>(buf, uniqueOrderId);
        codec::write_string<uint32_t>(buf, uniqueOrigOrderId);
        codec::write_string<uint32_t>(buf, clOrdId);
        codec::write_string<uint32_t>(buf, origClOrdId);
        codec::write_string<uint32_t>(buf, securityId);
    }
    

    void decode(ByteBuf& buf) override {
        uniqueOrderId = codec::read_string<uint32_t>(buf);
        uniqueOrigOrderId = codec::read_string<uint32_t>(buf);
        clOrdId = codec::read_string<uint32_t>(buf);
        origClOrdId = codec::read_string<uint32_t>(buf);
        securityId = codec::read_string<uint32_t>(buf);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const OrderCancel*>(&other);
        if(!checkType) return false;
        return uniqueOrderId == checkType->uniqueOrderId
               && uniqueOrigOrderId == checkType->uniqueOrigOrderId
               && clOrdId == checkType->clOrdId
               && origClOrdId == checkType->origClOrdId
               && securityId == checkType->securityId;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "OrderCancel { "
        << "UniqueOrderID: " << uniqueOrderId
        << ", "
        << "UniqueOrigOrderID: " << uniqueOrigOrderId
        << ", "
        << "ClOrdID: " << clOrdId
        << ", "
        << "OrigClOrdID: " << origClOrdId
        << ", "
        << "SecurityID: " << securityId
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const OrderCancel& pkt) {
    return os << pkt.toString();
}


struct CancelReject : public codec::BinaryCodec {
    std::string uniqueOrderId;
    std::string uniqueOrigOrderId;
    std::string clOrdId;
    std::string origClOrdId;
    uint32_t cxlRejReason;

    void encode(ByteBuf& buf) const override {
        codec::write_string<uint32_t>(buf, uniqueOrderId);
        codec::write_string<uint32_t>(buf, uniqueOrigOrderId);
        codec::write_string<uint32_t>(buf, clOrdId);
        codec::write_string<uint32_t>(buf, origClOrdId);
        buf.write_u32(cxlRejReason);
    }
    

    void decode(ByteBuf& buf) override {
        uniqueOrderId = codec::read_string<uint32_t>(buf);
        uniqueOrigOrderId = codec::read_string<uint32_t>(buf);
        clOrdId = codec::read_string<uint32_t>(buf);
        origClOrdId = codec::read_string<uint32_t>(buf);
        cxlRejReason = buf.read_u32();
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const CancelReject*>(&other);
        if(!checkType) return false;
        return uniqueOrderId == checkType->uniqueOrderId
               && uniqueOrigOrderId == checkType->uniqueOrigOrderId
               && clOrdId == checkType->clOrdId
               && origClOrdId == checkType->origClOrdId
               && cxlRejReason == checkType->cxlRejReason;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "CancelReject { "
        << "UniqueOrderID: " << uniqueOrderId
        << ", "
        << "UniqueOrigOrderID: " << uniqueOrigOrderId
        << ", "
        << "ClOrdID: " << clOrdId
        << ", "
        << "OrigClOrdID: " << origClOrdId
        << ", "
        << "CxlRejReason: " << std::to_string(cxlRejReason)
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const CancelReject& pkt) {
    return os << pkt.toString();
}


struct RiskResult : public codec::BinaryCodec {
    std::string uniqueOrderId;
    uint8_t riskStatus;
    std::string riskReason;

    void encode(ByteBuf& buf) const override {
        codec::write_string<uint32_t>(buf, uniqueOrderId);
        buf.write_u8(riskStatus);
        codec::write_string<uint32_t>(buf, riskReason);
    }
    

    void decode(ByteBuf& buf) override {
        uniqueOrderId = codec::read_string<uint32_t>(buf);
        riskStatus = buf.read_u8();
        riskReason = codec::read_string<uint32_t>(buf);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const RiskResult*>(&other);
        if(!checkType) return false;
        return uniqueOrderId == checkType->uniqueOrderId
               && riskStatus == checkType->riskStatus
               && riskReason == checkType->riskReason;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "RiskResult { "
        << "UniqueOrderID: " << uniqueOrderId
        << ", "
        << "RiskStatus: " << static_cast<unsigned>(riskStatus)
        << ", "
        << "RiskReason: " << riskReason
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const RiskResult& pkt) {
    return os << pkt.toString();
}


struct RcBinaryTag{};
using RcBinaryMessageFactory = MessageFactory<uint32_t, codec::BinaryCodec, RcBinaryTag>;
REGISTER_MESSAGE(RcBinaryMessageFactory, 100101, NewOrder);
REGISTER_MESSAGE(RcBinaryMessageFactory, 200102, OrderConfirm);
REGISTER_MESSAGE(RcBinaryMessageFactory, 200115, ExecutionReport);
REGISTER_MESSAGE(RcBinaryMessageFactory, 190007, OrderCancel);
REGISTER_MESSAGE(RcBinaryMessageFactory, 290008, CancelReject);
REGISTER_MESSAGE(RcBinaryMessageFactory, 800001, RiskResult);


struct RcBinary : public codec::BinaryCodec {
    uint32_t msgType;
    uint32_t version;
    uint32_t msgBodyLen;
    std::unique_ptr<codec::BinaryCodec> body;

    void encode(ByteBuf& buf) const override {
        buf.write_u32(msgType);
        buf.write_u32(version);
        auto msgBodyLenPos = buf.writer_index();
        buf.write_u32(0);
        auto bodyStart = buf.writer_index();
        body->encode(buf);
        auto bodyEnd = buf.writer_index();
        auto bodyLen_ = static_cast<unsigned int>(bodyEnd - bodyStart);
        buf.write_u32_at(msgBodyLenPos, bodyLen_);
    }
    

    void decode(ByteBuf& buf) override {
        msgType = buf.read_u32();
        version = buf.read_u32();
        msgBodyLen = buf.read_u32();
        body = RcBinaryMessageFactory::getInstance().create(msgType);
        body->decode(buf);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const RcBinary*>(&other);
        if(!checkType) return false;
        return msgType == checkType->msgType
               && version == checkType->version
               && msgBodyLen == checkType->msgBodyLen
               && body->equals(*checkType->body);
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "RcBinary { "
        << "MsgType: " << std::to_string(msgType)
        << ", "
        << "Version: " << std::to_string(version)
        << ", "
        << "MsgBodyLen: " << std::to_string(msgBodyLen)
        << ", "
        << "Body: " << body->toString()
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const RcBinary& pkt) {
    return os << pkt.toString();
}


