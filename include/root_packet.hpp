// Copyright 2025 xinchentechnote
// Code generated by fin-protoc. DO NOT EDIT.
#pragma once
#include <cstdint>
#include <functional>
#include <iomanip>
#include <memory>
#include <string>
#include <unordered_map>
#include <vector>
#include <iostream>
#include "include/codec.hpp"
#include "include/bytebuf.hpp"
#include "include/checksum.hpp"

struct BasicPacket : public codec::BinaryCodec {
    int8_t fieldI8;
    int16_t fieldI16;
    int32_t fieldI32;
    int64_t fieldI64;
    std::string fieldChar;
    uint8_t fieldU8;
    uint16_t fieldU16;
    uint32_t fieldU32;
    uint64_t fieldU64;
    float fieldF32;
    double fieldF64;
    std::vector<int8_t> fieldI8List;
    std::vector<int16_t> fieldI16List;
    std::vector<int32_t> fieldI32List;
    std::vector<int64_t> fieldI64List;
    std::vector<std::string> fieldCharList;
    std::vector<uint8_t> fieldU8List;
    std::vector<uint16_t> fieldU16List;
    std::vector<uint32_t> fieldU32List;
    std::vector<uint64_t> fieldU64List;
    std::vector<float> fieldF32List;
    std::vector<double> fieldF64List;

    void encode(ByteBuf& buf) const override {
        buf.write_i8(fieldI8);
        buf.write_i16_le(fieldI16);
        buf.write_i32_le(fieldI32);
        buf.write_i64_le(fieldI64);
        codec::put_fixed_string(buf, fieldChar, 1);
        buf.write_u8(fieldU8);
        buf.write_u16_le(fieldU16);
        buf.write_u32_le(fieldU32);
        buf.write_u64_le(fieldU64);
        buf.write_f32_le(fieldF32);
        buf.write_f64_le(fieldF64);
        codec::put_basic_type_le<uint16_t,int8_t>(buf,fieldI8List);
        codec::put_basic_type_le<uint16_t,int16_t>(buf,fieldI16List);
        codec::put_basic_type_le<uint16_t,int32_t>(buf,fieldI32List);
        codec::put_basic_type_le<uint16_t,int64_t>(buf,fieldI64List);
        codec::put_fixed_string_list_le<uint16_t>(buf, fieldCharList, 1);
        codec::put_basic_type_le<uint16_t,uint8_t>(buf,fieldU8List);
        codec::put_basic_type_le<uint16_t,uint16_t>(buf,fieldU16List);
        codec::put_basic_type_le<uint16_t,uint32_t>(buf,fieldU32List);
        codec::put_basic_type_le<uint16_t,uint64_t>(buf,fieldU64List);
        codec::put_basic_type_le<uint16_t,float>(buf,fieldF32List);
        codec::put_basic_type_le<uint16_t,double>(buf,fieldF64List);
    }
    

    void decode(ByteBuf& buf) override {
        fieldI8 = buf.read_i8();
        fieldI16 = buf.read_i16_le();
        fieldI32 = buf.read_i32_le();
        fieldI64 = buf.read_i64_le();
        fieldChar = codec::get_fixed_string(buf, 1);
        fieldU8 = buf.read_u8();
        fieldU16 = buf.read_u16_le();
        fieldU32 = buf.read_u32_le();
        fieldU64 = buf.read_u64_le();
        fieldF32 = buf.read_f32_le();
        fieldF64 = buf.read_f64_le();
        fieldI8List = codec::get_basic_type_le<uint16_t,int8_t>(buf);
        fieldI16List = codec::get_basic_type_le<uint16_t,int16_t>(buf);
        fieldI32List = codec::get_basic_type_le<uint16_t,int32_t>(buf);
        fieldI64List = codec::get_basic_type_le<uint16_t,int64_t>(buf);
        fieldCharList = codec::get_fixed_string_list_le<uint16_t>(buf, 1);
        fieldU8List = codec::get_basic_type_le<uint16_t,uint8_t>(buf);
        fieldU16List = codec::get_basic_type_le<uint16_t,uint16_t>(buf);
        fieldU32List = codec::get_basic_type_le<uint16_t,uint32_t>(buf);
        fieldU64List = codec::get_basic_type_le<uint16_t,uint64_t>(buf);
        fieldF32List = codec::get_basic_type_le<uint16_t,float>(buf);
        fieldF64List = codec::get_basic_type_le<uint16_t,double>(buf);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const BasicPacket*>(&other);
        if(!checkType) return false;
        return fieldI8 == checkType->fieldI8
               && fieldI16 == checkType->fieldI16
               && fieldI32 == checkType->fieldI32
               && fieldI64 == checkType->fieldI64
               && fieldChar == checkType->fieldChar
               && fieldU8 == checkType->fieldU8
               && fieldU16 == checkType->fieldU16
               && fieldU32 == checkType->fieldU32
               && fieldU64 == checkType->fieldU64
               && fieldF32 == checkType->fieldF32
               && fieldF64 == checkType->fieldF64
               && fieldI8List == checkType->fieldI8List
               && fieldI16List == checkType->fieldI16List
               && fieldI32List == checkType->fieldI32List
               && fieldI64List == checkType->fieldI64List
               && fieldCharList == checkType->fieldCharList
               && fieldU8List == checkType->fieldU8List
               && fieldU16List == checkType->fieldU16List
               && fieldU32List == checkType->fieldU32List
               && fieldU64List == checkType->fieldU64List
               && fieldF32List == checkType->fieldF32List
               && fieldF64List == checkType->fieldF64List;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "BasicPacket { "
        << "fieldI8: " << static_cast<int>(fieldI8)
        << ", "
        << "fieldI16: " << std::to_string(fieldI16)
        << ", "
        << "fieldI32: " << std::to_string(fieldI32)
        << ", "
        << "fieldI64: " << std::to_string(fieldI64)
        << ", "
        << "fieldChar: " << fieldChar
        << ", "
        << "fieldU8: " << static_cast<unsigned>(fieldU8)
        << ", "
        << "fieldU16: " << std::to_string(fieldU16)
        << ", "
        << "fieldU32: " << std::to_string(fieldU32)
        << ", "
        << "fieldU64: " << std::to_string(fieldU64)
        << ", "
        << "fieldF32: " << std::fixed << std::setprecision(6) << fieldF32
        << ", "
        << "fieldF64: " << std::fixed << std::setprecision(6) << fieldF64
        << ", "
        << "fieldI8List: " << codec::join_vector<int8_t>(fieldI8List)
        << ", "
        << "fieldI16List: " << codec::join_vector<int16_t>(fieldI16List)
        << ", "
        << "fieldI32List: " << codec::join_vector<int32_t>(fieldI32List)
        << ", "
        << "fieldI64List: " << codec::join_vector<int64_t>(fieldI64List)
        << ", "
        << "fieldCharList: " << codec::join_vector<std::string>(fieldCharList)
        << ", "
        << "fieldU8List: " << codec::join_vector<uint8_t>(fieldU8List)
        << ", "
        << "fieldU16List: " << codec::join_vector<uint16_t>(fieldU16List)
        << ", "
        << "fieldU32List: " << codec::join_vector<uint32_t>(fieldU32List)
        << ", "
        << "fieldU64List: " << codec::join_vector<uint64_t>(fieldU64List)
        << ", "
        << "fieldF32List: " << codec::join_vector<float>(fieldF32List)
        << ", "
        << "fieldF64List: " << codec::join_vector<double>(fieldF64List)
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const BasicPacket& pkt) {
    return os << pkt.toString();
}


struct StringPacket : public codec::BinaryCodec {
    std::string fieldDynamicString;
    std::string fieldDynamicString1;
    std::string fieldFixedString1;
    std::string fieldFixedString10;
    std::vector<std::string> fieldDynamicStringList;
    std::vector<std::string> fieldDynamicString1List;
    std::vector<std::string> fieldFixedString1List;
    std::vector<std::string> fieldFixedString10List;

    void encode(ByteBuf& buf) const override {
        codec::put_string_le<uint16_t>(buf, fieldDynamicString);
        codec::put_string_le<uint16_t>(buf, fieldDynamicString1);
        codec::put_fixed_string(buf, fieldFixedString1, 1);
        codec::put_fixed_string(buf, fieldFixedString10, 10);
        codec::put_string_list_le<uint16_t,uint16_t>(buf, fieldDynamicStringList);
        codec::put_string_list_le<uint16_t,uint16_t>(buf, fieldDynamicString1List);
        codec::put_fixed_string_list_le<uint16_t>(buf, fieldFixedString1List, 1);
        codec::put_fixed_string_list_le<uint16_t>(buf, fieldFixedString10List, 10);
    }
    

    void decode(ByteBuf& buf) override {
        fieldDynamicString = codec::get_string_le<uint16_t>(buf);
        fieldDynamicString1 = codec::get_string_le<uint16_t>(buf);
        fieldFixedString1 = codec::get_fixed_string(buf, 1);
        fieldFixedString10 = codec::get_fixed_string(buf, 10);
        fieldDynamicStringList = codec::get_string_list_le<uint16_t,uint16_t>(buf);
        fieldDynamicString1List = codec::get_string_list_le<uint16_t,uint16_t>(buf);
        fieldFixedString1List = codec::get_fixed_string_list_le<uint16_t>(buf, 1);
        fieldFixedString10List = codec::get_fixed_string_list_le<uint16_t>(buf, 10);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const StringPacket*>(&other);
        if(!checkType) return false;
        return fieldDynamicString == checkType->fieldDynamicString
               && fieldDynamicString1 == checkType->fieldDynamicString1
               && fieldFixedString1 == checkType->fieldFixedString1
               && fieldFixedString10 == checkType->fieldFixedString10
               && fieldDynamicStringList == checkType->fieldDynamicStringList
               && fieldDynamicString1List == checkType->fieldDynamicString1List
               && fieldFixedString1List == checkType->fieldFixedString1List
               && fieldFixedString10List == checkType->fieldFixedString10List;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "StringPacket { "
        << "fieldDynamicString: " << fieldDynamicString
        << ", "
        << "fieldDynamicString1: " << fieldDynamicString1
        << ", "
        << "fieldFixedString1: " << fieldFixedString1
        << ", "
        << "fieldFixedString10: " << fieldFixedString10
        << ", "
        << "fieldDynamicStringList: " << codec::join_vector<std::string>(fieldDynamicStringList)
        << ", "
        << "fieldDynamicString1List: " << codec::join_vector<std::string>(fieldDynamicString1List)
        << ", "
        << "fieldFixedString1List: " << codec::join_vector<std::string>(fieldFixedString1List)
        << ", "
        << "fieldFixedString10List: " << codec::join_vector<std::string>(fieldFixedString10List)
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const StringPacket& pkt) {
    return os << pkt.toString();
}


struct SubPacket : public codec::BinaryCodec {
    uint32_t fieldU32;
    std::vector<int16_t> fieldI16List;

    void encode(ByteBuf& buf) const override {
        buf.write_u32_le(fieldU32);
        codec::put_basic_type_le<uint16_t,int16_t>(buf,fieldI16List);
    }
    

    void decode(ByteBuf& buf) override {
        fieldU32 = buf.read_u32_le();
        fieldI16List = codec::get_basic_type_le<uint16_t,int16_t>(buf);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const SubPacket*>(&other);
        if(!checkType) return false;
        return fieldU32 == checkType->fieldU32
               && fieldI16List == checkType->fieldI16List;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "SubPacket { "
        << "fieldU32: " << std::to_string(fieldU32)
        << ", "
        << "fieldI16List: " << codec::join_vector<int16_t>(fieldI16List)
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const SubPacket& pkt) {
    return os << pkt.toString();
}



struct InerPacket : public codec::BinaryCodec {
    uint32_t fieldU32;
    std::vector<int16_t> fieldI16List;

    void encode(ByteBuf& buf) const override {
        buf.write_u32_le(fieldU32);
        codec::put_basic_type_le<uint16_t,int16_t>(buf,fieldI16List);
    }
    

    void decode(ByteBuf& buf) override {
        fieldU32 = buf.read_u32_le();
        fieldI16List = codec::get_basic_type_le<uint16_t,int16_t>(buf);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const InerPacket*>(&other);
        if(!checkType) return false;
        return fieldU32 == checkType->fieldU32
               && fieldI16List == checkType->fieldI16List;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "InerPacket { "
        << "fieldU32: " << std::to_string(fieldU32)
        << ", "
        << "fieldI16List: " << codec::join_vector<int16_t>(fieldI16List)
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const InerPacket& pkt) {
    return os << pkt.toString();
}


struct NestedPacket : public codec::BinaryCodec {
    SubPacket subPacket;
    std::vector<SubPacket> subPacketList;
    InerPacket inerPacket;

    void encode(ByteBuf& buf) const override {
        subPacket.encode(buf);
        codec::put_object_List_le<uint16_t>(buf,subPacketList);
        inerPacket.encode(buf);
    }
    

    void decode(ByteBuf& buf) override {
        subPacket.decode(buf);
        subPacketList = codec::get_object_List_le<uint16_t,SubPacket>(buf);
        inerPacket.decode(buf);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const NestedPacket*>(&other);
        if(!checkType) return false;
        return subPacket == checkType->subPacket
               && subPacketList == checkType->subPacketList
               && inerPacket == checkType->inerPacket;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "NestedPacket { "
        << "SubPacket: " << subPacket.toString()
        << ", "
        << "SubPacketList: " << codec::join_vector<SubPacket>(subPacketList)
        << ", "
        << "InerPacket: " << inerPacket.toString()
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const NestedPacket& pkt) {
    return os << pkt.toString();
}



struct EmptyPacket : public codec::BinaryCodec {

    void encode(ByteBuf& buf) const override {
    }
    

    void decode(ByteBuf& buf) override {
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const EmptyPacket*>(&other);
        if(!checkType) return false;
        return true;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "EmptyPacket { "
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const EmptyPacket& pkt) {
    return os << pkt.toString();
}






static const std::unordered_map<uint16_t,std::function<std::unique_ptr<codec::BinaryCodec>()>> RootPacketMsgTypeFactoryMap = {
    {1, [] { return std::make_unique<BasicPacket>(); }},
    {2, [] { return std::make_unique<StringPacket>(); }},
    {3, [] { return std::make_unique<NestedPacket>(); }},
    {4, [] { return std::make_unique<EmptyPacket>(); }},
};
struct RootPacket : public codec::BinaryCodec {
    uint16_t msgType;
    uint32_t payloadLen;
    std::unique_ptr<codec::BinaryCodec> payload;
    uint32_t checksum;

    void encode(ByteBuf& buf) const override {
        buf.write_u16_le(msgType);
        ByteBuf payloadBuf;
        payload->encode(payloadBuf);
        auto payloadLen_ = static_cast<uint32_t>(payloadBuf.readable_bytes());
        buf.write_u32_le(payloadLen_);
        buf.write_bytes(payloadBuf.data().data(), payloadLen_);
        auto service = ChecksumServiceContext::instance().get<ByteBuf, uint32_t>("CRC32");
        if(service != nullptr){
            auto cs = service->calc(buf);
            buf.write_u32_le(cs);
        } else {
            buf.write_u32_le(checksum);
        }
    }
    

    void decode(ByteBuf& buf) override {
        msgType = buf.read_u16_le();
        payloadLen = buf.read_u32_le();
        auto it = RootPacketMsgTypeFactoryMap.find(msgType);
        if(it != RootPacketMsgTypeFactoryMap.end()) {
            payload = it->second();
        } else {
            throw std::runtime_error("Unknow match key:" + msgType);
        }
        payload->decode(buf);
        checksum = buf.read_u32_le();
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const RootPacket*>(&other);
        if(!checkType) return false;
        return msgType == checkType->msgType
               && payloadLen == checkType->payloadLen
               && payload->equals(*checkType->payload)
               && checksum == checkType->checksum;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "RootPacket { "
        << "MsgType: " << std::to_string(msgType)
        << ", "
        << "PayloadLen: " << std::to_string(payloadLen)
        << ", "
        << "Payload: " << payload->toString()
        << ", "
        << "Checksum: " << std::to_string(checksum)
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const RootPacket& pkt) {
    return os << pkt.toString();
}


