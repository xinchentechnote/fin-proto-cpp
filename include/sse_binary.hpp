// Copyright 2025 xinchentechnote
// Code generated by fin-protoc. DO NOT EDIT.
#pragma once
#include <cstdint>
#include <functional>
#include <iomanip>
#include <memory>
#include <string>
#include <unordered_map>
#include <vector>
#include <iostream>
#include "include/codec.hpp"
#include "include/bytebuf.hpp"
#include "include/checksum.hpp"

struct Heartbeat : public codec::BinaryCodec {

    void encode(ByteBuf& buf) const override {
    }
    

    void decode(ByteBuf& buf) override {
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const Heartbeat*>(&other);
        if(!checkType) return false;
        return true;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "Heartbeat { "
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const Heartbeat& pkt) {
    return os << pkt.toString();
}


struct Logon : public codec::BinaryCodec {
    std::string senderCompId;
    std::string targetCompId;
    uint16_t heartBtInt;
    std::string prtclVersion;
    uint32_t tradeDate;
    uint32_t qsize;

    void encode(ByteBuf& buf) const override {
        codec::put_fixed_string(buf, senderCompId, 32);
        codec::put_fixed_string(buf, targetCompId, 32);
        buf.write_u16(heartBtInt);
        codec::put_fixed_string(buf, prtclVersion, 8);
        buf.write_u32(tradeDate);
        buf.write_u32(qsize);
    }
    

    void decode(ByteBuf& buf) override {
        senderCompId = codec::get_fixed_string(buf, 32);
        targetCompId = codec::get_fixed_string(buf, 32);
        heartBtInt = buf.read_u16();
        prtclVersion = codec::get_fixed_string(buf, 8);
        tradeDate = buf.read_u32();
        qsize = buf.read_u32();
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const Logon*>(&other);
        if(!checkType) return false;
        return senderCompId == checkType->senderCompId
               && targetCompId == checkType->targetCompId
               && heartBtInt == checkType->heartBtInt
               && prtclVersion == checkType->prtclVersion
               && tradeDate == checkType->tradeDate
               && qsize == checkType->qsize;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "Logon { "
        << "SenderCompID: " << senderCompId
        << ", "
        << "TargetCompID: " << targetCompId
        << ", "
        << "HeartBtInt: " << std::to_string(heartBtInt)
        << ", "
        << "PrtclVersion: " << prtclVersion
        << ", "
        << "TradeDate: " << std::to_string(tradeDate)
        << ", "
        << "QSize: " << std::to_string(qsize)
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const Logon& pkt) {
    return os << pkt.toString();
}


struct Logout : public codec::BinaryCodec {
    uint32_t sessionStatus;
    std::string text;

    void encode(ByteBuf& buf) const override {
        buf.write_u32(sessionStatus);
        codec::put_fixed_string(buf, text, 64);
    }
    

    void decode(ByteBuf& buf) override {
        sessionStatus = buf.read_u32();
        text = codec::get_fixed_string(buf, 64);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const Logout*>(&other);
        if(!checkType) return false;
        return sessionStatus == checkType->sessionStatus
               && text == checkType->text;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "Logout { "
        << "SessionStatus: " << std::to_string(sessionStatus)
        << ", "
        << "Text: " << text
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const Logout& pkt) {
    return os << pkt.toString();
}


struct NewOrderSingle : public codec::BinaryCodec {
    uint32_t bizId;
    std::string bizPbu;
    std::string clOrdId;
    std::string securityId;
    std::string account;
    uint8_t ownerType;
    std::string side;
    int64_t price;
    int64_t orderQty;
    std::string ordType;
    std::string timeInForce;
    uint64_t transactTime;
    std::string creditTag;
    std::string clearingFirm;
    std::string branchId;
    std::string userInfo;

    void encode(ByteBuf& buf) const override {
        buf.write_u32(bizId);
        codec::put_fixed_string(buf, bizPbu, 8);
        codec::put_fixed_string(buf, clOrdId, 10);
        codec::put_fixed_string(buf, securityId, 12);
        codec::put_fixed_string(buf, account, 13);
        buf.write_u8(ownerType);
        codec::put_fixed_string(buf, side, 1);
        buf.write_i64(price);
        buf.write_i64(orderQty);
        codec::put_fixed_string(buf, ordType, 1);
        codec::put_fixed_string(buf, timeInForce, 1);
        buf.write_u64(transactTime);
        codec::put_fixed_string(buf, creditTag, 2);
        codec::put_fixed_string(buf, clearingFirm, 8);
        codec::put_fixed_string(buf, branchId, 8);
        codec::put_fixed_string(buf, userInfo, 32);
    }
    

    void decode(ByteBuf& buf) override {
        bizId = buf.read_u32();
        bizPbu = codec::get_fixed_string(buf, 8);
        clOrdId = codec::get_fixed_string(buf, 10);
        securityId = codec::get_fixed_string(buf, 12);
        account = codec::get_fixed_string(buf, 13);
        ownerType = buf.read_u8();
        side = codec::get_fixed_string(buf, 1);
        price = buf.read_i64();
        orderQty = buf.read_i64();
        ordType = codec::get_fixed_string(buf, 1);
        timeInForce = codec::get_fixed_string(buf, 1);
        transactTime = buf.read_u64();
        creditTag = codec::get_fixed_string(buf, 2);
        clearingFirm = codec::get_fixed_string(buf, 8);
        branchId = codec::get_fixed_string(buf, 8);
        userInfo = codec::get_fixed_string(buf, 32);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const NewOrderSingle*>(&other);
        if(!checkType) return false;
        return bizId == checkType->bizId
               && bizPbu == checkType->bizPbu
               && clOrdId == checkType->clOrdId
               && securityId == checkType->securityId
               && account == checkType->account
               && ownerType == checkType->ownerType
               && side == checkType->side
               && price == checkType->price
               && orderQty == checkType->orderQty
               && ordType == checkType->ordType
               && timeInForce == checkType->timeInForce
               && transactTime == checkType->transactTime
               && creditTag == checkType->creditTag
               && clearingFirm == checkType->clearingFirm
               && branchId == checkType->branchId
               && userInfo == checkType->userInfo;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "NewOrderSingle { "
        << "BizID: " << std::to_string(bizId)
        << ", "
        << "BizPbu: " << bizPbu
        << ", "
        << "ClOrdID: " << clOrdId
        << ", "
        << "SecurityID: " << securityId
        << ", "
        << "Account: " << account
        << ", "
        << "OwnerType: " << static_cast<unsigned>(ownerType)
        << ", "
        << "Side: " << side
        << ", "
        << "Price: " << std::to_string(price)
        << ", "
        << "OrderQty: " << std::to_string(orderQty)
        << ", "
        << "OrdType: " << ordType
        << ", "
        << "TimeInForce: " << timeInForce
        << ", "
        << "TransactTime: " << std::to_string(transactTime)
        << ", "
        << "CreditTag: " << creditTag
        << ", "
        << "ClearingFirm: " << clearingFirm
        << ", "
        << "BranchID: " << branchId
        << ", "
        << "UserInfo: " << userInfo
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const NewOrderSingle& pkt) {
    return os << pkt.toString();
}


struct OrderCancel : public codec::BinaryCodec {
    uint32_t bizId;
    std::string bizPbu;
    std::string clOrdId;
    std::string securityId;
    std::string account;
    uint8_t ownerType;
    std::string side;
    std::string origClOrdId;
    uint64_t transactTime;
    std::string branchId;
    std::string userInfo;

    void encode(ByteBuf& buf) const override {
        buf.write_u32(bizId);
        codec::put_fixed_string(buf, bizPbu, 8);
        codec::put_fixed_string(buf, clOrdId, 10);
        codec::put_fixed_string(buf, securityId, 12);
        codec::put_fixed_string(buf, account, 13);
        buf.write_u8(ownerType);
        codec::put_fixed_string(buf, side, 1);
        codec::put_fixed_string(buf, origClOrdId, 10);
        buf.write_u64(transactTime);
        codec::put_fixed_string(buf, branchId, 8);
        codec::put_fixed_string(buf, userInfo, 32);
    }
    

    void decode(ByteBuf& buf) override {
        bizId = buf.read_u32();
        bizPbu = codec::get_fixed_string(buf, 8);
        clOrdId = codec::get_fixed_string(buf, 10);
        securityId = codec::get_fixed_string(buf, 12);
        account = codec::get_fixed_string(buf, 13);
        ownerType = buf.read_u8();
        side = codec::get_fixed_string(buf, 1);
        origClOrdId = codec::get_fixed_string(buf, 10);
        transactTime = buf.read_u64();
        branchId = codec::get_fixed_string(buf, 8);
        userInfo = codec::get_fixed_string(buf, 32);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const OrderCancel*>(&other);
        if(!checkType) return false;
        return bizId == checkType->bizId
               && bizPbu == checkType->bizPbu
               && clOrdId == checkType->clOrdId
               && securityId == checkType->securityId
               && account == checkType->account
               && ownerType == checkType->ownerType
               && side == checkType->side
               && origClOrdId == checkType->origClOrdId
               && transactTime == checkType->transactTime
               && branchId == checkType->branchId
               && userInfo == checkType->userInfo;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "OrderCancel { "
        << "BizID: " << std::to_string(bizId)
        << ", "
        << "BizPbu: " << bizPbu
        << ", "
        << "ClOrdID: " << clOrdId
        << ", "
        << "SecurityID: " << securityId
        << ", "
        << "Account: " << account
        << ", "
        << "OwnerType: " << static_cast<unsigned>(ownerType)
        << ", "
        << "Side: " << side
        << ", "
        << "OrigClOrdID: " << origClOrdId
        << ", "
        << "TransactTime: " << std::to_string(transactTime)
        << ", "
        << "BranchID: " << branchId
        << ", "
        << "UserInfo: " << userInfo
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const OrderCancel& pkt) {
    return os << pkt.toString();
}


struct Confirm : public codec::BinaryCodec {
    std::string pbu;
    uint32_t setId;
    uint64_t reportIndex;
    uint32_t bizId;
    std::string execType;
    std::string bizPbu;
    std::string clOrdId;
    std::string securityId;
    std::string account;
    uint8_t ownerType;
    std::string side;
    int64_t price;
    int64_t orderQty;
    int64_t leavesQty;
    int64_t cxlQty;
    std::string ordType;
    std::string timeInForce;
    std::string ordStatus;
    std::string creditTag;
    std::string origClOrdId;
    std::string clearingFirm;
    std::string branchId;
    uint32_t ordRejReason;
    std::string ordCnfmId;
    std::string origOrdCnfmId;
    uint32_t tradeDate;
    uint64_t transactTime;
    std::string userInfo;

    void encode(ByteBuf& buf) const override {
        codec::put_fixed_string(buf, pbu, 8);
        buf.write_u32(setId);
        buf.write_u64(reportIndex);
        buf.write_u32(bizId);
        codec::put_fixed_string(buf, execType, 1);
        codec::put_fixed_string(buf, bizPbu, 8);
        codec::put_fixed_string(buf, clOrdId, 10);
        codec::put_fixed_string(buf, securityId, 12);
        codec::put_fixed_string(buf, account, 13);
        buf.write_u8(ownerType);
        codec::put_fixed_string(buf, side, 1);
        buf.write_i64(price);
        buf.write_i64(orderQty);
        buf.write_i64(leavesQty);
        buf.write_i64(cxlQty);
        codec::put_fixed_string(buf, ordType, 1);
        codec::put_fixed_string(buf, timeInForce, 1);
        codec::put_fixed_string(buf, ordStatus, 1);
        codec::put_fixed_string(buf, creditTag, 2);
        codec::put_fixed_string(buf, origClOrdId, 10);
        codec::put_fixed_string(buf, clearingFirm, 8);
        codec::put_fixed_string(buf, branchId, 8);
        buf.write_u32(ordRejReason);
        codec::put_fixed_string(buf, ordCnfmId, 16);
        codec::put_fixed_string(buf, origOrdCnfmId, 16);
        buf.write_u32(tradeDate);
        buf.write_u64(transactTime);
        codec::put_fixed_string(buf, userInfo, 32);
    }
    

    void decode(ByteBuf& buf) override {
        pbu = codec::get_fixed_string(buf, 8);
        setId = buf.read_u32();
        reportIndex = buf.read_u64();
        bizId = buf.read_u32();
        execType = codec::get_fixed_string(buf, 1);
        bizPbu = codec::get_fixed_string(buf, 8);
        clOrdId = codec::get_fixed_string(buf, 10);
        securityId = codec::get_fixed_string(buf, 12);
        account = codec::get_fixed_string(buf, 13);
        ownerType = buf.read_u8();
        side = codec::get_fixed_string(buf, 1);
        price = buf.read_i64();
        orderQty = buf.read_i64();
        leavesQty = buf.read_i64();
        cxlQty = buf.read_i64();
        ordType = codec::get_fixed_string(buf, 1);
        timeInForce = codec::get_fixed_string(buf, 1);
        ordStatus = codec::get_fixed_string(buf, 1);
        creditTag = codec::get_fixed_string(buf, 2);
        origClOrdId = codec::get_fixed_string(buf, 10);
        clearingFirm = codec::get_fixed_string(buf, 8);
        branchId = codec::get_fixed_string(buf, 8);
        ordRejReason = buf.read_u32();
        ordCnfmId = codec::get_fixed_string(buf, 16);
        origOrdCnfmId = codec::get_fixed_string(buf, 16);
        tradeDate = buf.read_u32();
        transactTime = buf.read_u64();
        userInfo = codec::get_fixed_string(buf, 32);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const Confirm*>(&other);
        if(!checkType) return false;
        return pbu == checkType->pbu
               && setId == checkType->setId
               && reportIndex == checkType->reportIndex
               && bizId == checkType->bizId
               && execType == checkType->execType
               && bizPbu == checkType->bizPbu
               && clOrdId == checkType->clOrdId
               && securityId == checkType->securityId
               && account == checkType->account
               && ownerType == checkType->ownerType
               && side == checkType->side
               && price == checkType->price
               && orderQty == checkType->orderQty
               && leavesQty == checkType->leavesQty
               && cxlQty == checkType->cxlQty
               && ordType == checkType->ordType
               && timeInForce == checkType->timeInForce
               && ordStatus == checkType->ordStatus
               && creditTag == checkType->creditTag
               && origClOrdId == checkType->origClOrdId
               && clearingFirm == checkType->clearingFirm
               && branchId == checkType->branchId
               && ordRejReason == checkType->ordRejReason
               && ordCnfmId == checkType->ordCnfmId
               && origOrdCnfmId == checkType->origOrdCnfmId
               && tradeDate == checkType->tradeDate
               && transactTime == checkType->transactTime
               && userInfo == checkType->userInfo;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "Confirm { "
        << "Pbu: " << pbu
        << ", "
        << "SetID: " << std::to_string(setId)
        << ", "
        << "ReportIndex: " << std::to_string(reportIndex)
        << ", "
        << "BizID: " << std::to_string(bizId)
        << ", "
        << "ExecType: " << execType
        << ", "
        << "BizPbu: " << bizPbu
        << ", "
        << "ClOrdID: " << clOrdId
        << ", "
        << "SecurityID: " << securityId
        << ", "
        << "Account: " << account
        << ", "
        << "OwnerType: " << static_cast<unsigned>(ownerType)
        << ", "
        << "Side: " << side
        << ", "
        << "Price: " << std::to_string(price)
        << ", "
        << "OrderQty: " << std::to_string(orderQty)
        << ", "
        << "LeavesQty: " << std::to_string(leavesQty)
        << ", "
        << "CxlQty: " << std::to_string(cxlQty)
        << ", "
        << "OrdType: " << ordType
        << ", "
        << "TimeInForce: " << timeInForce
        << ", "
        << "OrdStatus: " << ordStatus
        << ", "
        << "CreditTag: " << creditTag
        << ", "
        << "OrigClOrdID: " << origClOrdId
        << ", "
        << "ClearingFirm: " << clearingFirm
        << ", "
        << "BranchID: " << branchId
        << ", "
        << "OrdRejReason: " << std::to_string(ordRejReason)
        << ", "
        << "OrdCnfmID: " << ordCnfmId
        << ", "
        << "OrigOrdCnfmID: " << origOrdCnfmId
        << ", "
        << "TradeDate: " << std::to_string(tradeDate)
        << ", "
        << "TransactTime: " << std::to_string(transactTime)
        << ", "
        << "UserInfo: " << userInfo
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const Confirm& pkt) {
    return os << pkt.toString();
}


struct CancelReject : public codec::BinaryCodec {
    std::string pbu;
    uint32_t setId;
    uint64_t reportIndex;
    uint32_t bizId;
    std::string bizPbu;
    std::string clOrdId;
    std::string securityId;
    std::string origClOrdId;
    std::string branchId;
    uint32_t cxlRejReason;
    uint32_t tradeDate;
    uint64_t transactTime;
    std::string userInfo;

    void encode(ByteBuf& buf) const override {
        codec::put_fixed_string(buf, pbu, 8);
        buf.write_u32(setId);
        buf.write_u64(reportIndex);
        buf.write_u32(bizId);
        codec::put_fixed_string(buf, bizPbu, 8);
        codec::put_fixed_string(buf, clOrdId, 10);
        codec::put_fixed_string(buf, securityId, 12);
        codec::put_fixed_string(buf, origClOrdId, 10);
        codec::put_fixed_string(buf, branchId, 8);
        buf.write_u32(cxlRejReason);
        buf.write_u32(tradeDate);
        buf.write_u64(transactTime);
        codec::put_fixed_string(buf, userInfo, 32);
    }
    

    void decode(ByteBuf& buf) override {
        pbu = codec::get_fixed_string(buf, 8);
        setId = buf.read_u32();
        reportIndex = buf.read_u64();
        bizId = buf.read_u32();
        bizPbu = codec::get_fixed_string(buf, 8);
        clOrdId = codec::get_fixed_string(buf, 10);
        securityId = codec::get_fixed_string(buf, 12);
        origClOrdId = codec::get_fixed_string(buf, 10);
        branchId = codec::get_fixed_string(buf, 8);
        cxlRejReason = buf.read_u32();
        tradeDate = buf.read_u32();
        transactTime = buf.read_u64();
        userInfo = codec::get_fixed_string(buf, 32);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const CancelReject*>(&other);
        if(!checkType) return false;
        return pbu == checkType->pbu
               && setId == checkType->setId
               && reportIndex == checkType->reportIndex
               && bizId == checkType->bizId
               && bizPbu == checkType->bizPbu
               && clOrdId == checkType->clOrdId
               && securityId == checkType->securityId
               && origClOrdId == checkType->origClOrdId
               && branchId == checkType->branchId
               && cxlRejReason == checkType->cxlRejReason
               && tradeDate == checkType->tradeDate
               && transactTime == checkType->transactTime
               && userInfo == checkType->userInfo;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "CancelReject { "
        << "Pbu: " << pbu
        << ", "
        << "SetID: " << std::to_string(setId)
        << ", "
        << "ReportIndex: " << std::to_string(reportIndex)
        << ", "
        << "BizID: " << std::to_string(bizId)
        << ", "
        << "BizPbu: " << bizPbu
        << ", "
        << "ClOrdID: " << clOrdId
        << ", "
        << "SecurityID: " << securityId
        << ", "
        << "OrigClOrdID: " << origClOrdId
        << ", "
        << "BranchID: " << branchId
        << ", "
        << "CxlRejReason: " << std::to_string(cxlRejReason)
        << ", "
        << "TradeDate: " << std::to_string(tradeDate)
        << ", "
        << "TransactTime: " << std::to_string(transactTime)
        << ", "
        << "UserInfo: " << userInfo
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const CancelReject& pkt) {
    return os << pkt.toString();
}


struct Report : public codec::BinaryCodec {
    std::string pbu;
    uint32_t setId;
    uint64_t reportIndex;
    uint32_t bizId;
    std::string execType;
    std::string bizPbu;
    std::string clOrdId;
    std::string securityId;
    std::string account;
    uint8_t ownerType;
    std::string side;
    int64_t price;
    int64_t orderQty;
    int64_t leavesQty;
    int64_t cxlQty;
    std::string ordType;
    std::string timeInForce;
    std::string ordStatus;
    std::string creditTag;
    std::string origClOrdId;
    std::string clearingFirm;
    std::string branchId;
    uint32_t ordRejReason;
    std::string ordCnfmId;
    std::string origOrdCnfmId;
    uint32_t tradeDate;
    uint64_t transactTime;
    std::string userInfo;

    void encode(ByteBuf& buf) const override {
        codec::put_fixed_string(buf, pbu, 8);
        buf.write_u32(setId);
        buf.write_u64(reportIndex);
        buf.write_u32(bizId);
        codec::put_fixed_string(buf, execType, 1);
        codec::put_fixed_string(buf, bizPbu, 8);
        codec::put_fixed_string(buf, clOrdId, 10);
        codec::put_fixed_string(buf, securityId, 12);
        codec::put_fixed_string(buf, account, 13);
        buf.write_u8(ownerType);
        codec::put_fixed_string(buf, side, 1);
        buf.write_i64(price);
        buf.write_i64(orderQty);
        buf.write_i64(leavesQty);
        buf.write_i64(cxlQty);
        codec::put_fixed_string(buf, ordType, 1);
        codec::put_fixed_string(buf, timeInForce, 1);
        codec::put_fixed_string(buf, ordStatus, 1);
        codec::put_fixed_string(buf, creditTag, 2);
        codec::put_fixed_string(buf, origClOrdId, 10);
        codec::put_fixed_string(buf, clearingFirm, 8);
        codec::put_fixed_string(buf, branchId, 8);
        buf.write_u32(ordRejReason);
        codec::put_fixed_string(buf, ordCnfmId, 16);
        codec::put_fixed_string(buf, origOrdCnfmId, 16);
        buf.write_u32(tradeDate);
        buf.write_u64(transactTime);
        codec::put_fixed_string(buf, userInfo, 32);
    }
    

    void decode(ByteBuf& buf) override {
        pbu = codec::get_fixed_string(buf, 8);
        setId = buf.read_u32();
        reportIndex = buf.read_u64();
        bizId = buf.read_u32();
        execType = codec::get_fixed_string(buf, 1);
        bizPbu = codec::get_fixed_string(buf, 8);
        clOrdId = codec::get_fixed_string(buf, 10);
        securityId = codec::get_fixed_string(buf, 12);
        account = codec::get_fixed_string(buf, 13);
        ownerType = buf.read_u8();
        side = codec::get_fixed_string(buf, 1);
        price = buf.read_i64();
        orderQty = buf.read_i64();
        leavesQty = buf.read_i64();
        cxlQty = buf.read_i64();
        ordType = codec::get_fixed_string(buf, 1);
        timeInForce = codec::get_fixed_string(buf, 1);
        ordStatus = codec::get_fixed_string(buf, 1);
        creditTag = codec::get_fixed_string(buf, 2);
        origClOrdId = codec::get_fixed_string(buf, 10);
        clearingFirm = codec::get_fixed_string(buf, 8);
        branchId = codec::get_fixed_string(buf, 8);
        ordRejReason = buf.read_u32();
        ordCnfmId = codec::get_fixed_string(buf, 16);
        origOrdCnfmId = codec::get_fixed_string(buf, 16);
        tradeDate = buf.read_u32();
        transactTime = buf.read_u64();
        userInfo = codec::get_fixed_string(buf, 32);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const Report*>(&other);
        if(!checkType) return false;
        return pbu == checkType->pbu
               && setId == checkType->setId
               && reportIndex == checkType->reportIndex
               && bizId == checkType->bizId
               && execType == checkType->execType
               && bizPbu == checkType->bizPbu
               && clOrdId == checkType->clOrdId
               && securityId == checkType->securityId
               && account == checkType->account
               && ownerType == checkType->ownerType
               && side == checkType->side
               && price == checkType->price
               && orderQty == checkType->orderQty
               && leavesQty == checkType->leavesQty
               && cxlQty == checkType->cxlQty
               && ordType == checkType->ordType
               && timeInForce == checkType->timeInForce
               && ordStatus == checkType->ordStatus
               && creditTag == checkType->creditTag
               && origClOrdId == checkType->origClOrdId
               && clearingFirm == checkType->clearingFirm
               && branchId == checkType->branchId
               && ordRejReason == checkType->ordRejReason
               && ordCnfmId == checkType->ordCnfmId
               && origOrdCnfmId == checkType->origOrdCnfmId
               && tradeDate == checkType->tradeDate
               && transactTime == checkType->transactTime
               && userInfo == checkType->userInfo;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "Report { "
        << "Pbu: " << pbu
        << ", "
        << "SetID: " << std::to_string(setId)
        << ", "
        << "ReportIndex: " << std::to_string(reportIndex)
        << ", "
        << "BizID: " << std::to_string(bizId)
        << ", "
        << "ExecType: " << execType
        << ", "
        << "BizPbu: " << bizPbu
        << ", "
        << "ClOrdID: " << clOrdId
        << ", "
        << "SecurityID: " << securityId
        << ", "
        << "Account: " << account
        << ", "
        << "OwnerType: " << static_cast<unsigned>(ownerType)
        << ", "
        << "Side: " << side
        << ", "
        << "Price: " << std::to_string(price)
        << ", "
        << "OrderQty: " << std::to_string(orderQty)
        << ", "
        << "LeavesQty: " << std::to_string(leavesQty)
        << ", "
        << "CxlQty: " << std::to_string(cxlQty)
        << ", "
        << "OrdType: " << ordType
        << ", "
        << "TimeInForce: " << timeInForce
        << ", "
        << "OrdStatus: " << ordStatus
        << ", "
        << "CreditTag: " << creditTag
        << ", "
        << "OrigClOrdID: " << origClOrdId
        << ", "
        << "ClearingFirm: " << clearingFirm
        << ", "
        << "BranchID: " << branchId
        << ", "
        << "OrdRejReason: " << std::to_string(ordRejReason)
        << ", "
        << "OrdCnfmID: " << ordCnfmId
        << ", "
        << "OrigOrdCnfmID: " << origOrdCnfmId
        << ", "
        << "TradeDate: " << std::to_string(tradeDate)
        << ", "
        << "TransactTime: " << std::to_string(transactTime)
        << ", "
        << "UserInfo: " << userInfo
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const Report& pkt) {
    return os << pkt.toString();
}


struct OrderReject : public codec::BinaryCodec {
    uint32_t bizId;
    std::string bizPbu;
    std::string clOrdId;
    std::string securityId;
    uint32_t ordRejReason;
    uint32_t tradeDate;
    uint64_t transactTime;
    std::string userInfo;

    void encode(ByteBuf& buf) const override {
        buf.write_u32(bizId);
        codec::put_fixed_string(buf, bizPbu, 8);
        codec::put_fixed_string(buf, clOrdId, 10);
        codec::put_fixed_string(buf, securityId, 12);
        buf.write_u32(ordRejReason);
        buf.write_u32(tradeDate);
        buf.write_u64(transactTime);
        codec::put_fixed_string(buf, userInfo, 32);
    }
    

    void decode(ByteBuf& buf) override {
        bizId = buf.read_u32();
        bizPbu = codec::get_fixed_string(buf, 8);
        clOrdId = codec::get_fixed_string(buf, 10);
        securityId = codec::get_fixed_string(buf, 12);
        ordRejReason = buf.read_u32();
        tradeDate = buf.read_u32();
        transactTime = buf.read_u64();
        userInfo = codec::get_fixed_string(buf, 32);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const OrderReject*>(&other);
        if(!checkType) return false;
        return bizId == checkType->bizId
               && bizPbu == checkType->bizPbu
               && clOrdId == checkType->clOrdId
               && securityId == checkType->securityId
               && ordRejReason == checkType->ordRejReason
               && tradeDate == checkType->tradeDate
               && transactTime == checkType->transactTime
               && userInfo == checkType->userInfo;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "OrderReject { "
        << "BizID: " << std::to_string(bizId)
        << ", "
        << "BizPbu: " << bizPbu
        << ", "
        << "ClOrdID: " << clOrdId
        << ", "
        << "SecurityID: " << securityId
        << ", "
        << "OrdRejReason: " << std::to_string(ordRejReason)
        << ", "
        << "TradeDate: " << std::to_string(tradeDate)
        << ", "
        << "TransactTime: " << std::to_string(transactTime)
        << ", "
        << "UserInfo: " << userInfo
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const OrderReject& pkt) {
    return os << pkt.toString();
}


struct PlatformState : public codec::BinaryCodec {
    uint16_t platformId;
    uint16_t platformState;

    void encode(ByteBuf& buf) const override {
        buf.write_u16(platformId);
        buf.write_u16(platformState);
    }
    

    void decode(ByteBuf& buf) override {
        platformId = buf.read_u16();
        platformState = buf.read_u16();
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const PlatformState*>(&other);
        if(!checkType) return false;
        return platformId == checkType->platformId
               && platformState == checkType->platformState;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "PlatformState { "
        << "PlatformID: " << std::to_string(platformId)
        << ", "
        << "PlatformState: " << std::to_string(platformState)
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const PlatformState& pkt) {
    return os << pkt.toString();
}


struct ExecRptInfo : public codec::BinaryCodec {
    uint16_t platformId;
    std::vector<std::string> pbu;
    std::vector<uint32_t> setId;

    void encode(ByteBuf& buf) const override {
        buf.write_u16(platformId);
        codec::put_fixed_string_list<uint16_t>(buf, pbu, 8);
        codec::put_basic_type<uint16_t,uint32_t>(buf,setId);
    }
    

    void decode(ByteBuf& buf) override {
        platformId = buf.read_u16();
        pbu = codec::get_fixed_string_list<uint16_t>(buf, 8);
        setId = codec::get_basic_type<uint16_t,uint32_t>(buf);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const ExecRptInfo*>(&other);
        if(!checkType) return false;
        return platformId == checkType->platformId
               && pbu == checkType->pbu
               && setId == checkType->setId;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "ExecRptInfo { "
        << "PlatformID: " << std::to_string(platformId)
        << ", "
        << "Pbu: " << codec::join_vector<std::string>(pbu)
        << ", "
        << "SetID: " << codec::join_vector<uint32_t>(setId)
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const ExecRptInfo& pkt) {
    return os << pkt.toString();
}


struct SubExecRptSync : public codec::BinaryCodec {
    std::string pbu;
    uint32_t setId;
    uint64_t beginReportIndex;

    void encode(ByteBuf& buf) const override {
        codec::put_fixed_string(buf, pbu, 8);
        buf.write_u32(setId);
        buf.write_u64(beginReportIndex);
    }
    

    void decode(ByteBuf& buf) override {
        pbu = codec::get_fixed_string(buf, 8);
        setId = buf.read_u32();
        beginReportIndex = buf.read_u64();
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const SubExecRptSync*>(&other);
        if(!checkType) return false;
        return pbu == checkType->pbu
               && setId == checkType->setId
               && beginReportIndex == checkType->beginReportIndex;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "SubExecRptSync { "
        << "Pbu: " << pbu
        << ", "
        << "SetID: " << std::to_string(setId)
        << ", "
        << "BeginReportIndex: " << std::to_string(beginReportIndex)
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const SubExecRptSync& pkt) {
    return os << pkt.toString();
}


struct ExecRptSync : public codec::BinaryCodec {
    std::vector<SubExecRptSync> subExecRptSync;

    void encode(ByteBuf& buf) const override {
        codec::put_object_List<uint16_t>(buf,subExecRptSync);
    }
    

    void decode(ByteBuf& buf) override {
        subExecRptSync = codec::get_object_List<uint16_t,SubExecRptSync>(buf);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const ExecRptSync*>(&other);
        if(!checkType) return false;
        return subExecRptSync == checkType->subExecRptSync;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "ExecRptSync { "
        << "SubExecRptSync: " << codec::join_vector<SubExecRptSync>(subExecRptSync)
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const ExecRptSync& pkt) {
    return os << pkt.toString();
}


struct SubExecRptSyncRsp : public codec::BinaryCodec {
    std::string pbu;
    uint32_t setId;
    uint64_t beginReportIndex;
    uint64_t endReportIndex;
    uint32_t rejReason;
    std::string text;

    void encode(ByteBuf& buf) const override {
        codec::put_fixed_string(buf, pbu, 8);
        buf.write_u32(setId);
        buf.write_u64(beginReportIndex);
        buf.write_u64(endReportIndex);
        buf.write_u32(rejReason);
        codec::put_fixed_string(buf, text, 64);
    }
    

    void decode(ByteBuf& buf) override {
        pbu = codec::get_fixed_string(buf, 8);
        setId = buf.read_u32();
        beginReportIndex = buf.read_u64();
        endReportIndex = buf.read_u64();
        rejReason = buf.read_u32();
        text = codec::get_fixed_string(buf, 64);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const SubExecRptSyncRsp*>(&other);
        if(!checkType) return false;
        return pbu == checkType->pbu
               && setId == checkType->setId
               && beginReportIndex == checkType->beginReportIndex
               && endReportIndex == checkType->endReportIndex
               && rejReason == checkType->rejReason
               && text == checkType->text;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "SubExecRptSyncRsp { "
        << "Pbu: " << pbu
        << ", "
        << "SetID: " << std::to_string(setId)
        << ", "
        << "BeginReportIndex: " << std::to_string(beginReportIndex)
        << ", "
        << "EndReportIndex: " << std::to_string(endReportIndex)
        << ", "
        << "RejReason: " << std::to_string(rejReason)
        << ", "
        << "Text: " << text
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const SubExecRptSyncRsp& pkt) {
    return os << pkt.toString();
}


struct ExecRptSyncRsp : public codec::BinaryCodec {
    std::vector<SubExecRptSyncRsp> subExecRptSyncRsp;

    void encode(ByteBuf& buf) const override {
        codec::put_object_List<uint16_t>(buf,subExecRptSyncRsp);
    }
    

    void decode(ByteBuf& buf) override {
        subExecRptSyncRsp = codec::get_object_List<uint16_t,SubExecRptSyncRsp>(buf);
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const ExecRptSyncRsp*>(&other);
        if(!checkType) return false;
        return subExecRptSyncRsp == checkType->subExecRptSyncRsp;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "ExecRptSyncRsp { "
        << "SubExecRptSyncRsp: " << codec::join_vector<SubExecRptSyncRsp>(subExecRptSyncRsp)
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const ExecRptSyncRsp& pkt) {
    return os << pkt.toString();
}


struct ExecRptEndOfStream : public codec::BinaryCodec {
    std::string pbu;
    uint32_t setId;
    uint64_t endReportIndex;

    void encode(ByteBuf& buf) const override {
        codec::put_fixed_string(buf, pbu, 8);
        buf.write_u32(setId);
        buf.write_u64(endReportIndex);
    }
    

    void decode(ByteBuf& buf) override {
        pbu = codec::get_fixed_string(buf, 8);
        setId = buf.read_u32();
        endReportIndex = buf.read_u64();
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const ExecRptEndOfStream*>(&other);
        if(!checkType) return false;
        return pbu == checkType->pbu
               && setId == checkType->setId
               && endReportIndex == checkType->endReportIndex;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "ExecRptEndOfStream { "
        << "Pbu: " << pbu
        << ", "
        << "SetID: " << std::to_string(setId)
        << ", "
        << "EndReportIndex: " << std::to_string(endReportIndex)
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const ExecRptEndOfStream& pkt) {
    return os << pkt.toString();
}
















static const std::unordered_map<uint32_t,std::function<std::unique_ptr<codec::BinaryCodec>()>> SseBinaryMsgTypeFactoryMap = {
    {33, [] { return std::make_unique<Heartbeat>(); }},
    {40, [] { return std::make_unique<Logon>(); }},
    {41, [] { return std::make_unique<Logout>(); }},
    {58, [] { return std::make_unique<NewOrderSingle>(); }},
    {61, [] { return std::make_unique<OrderCancel>(); }},
    {32, [] { return std::make_unique<Confirm>(); }},
    {59, [] { return std::make_unique<CancelReject>(); }},
    {103, [] { return std::make_unique<Report>(); }},
    {204, [] { return std::make_unique<OrderReject>(); }},
    {209, [] { return std::make_unique<PlatformState>(); }},
    {208, [] { return std::make_unique<ExecRptInfo>(); }},
    {206, [] { return std::make_unique<ExecRptSync>(); }},
    {207, [] { return std::make_unique<ExecRptSyncRsp>(); }},
    {210, [] { return std::make_unique<ExecRptEndOfStream>(); }},
};
struct SseBinary : public codec::BinaryCodec {
    uint32_t msgType;
    uint64_t msgSeqNum;
    uint32_t msgBodyLen;
    std::unique_ptr<codec::BinaryCodec> body;
    uint32_t checksum;

    void encode(ByteBuf& buf) const override {
        buf.write_u32(msgType);
        buf.write_u64(msgSeqNum);
        auto msgBodyLenPos = buf.writer_index();
        buf.write_u32(0);
        auto bodyStart = buf.writer_index();
        body->encode(buf);
        auto bodyEnd = buf.writer_index();
        auto bodyLen_ = static_cast<unsigned int>(bodyEnd - bodyStart);
        buf.write_u32_at(msgBodyLenPos, bodyLen_);
        auto service = ChecksumServiceContext::instance().get<ByteBuf, uint32_t>("SSE_BIN");
        if(service != nullptr){
            auto cs = service->calc(buf);
            buf.write_u32(cs);
        } else {
            buf.write_u32(checksum);
        }
    }
    

    void decode(ByteBuf& buf) override {
        msgType = buf.read_u32();
        msgSeqNum = buf.read_u64();
        msgBodyLen = buf.read_u32();
        auto it = SseBinaryMsgTypeFactoryMap.find(msgType);
        if(it != SseBinaryMsgTypeFactoryMap.end()) {
            body = it->second();
        } else {
            throw std::runtime_error("Unknow match key:" + msgType);
        }
        body->decode(buf);
        checksum = buf.read_u32();
    }
    

    bool equals(const BinaryCodec& other) const override {
        const auto* checkType = dynamic_cast<const SseBinary*>(&other);
        if(!checkType) return false;
        return msgType == checkType->msgType
               && msgSeqNum == checkType->msgSeqNum
               && msgBodyLen == checkType->msgBodyLen
               && body->equals(*checkType->body)
               && checksum == checkType->checksum;
    }
    
    std::string toString() const override {
        std::ostringstream oss;
        oss << "SseBinary { "
        << "MsgType: " << std::to_string(msgType)
        << ", "
        << "MsgSeqNum: " << std::to_string(msgSeqNum)
        << ", "
        << "MsgBodyLen: " << std::to_string(msgBodyLen)
        << ", "
        << "Body: " << body->toString()
        << ", "
        << "Checksum: " << std::to_string(checksum)
        << " }";
        return oss.str();
    }
    
};

inline std::ostream& operator<<(std::ostream& os, const SseBinary& pkt) {
    return os << pkt.toString();
}


