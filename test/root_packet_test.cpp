// Copyright 2025 xinchentechnote
// Code generated by fin-protoc. DO NOT EDIT.
#include "include/root_packet.hpp"

#include <gtest/gtest.h>

TEST(RootPacketTest, EncodeAndDecode) {
  // Create and initialize a StringPacket payload
  auto stringPayload = std::make_unique<StringPacket>();
  stringPayload->fieldDynamicString = "test";
  stringPayload->fieldDynamicString1 = "test1";
  stringPayload->fieldFixedString1 = "a";
  stringPayload->fieldFixedString10 = "abcdefghij";

  // Create original RootPacket
  RootPacket original;
  original.msgType = 2;  // StringPacket type
  original.payload = std::move(stringPayload);
  original.checksum = 0x12345678;

  // Encode the packet
  ByteBuf buf;
  original.encode(buf);

  // Decode into a new packet
  RootPacket decoded;
  decoded.decode(buf);
  original.payloadLen = decoded.payloadLen;  // Set payloadLen after decoding

  // Verify header fields
  EXPECT_EQ(original.msgType, decoded.msgType);
  EXPECT_EQ(original.checksum, decoded.checksum);

  // Verify payload type and content
  ASSERT_NE(decoded.payload, nullptr);
  auto* decodedString = dynamic_cast<StringPacket*>(decoded.payload.get());
  ASSERT_NE(decodedString, nullptr);

  EXPECT_EQ(decodedString->fieldDynamicString, "test");
  EXPECT_EQ(decodedString->fieldDynamicString1, "test1");
  EXPECT_EQ(decodedString->fieldFixedString1, "a");
  EXPECT_EQ(decodedString->fieldFixedString10, "abcdefghij");

  // Verify the complete packet equality
  EXPECT_TRUE(original == decoded);
}

TEST(BasicPacketTest, EncodeAndDeocde) {
  BasicPacket original;
  original.fieldI8 = 1;
  original.fieldI16 = 2;
  original.fieldI32 = 4;
  original.fieldI64 = 8;
  original.fieldChar = "x";
  original.fieldU8 = 1;
  original.fieldU16 = 2;
  original.fieldU32 = 4;
  original.fieldU64 = 8;
  original.fieldF32 = 4;
  original.fieldF64 = 8;
  original.fieldI8List = {1};
  original.fieldI16List = {2};
  original.fieldI32List = {4};
  original.fieldI64List = {8};
  original.fieldCharList = {"x"};
  original.fieldU8List = {1};
  original.fieldU16List = {2};
  original.fieldU32List = {4};
  original.fieldU64List = {8};
  original.fieldF32List = {4};
  original.fieldF64List = {8};
}

TEST(StringPacketTest, EncodeAndDeocde) {
  StringPacket original;
  original.fieldDynamicString = "hello";
  original.fieldDynamicString1 = "hello";
  original.fieldFixedString1 = "x";
  original.fieldFixedString10 = "xxxxxxxxxx";
  original.fieldDynamicStringList = {"hello"};
  original.fieldDynamicString1List = {"hello"};
  original.fieldFixedString1List = {"x"};
  original.fieldFixedString10List = {"xxxxxxxxxx"};
}

TEST(NestedPacketTest, EncodeAndDeocde) {
  SubPacket subPacket;
  subPacket.fieldU32 = 4;
  subPacket.fieldI16List = {2};

  SubPacket subPacketList;
  subPacketList.fieldU32 = 4;
  subPacketList.fieldI16List = {2};

  InerPacket inerPacket;
  inerPacket.fieldU32 = 4;
  inerPacket.fieldI16List = {2};

  NestedPacket original;
  original.subPacket = subPacket;
  original.subPacketList = {subPacketList};
  original.inerPacket = inerPacket;
}

TEST(SubPacketTest, EncodeAndDeocde) {
  SubPacket original;
  original.fieldU32 = 4;
  original.fieldI16List = {2};
}

TEST(EmptyPacketTest, EncodeAndDeocde) {
  EmptyPacket original;
}
